{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Networks And Distributed Applications \u00b6 This site provides documentation and resources for students participating in INFO 314 : \"Computer Networks And Distributed Applications\" . 1 If you notice a problem with the content presented here, please file an issue on the GitHub project repository . Course Site vs. Canvas \u00b6 Class documentation and troubleshooting will be slowly added to this course website in order to better support students with their assignments. If you are looking for the class schedule, information on what to read for the next class, and information on assignments, their due dates, and their deliverables, please visit the course Canvas page @ INFO 314 Canvas Homepage Asking for Help \u00b6 If you ever need help with an assignment, please refer to this page to know where to ask: Contact Us Curious on how to develop something similar to this? Follow instructions on how to setup your own MkDocs here . \u21a9","title":"Home"},{"location":"#computer-networks-and-distributed-applications","text":"This site provides documentation and resources for students participating in INFO 314 : \"Computer Networks And Distributed Applications\" . 1 If you notice a problem with the content presented here, please file an issue on the GitHub project repository .","title":"Computer Networks And Distributed Applications"},{"location":"#course-site-vs-canvas","text":"Class documentation and troubleshooting will be slowly added to this course website in order to better support students with their assignments. If you are looking for the class schedule, information on what to read for the next class, and information on assignments, their due dates, and their deliverables, please visit the course Canvas page @ INFO 314 Canvas Homepage","title":"Course Site vs. Canvas"},{"location":"#asking-for-help","text":"If you ever need help with an assignment, please refer to this page to know where to ask: Contact Us Curious on how to develop something similar to this? Follow instructions on how to setup your own MkDocs here . \u21a9","title":"Asking for Help"},{"location":"contact/","text":"Asking teaching staff for help As teaching staff, both the instructor and the teaching assistant are here to help you as much as possible. We will both be available on Slack for questions. Nevertheless it is expected that you will have attempted to solve the issue as much as possible before reaching out for help. Below are some guidelines: When should I reach out? You should reach out for help if you have: Written down what your problem is Written down why you think you are seeing this behavior Completed your own debugging Completed your own research How should I ask? It is highly encourages that you ask your questions in a Slack Channel. You will get a response back much more quickly either from a student are teaching staff this way. In your message explain the problem and what you have tried so far. If the question pertains grading or other private information, please use Canvas messaging or email one off the staff members. Our emails are listed on the Canvas page.","title":"Contact Us"},{"location":"assignments/analysis-report/","text":"Report 2 - NAT and DNS analysis \u00b6 The objective of this task is to analyze the mechanics of NAT and DNS using a variety of network utilities and to use your findings to help you answer the questions defined below. Part I: NAT Analysis \u00b6 In this section, you will use netstat and netstat-nat to analyze the state of network connections from several different perspectives on your LAN. Installation \u00b6 netstat is a powerful tool for viewing information about sockets and connections on Windows, Linux, and macOS devices. The tool is installed by default by all major desktop OS vendors, though you'll find that the command line options vary slightly between implementation. netstat-nat provides a similar interface to netstat with the purpose of diving more deeply into the behavior of routed network connections and NAT. Use apt to install netstat-nat on your Pi. Root Permissions netstat-nat requires root permissions in order to run properly on your Pi, while netstat can be run without having to invoke sudo (but may provide more detailed information when used in that way). Usage Tips \u00b6 The most common options for netstat across all three operating systems are -an . The -a option instructs netstat to display server as well as client sockets, while n disables reverse DNS resolution and keeps the output easier to interpret. Tip: Reducing netstat output netstat can produce an overwhelming amount of information. To focus your attention, you can limit the output to a single protocol, e.g., tcp or udp. The syntax for this option on Windows and macOS is -p <PROTO> , e.g., netstat -anp tcp . For Linux, use -t to select only TCP sockets and -u to select only UDP packets. When running netstat-nat , the most useful view for this combination of options will be -SNn . This will show you source and destination IP addresses as well as the entries in your Pi's NAT table associated with each connection. Analysis instructions \u00b6 Setup your computer to use the Pi as a router (wifi disabled) so that you can use netstat and netstat-nat to examine open Internet connections from multiple perspectives. You will obtain the most information by running netstat on your own computer back-to-back with netstat-nat on your Pi. You should also experiment with netstat on your Pi, though you'll find it does not show you any data about routed connections. Take some time to understand what these perspectives are showing you (it may be helpful to run netstat without -n temporarily to obtain more information about the protocols and destination hosts). Try to correlate connections shown in netstat on your computer with the connections appearing in your NAT tables. Part II: DNS Analysis \u00b6 In this section, you will use the tshark utility (a commandline version of Wireshark) in order to analyze DNS requests from the perspective of your Pi's external network interface. Install and configure tshark on your Pi and perform the two following captures of DNS as described below. Capture #1 - Perform a capture of DNS queries being routed through the Pi \u00b6 Setup your computer to use the Pi as a router (wifi disabled) and launch a tshark capture on the wlan0 port of your Pi. With tshark running, perform a manual DNS query from your computer to a public DNS resolver such as 1.1.1.1. Since your computer is now using your Pi as its default DNS resolver (based on the configuration performed by DHCP), you will need to manually override the DNS settings for your query. Info Both dig and Powershell's Resolve-DNSName command provide the functionality to override the system's default resolver. Use man or other resources to find the correct syntax for your system. Important Save a copy of your capture and make note of the domain queried. Capture #2 - Perform a capture of DNS queries being resolved by your Pi : \u00b6 Setup your computer to use the Pi as a router (wifi disabled) and launch a tshark capture on the wlan0 port of your Pi. With tshark running on your Pi , clear BIND's resolver cache on your Pi (run sudo rndc reload on the Pi) and perform a manual DNS query from your computer to the Raspberry Pi based recursive resolver. Important Save a copy of your capture and make note of the domain queried. Tips \u00b6 Use Wireshark's search capabilities to look for the string in the packet details of the capture. Use capture filters to limit the capture to port 53 and display filters to further cut down on the noise of the capture (see below). In addition to your DNS queries, you may see a lot of additional DNS traffic being generated by your computer and the Pi. The following display filter will eliminate DNSSEC related queries and queries generated by network time protocol : dns && !(dns.qry.type in {43 48} || dns.qry.name contains \"ntp.org\") . Questions \u00b6 Part I \u00b6 Briefly describe NAT in your own words along with an explanation of what information it collects in order to track and masquerade connections on your behalf. Use screenshots and illustrations from the sockets you observed. Note For research purposes, you may also want to search Port Address Translation (PAT). This is the tehcnical term for the variant of NAT that we are utilizing. Part II \u00b6 For each capture, summarize the message(s) that were involved in resolving your DNS queries . * Packet # from the wireshark capture * Source and Destination IP address * Tranport layer protocol and port * Message type, e.g., query/response * Record types included in the response, e.g., NS, A, or AAAA Looking at each pair of messages above, identify what type of DNS server provided back the corresponding response (Resolver, Root Name Server, TLD Name Server, or Authoritative Name Server). Using the data you've captured for illustration (along with other resources), compare and contrast the two sets of queries (Capture #1 and Capture #2) from the perspective of your Pi. What was the role of the Pi in each of these captures? What work did it have to do in order for you to receive a response to your question? Additional Resources \u00b6 WCT01-S11: Understand Proxy/Firewall/NAT/PAT Traffic Flows [WCT01: Network Analysis Overview Course]","title":"Report 2 - NAT and DNS analysis"},{"location":"assignments/analysis-report/#report-2-nat-and-dns-analysis","text":"The objective of this task is to analyze the mechanics of NAT and DNS using a variety of network utilities and to use your findings to help you answer the questions defined below.","title":"Report 2 - NAT and DNS analysis"},{"location":"assignments/analysis-report/#part-i-nat-analysis","text":"In this section, you will use netstat and netstat-nat to analyze the state of network connections from several different perspectives on your LAN.","title":"Part I: NAT Analysis"},{"location":"assignments/analysis-report/#installation","text":"netstat is a powerful tool for viewing information about sockets and connections on Windows, Linux, and macOS devices. The tool is installed by default by all major desktop OS vendors, though you'll find that the command line options vary slightly between implementation. netstat-nat provides a similar interface to netstat with the purpose of diving more deeply into the behavior of routed network connections and NAT. Use apt to install netstat-nat on your Pi. Root Permissions netstat-nat requires root permissions in order to run properly on your Pi, while netstat can be run without having to invoke sudo (but may provide more detailed information when used in that way).","title":"Installation"},{"location":"assignments/analysis-report/#usage-tips","text":"The most common options for netstat across all three operating systems are -an . The -a option instructs netstat to display server as well as client sockets, while n disables reverse DNS resolution and keeps the output easier to interpret. Tip: Reducing netstat output netstat can produce an overwhelming amount of information. To focus your attention, you can limit the output to a single protocol, e.g., tcp or udp. The syntax for this option on Windows and macOS is -p <PROTO> , e.g., netstat -anp tcp . For Linux, use -t to select only TCP sockets and -u to select only UDP packets. When running netstat-nat , the most useful view for this combination of options will be -SNn . This will show you source and destination IP addresses as well as the entries in your Pi's NAT table associated with each connection.","title":"Usage Tips"},{"location":"assignments/analysis-report/#analysis-instructions","text":"Setup your computer to use the Pi as a router (wifi disabled) so that you can use netstat and netstat-nat to examine open Internet connections from multiple perspectives. You will obtain the most information by running netstat on your own computer back-to-back with netstat-nat on your Pi. You should also experiment with netstat on your Pi, though you'll find it does not show you any data about routed connections. Take some time to understand what these perspectives are showing you (it may be helpful to run netstat without -n temporarily to obtain more information about the protocols and destination hosts). Try to correlate connections shown in netstat on your computer with the connections appearing in your NAT tables.","title":"Analysis instructions"},{"location":"assignments/analysis-report/#part-ii-dns-analysis","text":"In this section, you will use the tshark utility (a commandline version of Wireshark) in order to analyze DNS requests from the perspective of your Pi's external network interface. Install and configure tshark on your Pi and perform the two following captures of DNS as described below.","title":"Part II: DNS Analysis"},{"location":"assignments/analysis-report/#capture-1-perform-a-capture-of-dns-queries-being-routed-through-the-pi","text":"Setup your computer to use the Pi as a router (wifi disabled) and launch a tshark capture on the wlan0 port of your Pi. With tshark running, perform a manual DNS query from your computer to a public DNS resolver such as 1.1.1.1. Since your computer is now using your Pi as its default DNS resolver (based on the configuration performed by DHCP), you will need to manually override the DNS settings for your query. Info Both dig and Powershell's Resolve-DNSName command provide the functionality to override the system's default resolver. Use man or other resources to find the correct syntax for your system. Important Save a copy of your capture and make note of the domain queried.","title":"Capture &num;1 - Perform a capture of DNS queries being routed through the Pi"},{"location":"assignments/analysis-report/#capture-2-perform-a-capture-of-dns-queries-being-resolved-by-your-pi","text":"Setup your computer to use the Pi as a router (wifi disabled) and launch a tshark capture on the wlan0 port of your Pi. With tshark running on your Pi , clear BIND's resolver cache on your Pi (run sudo rndc reload on the Pi) and perform a manual DNS query from your computer to the Raspberry Pi based recursive resolver. Important Save a copy of your capture and make note of the domain queried.","title":"Capture &num;2 - Perform a capture of DNS queries being resolved by your Pi:"},{"location":"assignments/analysis-report/#tips","text":"Use Wireshark's search capabilities to look for the string in the packet details of the capture. Use capture filters to limit the capture to port 53 and display filters to further cut down on the noise of the capture (see below). In addition to your DNS queries, you may see a lot of additional DNS traffic being generated by your computer and the Pi. The following display filter will eliminate DNSSEC related queries and queries generated by network time protocol : dns && !(dns.qry.type in {43 48} || dns.qry.name contains \"ntp.org\") .","title":"Tips"},{"location":"assignments/analysis-report/#questions","text":"","title":"Questions"},{"location":"assignments/analysis-report/#part-i","text":"Briefly describe NAT in your own words along with an explanation of what information it collects in order to track and masquerade connections on your behalf. Use screenshots and illustrations from the sockets you observed. Note For research purposes, you may also want to search Port Address Translation (PAT). This is the tehcnical term for the variant of NAT that we are utilizing.","title":"Part I"},{"location":"assignments/analysis-report/#part-ii","text":"For each capture, summarize the message(s) that were involved in resolving your DNS queries . * Packet # from the wireshark capture * Source and Destination IP address * Tranport layer protocol and port * Message type, e.g., query/response * Record types included in the response, e.g., NS, A, or AAAA Looking at each pair of messages above, identify what type of DNS server provided back the corresponding response (Resolver, Root Name Server, TLD Name Server, or Authoritative Name Server). Using the data you've captured for illustration (along with other resources), compare and contrast the two sets of queries (Capture #1 and Capture #2) from the perspective of your Pi. What was the role of the Pi in each of these captures? What work did it have to do in order for you to receive a response to your question?","title":"Part II"},{"location":"assignments/analysis-report/#additional-resources","text":"WCT01-S11: Understand Proxy/Firewall/NAT/PAT Traffic Flows [WCT01: Network Analysis Overview Course]","title":"Additional Resources"},{"location":"assignments/dhcp-setup/","text":"Set up a DHCP Server for your LAN (2020-01-22) \u00b6 Overview \u00b6 In this assignment, we'll be standing up a DHCP service on the Raspberry Pi. As we've discussed in class, DHCP is a function that is sometimes performed by routers and is a necessary service whenever we are creating a new network (of almost any type). Before you Start \u00b6 Before starting any of the work within this checkpoint, make sure that you have completed all steps from checkpoint one, including the networkd setup. You must also have completed the Address Planning Exercise correctly. You will use the parameters you selected in that exercise to configure the IP address for the Pi as well as the configuration for isc-dhcp-server . Configure Static Addresses for your Raspberry Pi \u00b6 In this step, you will add a new configuration file to networkd in order to set up static addresses on eth0 . The addresses you use here will be the one you defined for your DHCP Server and Default Gateway in the LAN Planning Exercise . Please do not try to follow other tutorials for setting up addresses Every quarter, we have students who choose to follow online tutorials instead of the instructions we've provided. Please be aware that we are not using the default Raspberry Pi networking. These tutorials will often instruct you to configure static addresses in the /etc/dhcpcd.conf file or /etc/network/interfaces . Both of these methods were disabled when we set up networkd . Create a file named 20-eth0.network in /etc/systemd/network/ (you'll need to use sudo ) and define a static configuration that includes your chosen IP address and CIDR range. This path should already contain a default configuration for ethernet interfaces, e.g., 99-eth.network . We are overriding this configuration for eth0 by naming the file in such a way that networkd will load it first and by ensuring that the configuration will match eth0 exactly. Your file should look something like: [Match] # We only want to match the eth0 interface Name=eth0 # Provide full address config in abbreviated notation [Network] # Default Gateway / DHCP Server Address=192.168.0.1/24 # Enable link local addresses for IPv6 (FE80::) LinkLocalAddressing=ipv6 Warning Some online references will have you add a gateway and DNS settings for your new interface. You don't need to (and definitely shouldn't) add either to this interface. This interface does not provide a path for Internet traffic, but your Pi will try to use it that way if it believes it can be used for a default route. Likewise, we don't need to give the Pi DNS settings on Ethernet. The Pi will get it\u2019s DNS from the wireless interface, which received it\u2019s DNS settings from DHCP. In order to test these new settings: Call sudo systemctl restart systemd-networkd.service or reboot your Pi. Once you log back in, verify that networkd is running by calling systemctl status systemd-networkd and use the ip addr command to check that eth0 is online with the new address. Attention Make note that the Pi is now assigned to our new subnet, but our computer will still be using it's autoconfigured IPv4 address in the 169.254/16 range. In an IPv4 only world, this would prevent us from talking to the Pi. To fix the problem, we'd have to manually configure a static IP on our laptop in the same range as the Pi's network ID. Fortunately, both devices have autoconfigured IPv6 addresses that will be discovered through mDNS. By default, this is the address that SSH will use. Install and Configure DHCP \u00b6 For this part of the exercise, we'll use the ISC DHCP Server. The ISC server is available in apt repositories, so it can be installed using: sudo apt update sudo apt install isc-dhcp-server Warning Right after installation, isc-dhcp-server will report that it failed to run, and spit out lots of nasty-looking errors. This is normal, as the DHCP server has not yet been configured. Edit /etc/default/isc-dhcp-server to specify the interfaces ( eth0 only) on which to run the DHCP server. Comment out any options pertaining to DHCP for IPv6. The stock DHCP configuration is located at /etc/dhcp/dhcpd.conf . This file contains a number of example subnet declarations that you are meant to pick and choose from in order to configure the DHCP server and to distribute addresses within your predefined address range. For this assignment, our configuration is quite minimal: Specifications Before you start to configure your subnet, comment out the lines near the top of the file that specify global settings for nameservers and domain (we won\u2019t use them right now). Create a new subnet configuration block using the network ID and network mask you established in the LAN Planning Exercise . Inside the subnet block, define a contiguous range of IP addresses for the DHCP pool out of the address range selected in the LAN Planning Exercise . You may browse the othe options available, but at this point you should not specify anything other than the DHCP lease range. Why don't we configure the default gateway or name servers yet? Students will frequently jump ahead and fill in additional network parameters. The reason we don't want to include these parameters yet is that our Pi is not yet ready to provide an Internet connection. Sending a default route back to your workstation will create a black hole of sorts for Internet traffic. Your computer will try to route the traffic through the Pi, and the Pi will simply drop everything it receives. Test DHCP Server \u00b6 Use systemctl to restart the DHCP service as shown here: sudo systemctl restart isc-dhcp-server.service If you see errors such as the one shown here, you\u2019ll need to continue troubleshooting the DHCP server (see next section). pi@titan:~ $ sudo systemctl restart isc-dhcp-server.service Job for isc-dhcp-server.service failed because the control process exited with error code. See \"systemctl status isc-dhcp-server.service\" and \"journalctl -xe\" for details. Check your local machine to confirm that an IP address in the specified network range was provided. Try running ping from both directions (laptop -> pi and pi -> laptop) to confirm that the IP address and related settings are configured correctly. Warning If you are on Windows, incoming ping requests (those from pi -> laptop) will not get any response. This is because by default Windows Firewall blocks these requests from being answered. To disable this, run a PowerShell prompt as Administrator and enter these commands: New-NetFirewallRule -DisplayName \"Allow inbound ICMPv4\" -Direction Inbound -Protocol ICMPv4 -IcmpType 8 -Action Allow New-NetFirewallRule -DisplayName \"Allow inbound ICMPv6\" -Direction Inbound -Protocol ICMPv6 -IcmpType 8 -Action Allow ``` Troubleshooting \u00b6 Troubleshooting for the ISC DHCP Server can be found under troubleshooting dhcp .","title":"Set up a DHCP Server for your LAN (2020-01-22)"},{"location":"assignments/dhcp-setup/#set-up-a-dhcp-server-for-your-lan-2020-01-22","text":"","title":"Set up a DHCP Server for your LAN (2020-01-22)"},{"location":"assignments/dhcp-setup/#overview","text":"In this assignment, we'll be standing up a DHCP service on the Raspberry Pi. As we've discussed in class, DHCP is a function that is sometimes performed by routers and is a necessary service whenever we are creating a new network (of almost any type).","title":"Overview"},{"location":"assignments/dhcp-setup/#before-you-start","text":"Before starting any of the work within this checkpoint, make sure that you have completed all steps from checkpoint one, including the networkd setup. You must also have completed the Address Planning Exercise correctly. You will use the parameters you selected in that exercise to configure the IP address for the Pi as well as the configuration for isc-dhcp-server .","title":"Before you Start"},{"location":"assignments/dhcp-setup/#configure-static-addresses-for-your-raspberry-pi","text":"In this step, you will add a new configuration file to networkd in order to set up static addresses on eth0 . The addresses you use here will be the one you defined for your DHCP Server and Default Gateway in the LAN Planning Exercise . Please do not try to follow other tutorials for setting up addresses Every quarter, we have students who choose to follow online tutorials instead of the instructions we've provided. Please be aware that we are not using the default Raspberry Pi networking. These tutorials will often instruct you to configure static addresses in the /etc/dhcpcd.conf file or /etc/network/interfaces . Both of these methods were disabled when we set up networkd . Create a file named 20-eth0.network in /etc/systemd/network/ (you'll need to use sudo ) and define a static configuration that includes your chosen IP address and CIDR range. This path should already contain a default configuration for ethernet interfaces, e.g., 99-eth.network . We are overriding this configuration for eth0 by naming the file in such a way that networkd will load it first and by ensuring that the configuration will match eth0 exactly. Your file should look something like: [Match] # We only want to match the eth0 interface Name=eth0 # Provide full address config in abbreviated notation [Network] # Default Gateway / DHCP Server Address=192.168.0.1/24 # Enable link local addresses for IPv6 (FE80::) LinkLocalAddressing=ipv6 Warning Some online references will have you add a gateway and DNS settings for your new interface. You don't need to (and definitely shouldn't) add either to this interface. This interface does not provide a path for Internet traffic, but your Pi will try to use it that way if it believes it can be used for a default route. Likewise, we don't need to give the Pi DNS settings on Ethernet. The Pi will get it\u2019s DNS from the wireless interface, which received it\u2019s DNS settings from DHCP. In order to test these new settings: Call sudo systemctl restart systemd-networkd.service or reboot your Pi. Once you log back in, verify that networkd is running by calling systemctl status systemd-networkd and use the ip addr command to check that eth0 is online with the new address. Attention Make note that the Pi is now assigned to our new subnet, but our computer will still be using it's autoconfigured IPv4 address in the 169.254/16 range. In an IPv4 only world, this would prevent us from talking to the Pi. To fix the problem, we'd have to manually configure a static IP on our laptop in the same range as the Pi's network ID. Fortunately, both devices have autoconfigured IPv6 addresses that will be discovered through mDNS. By default, this is the address that SSH will use.","title":"Configure Static Addresses for your Raspberry Pi"},{"location":"assignments/dhcp-setup/#install-and-configure-dhcp","text":"For this part of the exercise, we'll use the ISC DHCP Server. The ISC server is available in apt repositories, so it can be installed using: sudo apt update sudo apt install isc-dhcp-server Warning Right after installation, isc-dhcp-server will report that it failed to run, and spit out lots of nasty-looking errors. This is normal, as the DHCP server has not yet been configured. Edit /etc/default/isc-dhcp-server to specify the interfaces ( eth0 only) on which to run the DHCP server. Comment out any options pertaining to DHCP for IPv6. The stock DHCP configuration is located at /etc/dhcp/dhcpd.conf . This file contains a number of example subnet declarations that you are meant to pick and choose from in order to configure the DHCP server and to distribute addresses within your predefined address range. For this assignment, our configuration is quite minimal: Specifications Before you start to configure your subnet, comment out the lines near the top of the file that specify global settings for nameservers and domain (we won\u2019t use them right now). Create a new subnet configuration block using the network ID and network mask you established in the LAN Planning Exercise . Inside the subnet block, define a contiguous range of IP addresses for the DHCP pool out of the address range selected in the LAN Planning Exercise . You may browse the othe options available, but at this point you should not specify anything other than the DHCP lease range. Why don't we configure the default gateway or name servers yet? Students will frequently jump ahead and fill in additional network parameters. The reason we don't want to include these parameters yet is that our Pi is not yet ready to provide an Internet connection. Sending a default route back to your workstation will create a black hole of sorts for Internet traffic. Your computer will try to route the traffic through the Pi, and the Pi will simply drop everything it receives.","title":"Install and Configure DHCP"},{"location":"assignments/dhcp-setup/#test-dhcp-server","text":"Use systemctl to restart the DHCP service as shown here: sudo systemctl restart isc-dhcp-server.service If you see errors such as the one shown here, you\u2019ll need to continue troubleshooting the DHCP server (see next section). pi@titan:~ $ sudo systemctl restart isc-dhcp-server.service Job for isc-dhcp-server.service failed because the control process exited with error code. See \"systemctl status isc-dhcp-server.service\" and \"journalctl -xe\" for details. Check your local machine to confirm that an IP address in the specified network range was provided. Try running ping from both directions (laptop -> pi and pi -> laptop) to confirm that the IP address and related settings are configured correctly. Warning If you are on Windows, incoming ping requests (those from pi -> laptop) will not get any response. This is because by default Windows Firewall blocks these requests from being answered. To disable this, run a PowerShell prompt as Administrator and enter these commands: New-NetFirewallRule -DisplayName \"Allow inbound ICMPv4\" -Direction Inbound -Protocol ICMPv4 -IcmpType 8 -Action Allow New-NetFirewallRule -DisplayName \"Allow inbound ICMPv6\" -Direction Inbound -Protocol ICMPv6 -IcmpType 8 -Action Allow ```","title":"Test DHCP Server"},{"location":"assignments/dhcp-setup/#troubleshooting","text":"Troubleshooting for the ISC DHCP Server can be found under troubleshooting dhcp .","title":"Troubleshooting"},{"location":"assignments/dns-zone-setup/","text":"Authoritative Name Server (last edited 2020-02-17) \u00b6 Overview \u00b6 In this assignment, we will extend our BIND configuration (think back to our DNS Resolver checkpoint ) to handle DNS queries for a domain that is in your complete control. While you don't have very many services or resources available on your network yet, this project should help you explore the ways in which DNS can be used to identify resources on a network as you add them. This task will build upon the work you did in the DNS Planning Exercise . Important With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task. In this assignment, you will use the provided reference documents to help you configure the project according to specification. For some students, this can be a challenging adjustment, but it is also a valuable skill to learn and practice as you prepare for technical internships and jobs. Before you start \u00b6 Before you begin, make sure that you have completed all steps through Checkpoint #4 successfully. At this point, BIND is installed and configured so that your Pi can resolve DNS queries from clients inside your LAN. DHCP is configured to provide LAN clients with the IP address of this resolver (via the domain-name-server option), and you have tested that DNS resolution is working. Before you begin, you should also confirm that you have completed the LAN Planning and DNS Planning exercises. You will be required to refer back to these worksheets. Create a new zone file \u00b6 The documentation installed with BIND provides guidance for where to store zone files on your name server. The recommendation for master (primary) name servers, such as the one we are creating, is to store the zone files in /etc/bind or one of its subdirectories. We'll follow this advice below. To get started defining your own zone, create a new sub-directory called zones in /etc/bind as shown below and copy the existing db.local into it as a starting point for creating your zone. Our advice is to follow the convention of naming your zone file after your selected domain, e.g., gradebook.pi is defined in /etc/bind/zones/db.gradebook.pi. Creating your starter zone file sudo mkdir -p /etc/bind/zones sudo cp /etc/bind/db.local /etc/bind/zones/db.gradebook.pi The initial contents of your zone file will look similar to this: ; ; BIND data file for local loopback interface ; $TTL 604800 @ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL ; @ IN NS localhost. @ IN A 127.0.0.1 @ IN AAAA ::1 As is stated in the comment at the start of the file, this file is defining a special purpose zone for the localhost domain to ensure proper handling when the name is passed to BIND. Customize the localhost zone file for your own domain \u00b6 Your task at this point is to update this file to describe the public-facing domain that you selected in the DNS Planning Exercise . Important Your primary resource for this task is the Zone File Reference , which outlines the format of the zone file and the resource records that we will use. It may also be helpful to examine the section Creating the Forward Zone File in DigitalOcean's Tutorial Customize the Start of Authority (SOA) \u00b6 Update the comments at the start of the file to refer to your domain and then modify the SOA resource record based on the fully-qualified domain name of your Pi and a valid email address, e.g., your UW email. Specifying e-mail addresses for SOA records While it's not apparent on first glance, every SOA resource record contains a field called the RNAME, which specifies an email address associated with the administrator for the domain. As mentioned in Zone File Reference , RNAME records receive special formatting. You must replace the @ with a . and escape existing periods in the username by prefixing them with a \\ ). Add NS and A records for the nameservers \u00b6 Delete the initial NS and glue records and create a new NS record and a type A glue record for your name server. The NS record will point to your server by its fully-qualified domain name. Likewise, the A record will contain the internal IP address of your server. The Zone File Reference provides real world examples of name servers and glue records. Using dig , e.g., dig NS microsoft.com , you can find additional examples for pretty much any public domain. Add records for additional DNS resources \u00b6 Using the provided Zone File Reference , create additional MX and A records to identify the mail server that you defined in the DNS Planning Exercise . It's okay that we haven't set up the mail server yet. Refer back to your LAN Planning and select an unused static address. Attention Pay close attention to the expected format of an MX resource record. It varies slightly from other common record types and leads to frequent errors. Declare the zone in named.conf.local \u00b6 The zone file that you have created defines the resources that can be queried by your name server, but it does not yet instruct BIND to serve the domain. To accomplish this, we will add a new zone configuration within /etc/bind/named.conf.local . Instructions Open /etc/bind/named.conf.local and add a new zone reference: // Replace references to corp.gradebook.pi with your own domain name. zone \"gradebook.pi\" IN { // We're setting up the master server for the zone. In DNS, masters contain // the zone file for a domain while slaves read the zone contents from a // master server. type master; file \"/etc/bind/zones/db.gradebook.pi\"; }; Validate and test your configuration \u00b6 Run named-checkconf -z to identify any immediate errors in your configuration or zone file and restart the bind9 service using systemctl . Use systemctl to verify that the service is running correctly. You can also test your configuration locally on the Pi by running dig @127.0.0.1 ns <DOMAIN_NAME> . Pay close attention to status codes and errors appearing in the response. Update DHCP \u00b6 Your LAN clients should be able to query the new domain without any additional configuration; however, we will take the opportunity to make one additional update to DHCP. Following the same process you've encountered in previous guides add the domain-name option to your subnet configuration. This option configures your LAN clients to recognize your internal domain name as a default domain name when attempting to resolve hosts, e.g., dig titan would resolve records for titan.gradebook.pi . Additional Resources \u00b6 A Comparison of DNS Server Types RFC 1034: Domain Names - Concepts and Facilities RFC 1035: Domain Names - Implementation and Specification How to format a zone file (Dyn.com) How to configure BIND as a Private Network DNS Server - DigitalOcean Tutorial","title":"Authoritative Name Server (last edited 2020-02-17)"},{"location":"assignments/dns-zone-setup/#authoritative-name-server-last-edited-2020-02-17","text":"","title":"Authoritative Name Server (last edited 2020-02-17)"},{"location":"assignments/dns-zone-setup/#overview","text":"In this assignment, we will extend our BIND configuration (think back to our DNS Resolver checkpoint ) to handle DNS queries for a domain that is in your complete control. While you don't have very many services or resources available on your network yet, this project should help you explore the ways in which DNS can be used to identify resources on a network as you add them. This task will build upon the work you did in the DNS Planning Exercise . Important With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task. In this assignment, you will use the provided reference documents to help you configure the project according to specification. For some students, this can be a challenging adjustment, but it is also a valuable skill to learn and practice as you prepare for technical internships and jobs.","title":"Overview"},{"location":"assignments/dns-zone-setup/#before-you-start","text":"Before you begin, make sure that you have completed all steps through Checkpoint #4 successfully. At this point, BIND is installed and configured so that your Pi can resolve DNS queries from clients inside your LAN. DHCP is configured to provide LAN clients with the IP address of this resolver (via the domain-name-server option), and you have tested that DNS resolution is working. Before you begin, you should also confirm that you have completed the LAN Planning and DNS Planning exercises. You will be required to refer back to these worksheets.","title":"Before you start"},{"location":"assignments/dns-zone-setup/#create-a-new-zone-file","text":"The documentation installed with BIND provides guidance for where to store zone files on your name server. The recommendation for master (primary) name servers, such as the one we are creating, is to store the zone files in /etc/bind or one of its subdirectories. We'll follow this advice below. To get started defining your own zone, create a new sub-directory called zones in /etc/bind as shown below and copy the existing db.local into it as a starting point for creating your zone. Our advice is to follow the convention of naming your zone file after your selected domain, e.g., gradebook.pi is defined in /etc/bind/zones/db.gradebook.pi. Creating your starter zone file sudo mkdir -p /etc/bind/zones sudo cp /etc/bind/db.local /etc/bind/zones/db.gradebook.pi The initial contents of your zone file will look similar to this: ; ; BIND data file for local loopback interface ; $TTL 604800 @ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL ; @ IN NS localhost. @ IN A 127.0.0.1 @ IN AAAA ::1 As is stated in the comment at the start of the file, this file is defining a special purpose zone for the localhost domain to ensure proper handling when the name is passed to BIND.","title":"Create a new zone file"},{"location":"assignments/dns-zone-setup/#customize-the-localhost-zone-file-for-your-own-domain","text":"Your task at this point is to update this file to describe the public-facing domain that you selected in the DNS Planning Exercise . Important Your primary resource for this task is the Zone File Reference , which outlines the format of the zone file and the resource records that we will use. It may also be helpful to examine the section Creating the Forward Zone File in DigitalOcean's Tutorial","title":"Customize the localhost zone file for your own domain"},{"location":"assignments/dns-zone-setup/#customize-the-start-of-authority-soa","text":"Update the comments at the start of the file to refer to your domain and then modify the SOA resource record based on the fully-qualified domain name of your Pi and a valid email address, e.g., your UW email. Specifying e-mail addresses for SOA records While it's not apparent on first glance, every SOA resource record contains a field called the RNAME, which specifies an email address associated with the administrator for the domain. As mentioned in Zone File Reference , RNAME records receive special formatting. You must replace the @ with a . and escape existing periods in the username by prefixing them with a \\ ).","title":"Customize the Start of Authority (SOA)"},{"location":"assignments/dns-zone-setup/#add-ns-and-a-records-for-the-nameservers","text":"Delete the initial NS and glue records and create a new NS record and a type A glue record for your name server. The NS record will point to your server by its fully-qualified domain name. Likewise, the A record will contain the internal IP address of your server. The Zone File Reference provides real world examples of name servers and glue records. Using dig , e.g., dig NS microsoft.com , you can find additional examples for pretty much any public domain.","title":"Add NS and A records for the nameservers"},{"location":"assignments/dns-zone-setup/#add-records-for-additional-dns-resources","text":"Using the provided Zone File Reference , create additional MX and A records to identify the mail server that you defined in the DNS Planning Exercise . It's okay that we haven't set up the mail server yet. Refer back to your LAN Planning and select an unused static address. Attention Pay close attention to the expected format of an MX resource record. It varies slightly from other common record types and leads to frequent errors.","title":"Add records for additional DNS resources"},{"location":"assignments/dns-zone-setup/#declare-the-zone-in-namedconflocal","text":"The zone file that you have created defines the resources that can be queried by your name server, but it does not yet instruct BIND to serve the domain. To accomplish this, we will add a new zone configuration within /etc/bind/named.conf.local . Instructions Open /etc/bind/named.conf.local and add a new zone reference: // Replace references to corp.gradebook.pi with your own domain name. zone \"gradebook.pi\" IN { // We're setting up the master server for the zone. In DNS, masters contain // the zone file for a domain while slaves read the zone contents from a // master server. type master; file \"/etc/bind/zones/db.gradebook.pi\"; };","title":"Declare the zone in named.conf.local"},{"location":"assignments/dns-zone-setup/#validate-and-test-your-configuration","text":"Run named-checkconf -z to identify any immediate errors in your configuration or zone file and restart the bind9 service using systemctl . Use systemctl to verify that the service is running correctly. You can also test your configuration locally on the Pi by running dig @127.0.0.1 ns <DOMAIN_NAME> . Pay close attention to status codes and errors appearing in the response.","title":"Validate and test your configuration"},{"location":"assignments/dns-zone-setup/#update-dhcp","text":"Your LAN clients should be able to query the new domain without any additional configuration; however, we will take the opportunity to make one additional update to DHCP. Following the same process you've encountered in previous guides add the domain-name option to your subnet configuration. This option configures your LAN clients to recognize your internal domain name as a default domain name when attempting to resolve hosts, e.g., dig titan would resolve records for titan.gradebook.pi .","title":"Update DHCP"},{"location":"assignments/dns-zone-setup/#additional-resources","text":"A Comparison of DNS Server Types RFC 1034: Domain Names - Concepts and Facilities RFC 1035: Domain Names - Implementation and Specification How to format a zone file (Dyn.com) How to configure BIND as a Private Network DNS Server - DigitalOcean Tutorial","title":"Additional Resources"},{"location":"assignments/final-project/","text":"Final Network Project (last edited 2020-03-11) \u00b6 Overview \u00b6 Working in your group, design and implement a networked system that mirrors the concept of an Internet Service Provider (ISP) with customer networks. Your primary objective in this exercise is to adapt what you've completed in previous tasks to meet the requirements specified below. Although you will be working together as a group on this project, each participant will take the lead on configuring their own network device to integrate into the ISP network. Additional configuration guidance will be made available through Slack. We will walk through new tasks together in our remaining lectures/labs. Important Instructions Before you get started, please browse to following link and fill out IP and DNS info: PICANN Registry Take time to plan out the network design and IP address usage with your group before you build. This plan is a mandatory deliverable and will be required before implementation assistance is given. We recommend that you sketch out an initial diagram of the entire network and create a checklist of major settings for each device. Before you start \u00b6 Each of your group members need to have completed the individual project checkpoints before proceeding with the configuration necessary for the final network. Each pi should function as a network gateway while also providing DHCP and private DNS services to an Ethernet-based LAN. Project Details \u00b6 Overview \u00b6 Each group is required to fulfill the following requirements by building off of previous checkpoints and additional resources. Differences between videos/specifications As a resource, I have provided videos that walk through various parts of this project. Please note that some of these videos were made in previous quarters. There may be minor differences between current project requirements and what is discussed in the video. It is important that you follow the current written specifications. Perform IP address planning and network renumbering on a group and individual basis based on the address ranges provided by the instructor. IP address assignments can be found in the PICANN Registry Video guide on Authoritative server, external IP, external DNS: Panapto Recording Address Planning for Final Project (video) VLANS: VLAN and Switch Planning (video) Planning: VLAN and switch planning worksheet Your network plans must be documented before requesting implementation assistance from instruction team Once you've completed all network planning and documentation you may move on to the following sections. Build a \u201ccore router\u201d that will function as the ISP for your other networks. In addition to providing connectivity between routers, you will provide public Internet access for the rest of your group. The router will eventually be connected to other groups to form a private in-class Internet. Project Topology (video) VLAN and Switch Planning (video) Build two or more \u201cedge routers\u201d that will allow your partners to connect to the Internet as customers of the ISP. Each router should serve one or more LAN subnets. In your final configuration, you should rely on the ISP connection for public Internet access, i.e., you won't be connecting the edge routers to public wifi directly except for setup purposes. Using Free Range Routing (FRR), configure BGP peering on the routing links between the ISP routers and customers\u2019 edge routers. Setup FRRouting Install FRR and Unifi Controller (video) Configure BGP peering FRR and BGP routing configuration (video) Configure public domains, authoritative servers, and (optionally) email for each of your networks. One router in your group should also host the .pi TLD at 10.10.10.10 (BGP Anycast) via a provided Docker image. [ SKIP ME ] Configure a Ubiquiti Unifi switch based on instructor instructions to support the system topology. Setting up VLANs on a Unifi Switch (video) Renumbering IP Addresses \u00b6 A block of IP addresses have been assigned to each group via the PICANN Registry Assign a range of addresses to each group member based on this block. Each group member should further subnet their own range into 2 - 4 distinct subnets. A minimum of two subnets per LAN are needed to meet the base project requirements. If you would like to experiment with more complex firewall rules and/or setting up a wireless LAN, we recommend four subnets. Use one of your subnets for your internal LAN (providing DHCP and other services to devices accessing through Ethernet). A second subnet should be dedicated to any public-facing services. Core Router Setup \u00b6 Managing network interfaces Use wlan0 to provide access to the public Internet to your customers (NAT is required) [ORIGINAL] Set up tagged VLAN interfaces to connect with each edge router. [UPDATED] Set up at least one VLAN interace, as would be required to connect with one of the Edge routers included in your network plan. See Setting up VLAN interfaces in Linux (video) . Firewall rules Our network is private, so use connection state with your forwarding rules to make sure inbound packets (from wlan0) are dropped when they aren't related to established sessions Within our network, traffic should be routed rather freely. In other words, make sure you aren't dropping packets that are being forwarded from your LAN or one of your partners' routing links. Private LAN Even though your router's primary role is infrastructure for your group, you should still set up a basic LAN that you'll connect to for management purposes. This should meet the base requirements described for LAN services. Edge Network Setup \u00b6 Managing network interfaces Create a tagged VLAN to connect with the core router. You must coordinate the VLAN ID with the core router and the switch. See Setting up VLAN interfaces in Linux (video) . Managing firewall rules You'll have no need for NAT as long as you set up your LAN inside your allocated IP range (see the previously linked registry) You may set the default FORWARD policy to ACCEPT to ensure that traffic can be routed between partners. Extra Credit Configure the default FORWARD policy to DROP traffic. You can allow traffic to be forwarded into your network (from wlan0) if it's related to a session your LAN client's initiated You can allow traffic into your device or network from the other routing links if it is destined to a public-facing service (i.e., Authoritative DNS, SMTP, or Webmail). Configure DROP policies for the INPUT and OUTPUT chains that manage traffic to/from the router. Ubiquiti Switch \u00b6 [ SKIP THIS SECTION ] \u00b6 See VLAN and Switch Planning , Installing FRR and Ubiquiti Controller , and Configuring Unifi Switch . Configure a VLAN that each group member shares with their own Pi. Set the VLAN up as native (untagged) for both the Pi and the PC connection to the switch. Set up tagged VLANs for each routing link. Create a profile for the port associated with each of your Pi\u2019s and add the VLANs to the profile according to which connections are available to that Pi. Reserve one port for the connection to the \u201ccore network\u201d. This port should be natively associated with the VLAN created for the core routing link. LAN Services \u00b6 Configure a DNS resolver (either caching or forwarding) to handle requests outside of your private zone. This was the outcome of Checkpoint #4. Configure DHCP services to distribute addresses and configuration within your LAN to end-users ([use the pre-defined address allocations for your group]). This was the outcome of Checkpoint #2, though you will need to adjust your address range. (EXTRA CREDIT OPTION) Configure a private DNS zone, e.g., corp.gradebook.pi, and use BIND views to restrict access to your private zone and the DNS resolver so that it is not available outside of your local LAN. Public Services \u00b6 See Configuring External IP and DNS . Configure a public DNS zone for each network (ISP + customer networks) and set up records for each of your public services (you may choose to centralize authoritative DNS at the ISP, but each student must configure their own zone file). [ SKIP ME ] (ONE PER GROUP) Host an authoritative DNS slave for the .pi TLD. This server will be hosted publicly on 10.10.10.10 and routed via BGP Anycast. A dockerized container and instructions to deploy are included in the repo linked below. (EXTRA CREDIT OPTION) Configure email for each of your public domains using the provided docker containers. Extra Credit \u00b6 If you're up for the challenge, there are several other ways to earn extra credit toward your final grade by completing the following tasks. (1 pt) Install and configure the Pi Mail Docker containers in order to host email on your domain/network. Extra credit will be given to each student who successfully completes this task. (1 pt) Add a wireless access point to your Edge LANs. The wlan0 port is capable of operating as a software-based access point using the hostapd package in the Debian repositories. At least two group members must complete this configuration. Instructions will be provided. (2 pt) Extend your Iptables rules to support a default DROP policy on the INPUT chain, making sure that you have full utility of all of your private and public services. Apply this configuration to each of your customer networks, adapting for any differences in configuration for that network. (1 pt) Extend your IPTables rules to support a default DROP policy on the OUTPUT chain, making sure that you have full utility of all of your private and public services. Apply this configuration to each of your customer networks, adapting for any differences in configuration for that network. [ SKIP ME ] (1 pt) Perform TCP-based nmap scans of your networks from inside and outside. Summarize the major findings for each network. You should have 2 scans per Pi. One scanning IP addresses for that team member from inside their LAN and one scanning from a different LAN. Important Links \u00b6 PICANN : DNS Registry and IP Reservations [ SKIP ME ] dotPI TLD: Instructions and docker components needed to load a dockerized BIND on 10.10.10.10 for the .pi TLD Pi Mail : Instructions and docker components needed to configure SMTP, IMAP, and a webmail server on your Pi","title":"**Final Network Project** (last edited 2020-03-11)"},{"location":"assignments/final-project/#final-network-project-last-edited-2020-03-11","text":"","title":"Final Network Project (last edited 2020-03-11)"},{"location":"assignments/final-project/#overview","text":"Working in your group, design and implement a networked system that mirrors the concept of an Internet Service Provider (ISP) with customer networks. Your primary objective in this exercise is to adapt what you've completed in previous tasks to meet the requirements specified below. Although you will be working together as a group on this project, each participant will take the lead on configuring their own network device to integrate into the ISP network. Additional configuration guidance will be made available through Slack. We will walk through new tasks together in our remaining lectures/labs. Important Instructions Before you get started, please browse to following link and fill out IP and DNS info: PICANN Registry Take time to plan out the network design and IP address usage with your group before you build. This plan is a mandatory deliverable and will be required before implementation assistance is given. We recommend that you sketch out an initial diagram of the entire network and create a checklist of major settings for each device.","title":"Overview"},{"location":"assignments/final-project/#before-you-start","text":"Each of your group members need to have completed the individual project checkpoints before proceeding with the configuration necessary for the final network. Each pi should function as a network gateway while also providing DHCP and private DNS services to an Ethernet-based LAN.","title":"Before you start"},{"location":"assignments/final-project/#project-details","text":"","title":"Project Details"},{"location":"assignments/final-project/#overview_1","text":"Each group is required to fulfill the following requirements by building off of previous checkpoints and additional resources. Differences between videos/specifications As a resource, I have provided videos that walk through various parts of this project. Please note that some of these videos were made in previous quarters. There may be minor differences between current project requirements and what is discussed in the video. It is important that you follow the current written specifications. Perform IP address planning and network renumbering on a group and individual basis based on the address ranges provided by the instructor. IP address assignments can be found in the PICANN Registry Video guide on Authoritative server, external IP, external DNS: Panapto Recording Address Planning for Final Project (video) VLANS: VLAN and Switch Planning (video) Planning: VLAN and switch planning worksheet Your network plans must be documented before requesting implementation assistance from instruction team Once you've completed all network planning and documentation you may move on to the following sections. Build a \u201ccore router\u201d that will function as the ISP for your other networks. In addition to providing connectivity between routers, you will provide public Internet access for the rest of your group. The router will eventually be connected to other groups to form a private in-class Internet. Project Topology (video) VLAN and Switch Planning (video) Build two or more \u201cedge routers\u201d that will allow your partners to connect to the Internet as customers of the ISP. Each router should serve one or more LAN subnets. In your final configuration, you should rely on the ISP connection for public Internet access, i.e., you won't be connecting the edge routers to public wifi directly except for setup purposes. Using Free Range Routing (FRR), configure BGP peering on the routing links between the ISP routers and customers\u2019 edge routers. Setup FRRouting Install FRR and Unifi Controller (video) Configure BGP peering FRR and BGP routing configuration (video) Configure public domains, authoritative servers, and (optionally) email for each of your networks. One router in your group should also host the .pi TLD at 10.10.10.10 (BGP Anycast) via a provided Docker image. [ SKIP ME ] Configure a Ubiquiti Unifi switch based on instructor instructions to support the system topology. Setting up VLANs on a Unifi Switch (video)","title":"Overview"},{"location":"assignments/final-project/#renumbering-ip-addresses","text":"A block of IP addresses have been assigned to each group via the PICANN Registry Assign a range of addresses to each group member based on this block. Each group member should further subnet their own range into 2 - 4 distinct subnets. A minimum of two subnets per LAN are needed to meet the base project requirements. If you would like to experiment with more complex firewall rules and/or setting up a wireless LAN, we recommend four subnets. Use one of your subnets for your internal LAN (providing DHCP and other services to devices accessing through Ethernet). A second subnet should be dedicated to any public-facing services.","title":"Renumbering IP Addresses"},{"location":"assignments/final-project/#core-router-setup","text":"Managing network interfaces Use wlan0 to provide access to the public Internet to your customers (NAT is required) [ORIGINAL] Set up tagged VLAN interfaces to connect with each edge router. [UPDATED] Set up at least one VLAN interace, as would be required to connect with one of the Edge routers included in your network plan. See Setting up VLAN interfaces in Linux (video) . Firewall rules Our network is private, so use connection state with your forwarding rules to make sure inbound packets (from wlan0) are dropped when they aren't related to established sessions Within our network, traffic should be routed rather freely. In other words, make sure you aren't dropping packets that are being forwarded from your LAN or one of your partners' routing links. Private LAN Even though your router's primary role is infrastructure for your group, you should still set up a basic LAN that you'll connect to for management purposes. This should meet the base requirements described for LAN services.","title":"Core Router Setup"},{"location":"assignments/final-project/#edge-network-setup","text":"Managing network interfaces Create a tagged VLAN to connect with the core router. You must coordinate the VLAN ID with the core router and the switch. See Setting up VLAN interfaces in Linux (video) . Managing firewall rules You'll have no need for NAT as long as you set up your LAN inside your allocated IP range (see the previously linked registry) You may set the default FORWARD policy to ACCEPT to ensure that traffic can be routed between partners. Extra Credit Configure the default FORWARD policy to DROP traffic. You can allow traffic to be forwarded into your network (from wlan0) if it's related to a session your LAN client's initiated You can allow traffic into your device or network from the other routing links if it is destined to a public-facing service (i.e., Authoritative DNS, SMTP, or Webmail). Configure DROP policies for the INPUT and OUTPUT chains that manage traffic to/from the router.","title":"Edge Network Setup"},{"location":"assignments/final-project/#ubiquiti-switch","text":"","title":"Ubiquiti Switch"},{"location":"assignments/final-project/#91-skip-this-section-93","text":"See VLAN and Switch Planning , Installing FRR and Ubiquiti Controller , and Configuring Unifi Switch . Configure a VLAN that each group member shares with their own Pi. Set the VLAN up as native (untagged) for both the Pi and the PC connection to the switch. Set up tagged VLANs for each routing link. Create a profile for the port associated with each of your Pi\u2019s and add the VLANs to the profile according to which connections are available to that Pi. Reserve one port for the connection to the \u201ccore network\u201d. This port should be natively associated with the VLAN created for the core routing link.","title":"[ SKIP THIS SECTION ]"},{"location":"assignments/final-project/#lan-services","text":"Configure a DNS resolver (either caching or forwarding) to handle requests outside of your private zone. This was the outcome of Checkpoint #4. Configure DHCP services to distribute addresses and configuration within your LAN to end-users ([use the pre-defined address allocations for your group]). This was the outcome of Checkpoint #2, though you will need to adjust your address range. (EXTRA CREDIT OPTION) Configure a private DNS zone, e.g., corp.gradebook.pi, and use BIND views to restrict access to your private zone and the DNS resolver so that it is not available outside of your local LAN.","title":"LAN Services"},{"location":"assignments/final-project/#public-services","text":"See Configuring External IP and DNS . Configure a public DNS zone for each network (ISP + customer networks) and set up records for each of your public services (you may choose to centralize authoritative DNS at the ISP, but each student must configure their own zone file). [ SKIP ME ] (ONE PER GROUP) Host an authoritative DNS slave for the .pi TLD. This server will be hosted publicly on 10.10.10.10 and routed via BGP Anycast. A dockerized container and instructions to deploy are included in the repo linked below. (EXTRA CREDIT OPTION) Configure email for each of your public domains using the provided docker containers.","title":"Public Services"},{"location":"assignments/final-project/#extra-credit","text":"If you're up for the challenge, there are several other ways to earn extra credit toward your final grade by completing the following tasks. (1 pt) Install and configure the Pi Mail Docker containers in order to host email on your domain/network. Extra credit will be given to each student who successfully completes this task. (1 pt) Add a wireless access point to your Edge LANs. The wlan0 port is capable of operating as a software-based access point using the hostapd package in the Debian repositories. At least two group members must complete this configuration. Instructions will be provided. (2 pt) Extend your Iptables rules to support a default DROP policy on the INPUT chain, making sure that you have full utility of all of your private and public services. Apply this configuration to each of your customer networks, adapting for any differences in configuration for that network. (1 pt) Extend your IPTables rules to support a default DROP policy on the OUTPUT chain, making sure that you have full utility of all of your private and public services. Apply this configuration to each of your customer networks, adapting for any differences in configuration for that network. [ SKIP ME ] (1 pt) Perform TCP-based nmap scans of your networks from inside and outside. Summarize the major findings for each network. You should have 2 scans per Pi. One scanning IP addresses for that team member from inside their LAN and one scanning from a different LAN.","title":"Extra Credit"},{"location":"assignments/final-project/#important-links","text":"PICANN : DNS Registry and IP Reservations [ SKIP ME ] dotPI TLD: Instructions and docker components needed to load a dockerized BIND on 10.10.10.10 for the .pi TLD Pi Mail : Instructions and docker components needed to configure SMTP, IMAP, and a webmail server on your Pi","title":"Important Links"},{"location":"assignments/lab1/","text":"Lab 1 - Core Technical Skills \u00b6 Lab 1 Assignment page on Canvas Overview \u00b6 In this lab you will be introduced to working with a headless Linux server. The work you do in this lab will be extremely helpful in becoming more comfortable with your Raspberry Pi. We will walk you through all of the required steps in lab, but all the required steps are also in this webpage. Before you start \u00b6 Everyone \u00b6 Confirm that you have created a DigitalOcean account, and that on the top right of the website it says you have $100.00 of credits. This will allow you to create virtual machine \u201cDroplets\u201d on DigitalOcean without incurring any direct cost. In addition to the email we sent on Sunday, instructions to complete this task can be found in here . Windows \u00b6 Determine which build of Windows 10 they have installed by running Get-ComputerInfo -Property WindowsVersion in PowerShell. The minimum version of Windows 10 required for this course is 1809, but you may proceed with this lab as long as you are running 1803. For any prior version of Windows (older than 1803), please install Git for Windows from https://gitforwindows.org/ and use the Git Bash environment to complete the following set of exercises instead of PowerShell. Create SSH client keys \u00b6 To use the DigitalOcean server we will soon create, you'll need a way to authenticate yourself and login to your server. While you might think a password will suffice, we will be using a more secure method of authentication through SSH keys. SSH stands for 'Secure Shell'. A 'shell' is a command line interface, such as the one's you've seen in Terminal, PowerShell, or Git Bash. Throughout this course, you'll be using the shell, remotely, to configure Linux. SSH makes the shell 'secure' by create a pair of keys that you use to authenticate yourself to a remote shell. These 'keys' are simply long strings of characters that are tied together with some complex mathematics. We will use a program called ssh-keygen to create this pair of keys. ssh-keygen will generate a private key, and a public key. Your public key can be given out, to say, DigitalOcean, while your private key remains only on your computer. In short, SSH works as follows in our scenario: Your computer connects to the DigitalOcean-hosted server via a remote shell The DigitalOcean-hosted server encrypts a file with your public key (sort of like creating a hash for it) and sends the encrypted file to you. Only your private key will be able to decrypt the file (sort of like getting back the original data that wash hashed). Your computer uses your private key to decrypt the file, then sends back the decrypted file to the server. You have now proved that you have the private key that matched the public key. To create your SSH keypair, use ssh-keygen as follows: With either Terminal (for Mac) or PowerShell/Git Bash (for Windows) run the following command with your own email address: ssh-keygen -t ed25519 -C <YOUR@EMAIL> You will be prompted for a file name for the private SSH key. Accept the default by pressing the Enter key. You will be prompted for a passphrase. This is important as it is used to protect your private SSH key. Make it something strong, like you would a password, and commit it to memory or write it down somewhere. If you are prompted to overwrite anything, type n and press the Enter key (OPTIONAL STEP) To avoid having to enter the passphrase every time you use your private key, set up ssh-agent as describe in this tutorial . Create a Debian 9 Server on DigitalOcean \u00b6 Log into your DigitalOcean account, go to the 'Droplet' tab on the left, and click 'Create Droplet'. Then set the Droplet up based on the following parameters: Image Debian 9.12 x64 Plan Starter / $5 per month Authentication SSH keys Right under the 'SSH keys' option in the 'Authentication' section, you'll see a button that says 'New SSH Key'. Press it, and you'll be prompted for your public SSH key. To get your public SSH key, enter the following in either Terminal (for Mac) or PowerShell/Git Bash (for Windows) cat ~/.ssh/id_ed25519.pub Warning Make sure to enter the .pub extension at the end of this line! Without the extension, you will get back your private key instead of your public key! You should then see a string like this: Copy the string (from the ssh-ed25519 all the way to the end of your email) and paste it into the 'Add public SSH key' window in DigitalOcean like so: Then type a name for the key (something like 'My Macbook Pro') and press 'Add SSH Key' Now you are all set to create the Droplet. Scroll down to and press 'Create Droplet'. If you want, you can create a name for this server in the 'Choose a hostname' section. Wait for the droplet to be created. When it's finished, copy the IP address of the server for the next section. It's the number right next to the server's name. Connect and Manage your Server \u00b6 Log in to the droplet as the root user via SSH \u00b6 In order to manage our remote server, we\u2019ll use SSH to connect remotely. Since we have already associated a set of SSH keys with the server, we will be able to log in the the server as the 'root' user without directly entering a password. The 'root' user is the default user on a Linux system, and it has permission to do anything . This is much different from a standard user account, say 'John', who only has permission to write, read, or execute certain files, like his user directory. We will begin this lab by logging in as the 'root' user, but we will soon create another user on the server and use that instead. It's typically not advised to use the root user on a Linux system unless what you're doing requires it. The syntax for ssh is: ssh <USERNAME>@<SERVER> We'll log in as the 'root' user, and use the IP address we copied earlier: e.g., ssh root@<SERVER_IP> for me that's ssh root@104.248.59.220 If you entered the command correctly, you should see something like: The authenticity of host '104.248.59.220 (104.248.59.220)' can't be established. ECDSA key fingerprint is SHA256:... Are you sure you want to continue connecting (yes/no)? This is your computer letting you know it's never connected to this server before. That's okay, so: Type yes and press enter. You will then be prompted with something like: Warning: Permanently added '104.248.59.220' (ECDSA) to the list of known hosts. Linux debian-info314-sp20 4.9.0-12-amd64 #1 SMP Debian 4.9.210-1 (2020-01-20) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. And finally you see something like this: root@debian-fdk542-432kgs:~# To receive credit for this lab, you need to create a transcript of all the commands you issue to the server. To do this, we will use the script command to capture your session. Enter: script root-session This will use the script program to create a log of all your shell input and save it to a file named root-session You should see this message: Script started, file is root-session Now, everything you type in this shell will now be captured in a file named root-session within your home directory. If you need to exit the server anytime, just type exit . The first time you exit you'll get the output: Script done, file is root-session This lets you know that script has finished recording and have saved the transcript. Next, type exit once more and you will be logged out of the SSH session, receving the message: logout Connection to 104.248.59.220 closed. Warning It's important that if you exit from the server and then reconnect to it (via ssh ) that you continue your script. This will ensure everything keeps being recorded and you will get full credit for the lab. To continue the script, type: script -a root-session after you SSH back into the server. You'll again be prompted with: Script started, file is root-session which ensures that your next commands will be appended to the root-session file Create a second user account \u00b6 In most situations, we will not work directly as the root user, since this would pose additional security risks. In fact, many Linux distributions will prevent direct root login. Let\u2019s create a new user and practice working with this configuration. Add a new user by entering this (where is your name or something else you'll remember) adduser <YOUR_USERNAME> you'll be prompted for other information, such as a password and a name. Give the account a password you'll remember, and skip the other fields (such as name) by pressing 'Enter'. Then, add the user to the sudo group: usermod -aG sudo <YOUR_USERNAME> This allows the new user to use sudo before commands. Using sudo allows a user who is not root to use root privaleges on a per-command basis. By default, DigitalOcean prevents users from connecting via SSH without an SSH key. This is the correct decision from the security perspective, but we will disable it temporarily in order to explore beneath the hood. Modify /etc/ssh/sshd_config to enable password-based login by editing it as follows: First, open sshd_config in nano by using: nano /etc/ssh/sshd_config This will open nano . nano is a terminal-based editor, and is very simple. You can only move the cursor by using the arrow keys. To copy text from a file using nano , select it using your mouse and then copy it as usual (Control+C on Windows, Command + C on Mac) In nano , Find the: PasswordAuthentication no setting and prefix it with a # comment character, so it should read: #PasswordAuthentication no Then save the document in nano by pressing: Control + X in Windows, Command + X in Mac. Settings don\u2019t take effect automatically. Use the systemctl tool to restart the sshd service: systemctl restart sshd Log in as your new user \u00b6 In a new terminal window , log in as the new user via SSH using the password you created above. Capture a script of your session by calling: script user-session The results of this command will be saved in a file named user-session. When you log in, run: pwd and make note of the directory. This is your home directory. Notice that the home directory for each user is different. Try listing the contents of the root user\u2019s home directory by typing: ls -al /root You should receive a permission denied error. The /root path is owned by the root user and has permissions restricted so that other users cannot read, write, or execute the directory or anything else it contains. Since root is a special user, the restriction does not apply in the other direction. Demonstrate this difference in permissions by listing the contents of the new user\u2019s home directory from the root user\u2019s shell , e.g., ls -al /home/clinton from your root login and view the contents of my user\u2019s home directory. By default in basic Linux distributions, the root user has complete control over all system and user resources and is even able to take on the identity of other users without knowing their passwords. Running Administrative Commands \u00b6 Many of the administration tasks we need to complete throughout the quarter require root level permissions. Since we\u2019ve already established that we will deliberately work as a non-root user, we should determine a method to elevate our privileges. In Linux and other Unix-based operating systems, the command that allows us to do this is called sudo . By prefixing any valid shell command or program name with sudo , we will assume the identity of root at runtime. Test this out by comparing the results of ( within the new user's shell ) whoami with the results of sudo whoami The next step will require us to log out of our current ssh session. Before you do this, type exit to end the current script session. You should see a message stating that the script is complete. You may now log out of ssh by running the exit command. Add SSH keys for your user \u00b6 As you\u2019ve seen, we can log into the root account without entering a password because of the SSH keys that we created at the beginning of this lab, but logging into our new user account requires a password (which is a much weaker configuration from a security perspective). Let\u2019s resolve this by adding our public SSH key to the new user account on our Droplet. First switch back to your root shell and examine the files saved in the .ssh folder of root\u2019s home directory. To do this, we'll switch to the .ssh directory using cd . cd stands for 'Change Directory' and will let you switch the folder you are in. To change to the .ssh folder type: cd .ssh Now you can use ls -al to view the contents of the folder once you are in it. What you should see in the specified path is a file named authorized_keys that contains a copy of your SSH public key on a line by itself. We\u2019ll be creating a similar file in the home directory of our new user. On each login attempt, the SSH server checks for authorized_keys designated for the user and loads. First, within a new terminal window , type: ssh <YOUR_USERNAME>@<SERVER_IP> 'mkdir -p ~/.ssh' This creates a quick SSH session into your user, and makes a new directory called .ssh for that user. Next, you'll copy your public key ( $HOME/.ssh/id_ed25519.pub ) to the Droplet using the scp command. scp is part of the OpenSSH client package and is used to copy files between paths on local and remote hosts. You will notice that it uses ssh syntax to identify the remote location followed by a colon and the actual source or target path at the remote location: NOTE: The following command is entered as one line but is wrapped due to the constraints of the editor. scp $HOME/.ssh/id_ed25519.pub <YOUR_USERNAME>@<SERVER_IP>:.ssh/authorized_keys Be aware that scp respects file permissions. When connecting as my non-root user, I cannot read or write to locations that are restricted to other users or root. Install a web server \u00b6 Test that you successfully copied your public key to the server and can access the Droplet as your non-root user without having to enter a server password: ssh <YOUR_USERNAME>@<SERVER_IP> You should not be prompted for your UNIX/Linux user password you set, it should instead use the SSH key as before, and if you set it, ask for the SSH passphrase. Once you are logged back in, resume your script by running script -a user-session Install the nginx web service using the command: sudo apt install nginx Verify that the service installed correctly by running systemctl status nginx and confirming that the nginx service is loaded and running. Use a web browser to navigate to your IP address and load the default nginx site, e.g., > , in my case http://134.209.4.234 Once you have completed these tasks, please close out the scripts from your root and user shell by typing exit twice on each shell. Now on your computer (no longer on the server!) , use scp to copy the scripts over by typing: scp root@<SERVER_IP>:root-session $HOME/Desktop and scp <YOUR_USERNAME>@<SERVER_IP>:user-session $HOME/Desktop They will be on your desktop. Deliverables \u00b6 For your deliverables, you will need to submit three files. Your user-session file (user-session) Your root-session file (root-session) A completed lab report using the markdown template provided above, exported to PDF. The lab report can be found at Lab 1 Assignment page on Canvas","title":"Lab 1 - Core Technical Skills"},{"location":"assignments/lab1/#lab-1-core-technical-skills","text":"Lab 1 Assignment page on Canvas","title":"Lab 1 - Core Technical Skills"},{"location":"assignments/lab1/#overview","text":"In this lab you will be introduced to working with a headless Linux server. The work you do in this lab will be extremely helpful in becoming more comfortable with your Raspberry Pi. We will walk you through all of the required steps in lab, but all the required steps are also in this webpage.","title":"Overview"},{"location":"assignments/lab1/#before-you-start","text":"","title":"Before you start"},{"location":"assignments/lab1/#everyone","text":"Confirm that you have created a DigitalOcean account, and that on the top right of the website it says you have $100.00 of credits. This will allow you to create virtual machine \u201cDroplets\u201d on DigitalOcean without incurring any direct cost. In addition to the email we sent on Sunday, instructions to complete this task can be found in here .","title":"Everyone"},{"location":"assignments/lab1/#windows","text":"Determine which build of Windows 10 they have installed by running Get-ComputerInfo -Property WindowsVersion in PowerShell. The minimum version of Windows 10 required for this course is 1809, but you may proceed with this lab as long as you are running 1803. For any prior version of Windows (older than 1803), please install Git for Windows from https://gitforwindows.org/ and use the Git Bash environment to complete the following set of exercises instead of PowerShell.","title":"Windows"},{"location":"assignments/lab1/#create-ssh-client-keys","text":"To use the DigitalOcean server we will soon create, you'll need a way to authenticate yourself and login to your server. While you might think a password will suffice, we will be using a more secure method of authentication through SSH keys. SSH stands for 'Secure Shell'. A 'shell' is a command line interface, such as the one's you've seen in Terminal, PowerShell, or Git Bash. Throughout this course, you'll be using the shell, remotely, to configure Linux. SSH makes the shell 'secure' by create a pair of keys that you use to authenticate yourself to a remote shell. These 'keys' are simply long strings of characters that are tied together with some complex mathematics. We will use a program called ssh-keygen to create this pair of keys. ssh-keygen will generate a private key, and a public key. Your public key can be given out, to say, DigitalOcean, while your private key remains only on your computer. In short, SSH works as follows in our scenario: Your computer connects to the DigitalOcean-hosted server via a remote shell The DigitalOcean-hosted server encrypts a file with your public key (sort of like creating a hash for it) and sends the encrypted file to you. Only your private key will be able to decrypt the file (sort of like getting back the original data that wash hashed). Your computer uses your private key to decrypt the file, then sends back the decrypted file to the server. You have now proved that you have the private key that matched the public key. To create your SSH keypair, use ssh-keygen as follows: With either Terminal (for Mac) or PowerShell/Git Bash (for Windows) run the following command with your own email address: ssh-keygen -t ed25519 -C <YOUR@EMAIL> You will be prompted for a file name for the private SSH key. Accept the default by pressing the Enter key. You will be prompted for a passphrase. This is important as it is used to protect your private SSH key. Make it something strong, like you would a password, and commit it to memory or write it down somewhere. If you are prompted to overwrite anything, type n and press the Enter key (OPTIONAL STEP) To avoid having to enter the passphrase every time you use your private key, set up ssh-agent as describe in this tutorial .","title":"Create SSH client keys"},{"location":"assignments/lab1/#create-a-debian-9-server-on-digitalocean","text":"Log into your DigitalOcean account, go to the 'Droplet' tab on the left, and click 'Create Droplet'. Then set the Droplet up based on the following parameters: Image Debian 9.12 x64 Plan Starter / $5 per month Authentication SSH keys Right under the 'SSH keys' option in the 'Authentication' section, you'll see a button that says 'New SSH Key'. Press it, and you'll be prompted for your public SSH key. To get your public SSH key, enter the following in either Terminal (for Mac) or PowerShell/Git Bash (for Windows) cat ~/.ssh/id_ed25519.pub Warning Make sure to enter the .pub extension at the end of this line! Without the extension, you will get back your private key instead of your public key! You should then see a string like this: Copy the string (from the ssh-ed25519 all the way to the end of your email) and paste it into the 'Add public SSH key' window in DigitalOcean like so: Then type a name for the key (something like 'My Macbook Pro') and press 'Add SSH Key' Now you are all set to create the Droplet. Scroll down to and press 'Create Droplet'. If you want, you can create a name for this server in the 'Choose a hostname' section. Wait for the droplet to be created. When it's finished, copy the IP address of the server for the next section. It's the number right next to the server's name.","title":"Create a Debian 9 Server on DigitalOcean"},{"location":"assignments/lab1/#connect-and-manage-your-server","text":"","title":"Connect and Manage your Server"},{"location":"assignments/lab1/#log-in-to-the-droplet-as-the-root-user-via-ssh","text":"In order to manage our remote server, we\u2019ll use SSH to connect remotely. Since we have already associated a set of SSH keys with the server, we will be able to log in the the server as the 'root' user without directly entering a password. The 'root' user is the default user on a Linux system, and it has permission to do anything . This is much different from a standard user account, say 'John', who only has permission to write, read, or execute certain files, like his user directory. We will begin this lab by logging in as the 'root' user, but we will soon create another user on the server and use that instead. It's typically not advised to use the root user on a Linux system unless what you're doing requires it. The syntax for ssh is: ssh <USERNAME>@<SERVER> We'll log in as the 'root' user, and use the IP address we copied earlier: e.g., ssh root@<SERVER_IP> for me that's ssh root@104.248.59.220 If you entered the command correctly, you should see something like: The authenticity of host '104.248.59.220 (104.248.59.220)' can't be established. ECDSA key fingerprint is SHA256:... Are you sure you want to continue connecting (yes/no)? This is your computer letting you know it's never connected to this server before. That's okay, so: Type yes and press enter. You will then be prompted with something like: Warning: Permanently added '104.248.59.220' (ECDSA) to the list of known hosts. Linux debian-info314-sp20 4.9.0-12-amd64 #1 SMP Debian 4.9.210-1 (2020-01-20) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. And finally you see something like this: root@debian-fdk542-432kgs:~# To receive credit for this lab, you need to create a transcript of all the commands you issue to the server. To do this, we will use the script command to capture your session. Enter: script root-session This will use the script program to create a log of all your shell input and save it to a file named root-session You should see this message: Script started, file is root-session Now, everything you type in this shell will now be captured in a file named root-session within your home directory. If you need to exit the server anytime, just type exit . The first time you exit you'll get the output: Script done, file is root-session This lets you know that script has finished recording and have saved the transcript. Next, type exit once more and you will be logged out of the SSH session, receving the message: logout Connection to 104.248.59.220 closed. Warning It's important that if you exit from the server and then reconnect to it (via ssh ) that you continue your script. This will ensure everything keeps being recorded and you will get full credit for the lab. To continue the script, type: script -a root-session after you SSH back into the server. You'll again be prompted with: Script started, file is root-session which ensures that your next commands will be appended to the root-session file","title":"Log in to the droplet as the root user via SSH"},{"location":"assignments/lab1/#create-a-second-user-account","text":"In most situations, we will not work directly as the root user, since this would pose additional security risks. In fact, many Linux distributions will prevent direct root login. Let\u2019s create a new user and practice working with this configuration. Add a new user by entering this (where is your name or something else you'll remember) adduser <YOUR_USERNAME> you'll be prompted for other information, such as a password and a name. Give the account a password you'll remember, and skip the other fields (such as name) by pressing 'Enter'. Then, add the user to the sudo group: usermod -aG sudo <YOUR_USERNAME> This allows the new user to use sudo before commands. Using sudo allows a user who is not root to use root privaleges on a per-command basis. By default, DigitalOcean prevents users from connecting via SSH without an SSH key. This is the correct decision from the security perspective, but we will disable it temporarily in order to explore beneath the hood. Modify /etc/ssh/sshd_config to enable password-based login by editing it as follows: First, open sshd_config in nano by using: nano /etc/ssh/sshd_config This will open nano . nano is a terminal-based editor, and is very simple. You can only move the cursor by using the arrow keys. To copy text from a file using nano , select it using your mouse and then copy it as usual (Control+C on Windows, Command + C on Mac) In nano , Find the: PasswordAuthentication no setting and prefix it with a # comment character, so it should read: #PasswordAuthentication no Then save the document in nano by pressing: Control + X in Windows, Command + X in Mac. Settings don\u2019t take effect automatically. Use the systemctl tool to restart the sshd service: systemctl restart sshd","title":"Create a second user account"},{"location":"assignments/lab1/#log-in-as-your-new-user","text":"In a new terminal window , log in as the new user via SSH using the password you created above. Capture a script of your session by calling: script user-session The results of this command will be saved in a file named user-session. When you log in, run: pwd and make note of the directory. This is your home directory. Notice that the home directory for each user is different. Try listing the contents of the root user\u2019s home directory by typing: ls -al /root You should receive a permission denied error. The /root path is owned by the root user and has permissions restricted so that other users cannot read, write, or execute the directory or anything else it contains. Since root is a special user, the restriction does not apply in the other direction. Demonstrate this difference in permissions by listing the contents of the new user\u2019s home directory from the root user\u2019s shell , e.g., ls -al /home/clinton from your root login and view the contents of my user\u2019s home directory. By default in basic Linux distributions, the root user has complete control over all system and user resources and is even able to take on the identity of other users without knowing their passwords.","title":"Log in as your new user"},{"location":"assignments/lab1/#running-administrative-commands","text":"Many of the administration tasks we need to complete throughout the quarter require root level permissions. Since we\u2019ve already established that we will deliberately work as a non-root user, we should determine a method to elevate our privileges. In Linux and other Unix-based operating systems, the command that allows us to do this is called sudo . By prefixing any valid shell command or program name with sudo , we will assume the identity of root at runtime. Test this out by comparing the results of ( within the new user's shell ) whoami with the results of sudo whoami The next step will require us to log out of our current ssh session. Before you do this, type exit to end the current script session. You should see a message stating that the script is complete. You may now log out of ssh by running the exit command.","title":"Running Administrative Commands"},{"location":"assignments/lab1/#add-ssh-keys-for-your-user","text":"As you\u2019ve seen, we can log into the root account without entering a password because of the SSH keys that we created at the beginning of this lab, but logging into our new user account requires a password (which is a much weaker configuration from a security perspective). Let\u2019s resolve this by adding our public SSH key to the new user account on our Droplet. First switch back to your root shell and examine the files saved in the .ssh folder of root\u2019s home directory. To do this, we'll switch to the .ssh directory using cd . cd stands for 'Change Directory' and will let you switch the folder you are in. To change to the .ssh folder type: cd .ssh Now you can use ls -al to view the contents of the folder once you are in it. What you should see in the specified path is a file named authorized_keys that contains a copy of your SSH public key on a line by itself. We\u2019ll be creating a similar file in the home directory of our new user. On each login attempt, the SSH server checks for authorized_keys designated for the user and loads. First, within a new terminal window , type: ssh <YOUR_USERNAME>@<SERVER_IP> 'mkdir -p ~/.ssh' This creates a quick SSH session into your user, and makes a new directory called .ssh for that user. Next, you'll copy your public key ( $HOME/.ssh/id_ed25519.pub ) to the Droplet using the scp command. scp is part of the OpenSSH client package and is used to copy files between paths on local and remote hosts. You will notice that it uses ssh syntax to identify the remote location followed by a colon and the actual source or target path at the remote location: NOTE: The following command is entered as one line but is wrapped due to the constraints of the editor. scp $HOME/.ssh/id_ed25519.pub <YOUR_USERNAME>@<SERVER_IP>:.ssh/authorized_keys Be aware that scp respects file permissions. When connecting as my non-root user, I cannot read or write to locations that are restricted to other users or root.","title":"Add SSH keys for your user"},{"location":"assignments/lab1/#install-a-web-server","text":"Test that you successfully copied your public key to the server and can access the Droplet as your non-root user without having to enter a server password: ssh <YOUR_USERNAME>@<SERVER_IP> You should not be prompted for your UNIX/Linux user password you set, it should instead use the SSH key as before, and if you set it, ask for the SSH passphrase. Once you are logged back in, resume your script by running script -a user-session Install the nginx web service using the command: sudo apt install nginx Verify that the service installed correctly by running systemctl status nginx and confirming that the nginx service is loaded and running. Use a web browser to navigate to your IP address and load the default nginx site, e.g., > , in my case http://134.209.4.234 Once you have completed these tasks, please close out the scripts from your root and user shell by typing exit twice on each shell. Now on your computer (no longer on the server!) , use scp to copy the scripts over by typing: scp root@<SERVER_IP>:root-session $HOME/Desktop and scp <YOUR_USERNAME>@<SERVER_IP>:user-session $HOME/Desktop They will be on your desktop.","title":"Install a web server"},{"location":"assignments/lab1/#deliverables","text":"For your deliverables, you will need to submit three files. Your user-session file (user-session) Your root-session file (root-session) A completed lab report using the markdown template provided above, exported to PDF. The lab report can be found at Lab 1 Assignment page on Canvas","title":"Deliverables"},{"location":"assignments/lab2/","text":"Lab 2 - Analyzing DHCP and ARP with Wireshark \u00b6 Lab 2 Assignment page on Canvas Overview \u00b6 The purpose of this lab is for students to get familiar with basic functionalities of Wireshark, and to be able to capture and analyze network traffic. There will be multiple correct ways to complete this lab, we highly recommend using search engines to help you find solutions. Introduction to Wireshark \u00b6 Wireshark is a tool designed to record and observe the messages that are sent over a network and to provide an analyst with tools to understand and troubleshoot the protocols associated with those messages. Starting a Capture \u00b6 Open Wireshark and locate the Capture section of the launch screen. This section contains an input field for configuring capture filters and a list of physical and virtual interfaces that can be used to capture packets. To the right of each interface, you should notice an animated \u201csparkline\u201d which indicates the level of activity on the associated network. You can launch a capture on your active interface (likely Wi-Fi or Ethernet) by double-clicking on the respective label. If a capture filter was specified before you selected the interface, Wireshark ignores any packets that don't match the filter. If the filter input is empty, Wireshark records everything it sees on the wire. Recording continues until you press the stop icon in the top toolbar or close the application. Exploring a Capture \u00b6 By default, Wireshark will divide capture-related content among three panes: Packet List Packet Details Packet Bytes The Packet List displays all packets in the current capture, summarizing important details about traffic flow and the type of data contained in the packet. The Packet Details view initially displays a layered summary of the protocols represented in the selected packet. A more detailed view of each protocol can be explored by clicking the arrow icons to the left of the summary. The order of the protocols in this view corresponds to the order in which each protocol\u2019s header appears in the data frame. The Packet Bytes pane can be useful for understanding the basic structure of raw network messages. As you navigate through the details in this view, Wireshark will highlight the corresponding bytes in the Packet Bytes pane. Narrowing your Search \u00b6 If you have any software, particularly a web browser, running in the background, you'll notice that Wireshark can quickly accumulate a large list of packets. Fortunately, the software provides a variety of tools to help you more easily locate packets relevant to your search. The packet list can be modified non-destructively by adding/removing display filters 1 in the input field below the top toolbar. Display filters are a valuable analytic tool that allows you to remove noise and quickly focus on packets that match certain criteria. In addition to writing your own display filters, you can access a variety of context-specific analysis tools by right clicking on any row of the Packet List or a field within the Packet Details pane. These tools can help you create a display filter based on the current packet or to investigate a conversation that spans multiple packets. Instructions \u00b6 DHCP \u00b6 Setup \u00b6 Stop any ongoing captures and configure a new capture on your wireless interface with capture filter arp || udp portrange 67-68 . This filter will prevent Wireshark from capturing excessive amounts of traffic so that we can leave the capture running for the entire lab. While our current capture should be fairly quiet owing to the previous capture filter, create a display filter to further reduce the number of visible packets (Hint: Type dhcp into the display filter input below the main wireshark toolbar). At the end of the lab, save your capture and submit it with your assignment. Request a new DHCP Lease \u00b6 In order to properly complete this lab, you will need to terminate your current DHCP lease so that you can capture the process of DHCP initializing your network interface. This process will differ depending on your OS. Follow the instructions linked on the resources site to complete this process. Report \u00b6 Based on your capture, create an outline of your complete DHCP exchange. For each message: Include a screenshot of the packet details summary. Include a brief written summary, identifying: DHCP message type, DHCP transaction ID, source and destination Ethernet addresses, source and destination IP addresses, and UDP source and destination UDP ports associated. How can you determine which messages were sent by your own device versus the DHCP server? Based on the outline you created above, determine the purpose of the 0.0.0.0 address appearing within the DHCP exchange. What Ethernet-layer (Layer 2) address corresponds to the 255.255.255.255 (Layer 3) IP address? Using online resources as necessary, determine the purpose of these special addresses. Which of the fields that you have observed can be used to distinguish between different conversations between the same client and server? If you look closely at the packet details for each message, you'll notice that each DHCP message contains a variety of options. In DHCP, options allow DHCP clients and servers to adapt the protocol to their own needs. Like many other protocols, DHCP encodes options as a type , a length , and a value . Based on this structure, we can continue to extend the protocol without needing to change the basic foundation. Using your search engine of choice, identify the IETF RFC (# and name) that defines the common option types for the DHCP protocol. Which DHCP Option (#) tells us the DHCP message type? How many bytes are required to encode the type? Which DHCP Option (#) tells us the length of a DHCP lease? How many bytes are required to encode the duration of the lease? According to the RFC, is it possible to specify the lease length in any unit of time other than seconds? Compare the Lease Time option of the Discover message with the value in the Offer message. Did your device request a particular duration? If so, did the server honor this request? Using online resources as needed, determine what happens at the end of a DHCP address lease. Based on the order of the messages in the capture and the details we've asked you to examine, offer an explanation of how the DHCP protocol works to configure your network interface with appropriate settings. How does the protocol make use of Ethernet and IP broadcast functionality, and why is that important? Use your capture to illustrate your point. ARP \u00b6 Setup \u00b6 You may continue to use the same capture for this section. If you launch a new capture, please save the first capture and submit both with your assignment. Before you begin the analysis questions, clear the ARP cache per instructions linked on the resources site and generate some Internet traffic, e.g., browse the web. Remove any existing display filters and create a new filter that will only show ARP related traffic. (Hint: type arp in the display filter input). Report \u00b6 Outline a complete ARP exchange (request and response). For each message: Include a screenshot of the packet details summary. Include a brief written summary, identifying: ARP Opcode, Sender and Target Ethernet addresses, Sender and Target IP addresses. Identify the 48-bit hardware address associated with your network interface and use this information to specify which message(s) originated from your local device? Determine which messages are sent to a broadcast destination. Why do you think the ARP protocol makes use of the broadcast destination? Aside from the broadcast address, what other differences do you notice between the contents of ARP requests and replies? Spend a moment comparing the overall packet structure (as seen in the Packet Details view) between DHCP and ARP. Identify any layers that are present in one protocol but not in the other. In order for a network message to be considered an IP packet, the message must contain an Internet Protocol layer that includes an IP header for the rest of the message. Does the ARP protocol use IP packets to communicate? Describe in your own words how ARP works to allow hosts to communicate in a Layer-2 network based on IP address. Use your capture to illustrate your points. Do not confuse display filters and capture filters. They serve very different purposes and even use distinct syntax. \u21a9","title":"Lab 2 - Analyzing DHCP and ARP with Wireshark"},{"location":"assignments/lab2/#lab-2-analyzing-dhcp-and-arp-with-wireshark","text":"Lab 2 Assignment page on Canvas","title":"Lab 2 - Analyzing DHCP and ARP with Wireshark"},{"location":"assignments/lab2/#overview","text":"The purpose of this lab is for students to get familiar with basic functionalities of Wireshark, and to be able to capture and analyze network traffic. There will be multiple correct ways to complete this lab, we highly recommend using search engines to help you find solutions.","title":"Overview"},{"location":"assignments/lab2/#introduction-to-wireshark","text":"Wireshark is a tool designed to record and observe the messages that are sent over a network and to provide an analyst with tools to understand and troubleshoot the protocols associated with those messages.","title":"Introduction to Wireshark"},{"location":"assignments/lab2/#starting-a-capture","text":"Open Wireshark and locate the Capture section of the launch screen. This section contains an input field for configuring capture filters and a list of physical and virtual interfaces that can be used to capture packets. To the right of each interface, you should notice an animated \u201csparkline\u201d which indicates the level of activity on the associated network. You can launch a capture on your active interface (likely Wi-Fi or Ethernet) by double-clicking on the respective label. If a capture filter was specified before you selected the interface, Wireshark ignores any packets that don't match the filter. If the filter input is empty, Wireshark records everything it sees on the wire. Recording continues until you press the stop icon in the top toolbar or close the application.","title":"Starting a Capture"},{"location":"assignments/lab2/#exploring-a-capture","text":"By default, Wireshark will divide capture-related content among three panes: Packet List Packet Details Packet Bytes The Packet List displays all packets in the current capture, summarizing important details about traffic flow and the type of data contained in the packet. The Packet Details view initially displays a layered summary of the protocols represented in the selected packet. A more detailed view of each protocol can be explored by clicking the arrow icons to the left of the summary. The order of the protocols in this view corresponds to the order in which each protocol\u2019s header appears in the data frame. The Packet Bytes pane can be useful for understanding the basic structure of raw network messages. As you navigate through the details in this view, Wireshark will highlight the corresponding bytes in the Packet Bytes pane.","title":"Exploring a Capture"},{"location":"assignments/lab2/#narrowing-your-search","text":"If you have any software, particularly a web browser, running in the background, you'll notice that Wireshark can quickly accumulate a large list of packets. Fortunately, the software provides a variety of tools to help you more easily locate packets relevant to your search. The packet list can be modified non-destructively by adding/removing display filters 1 in the input field below the top toolbar. Display filters are a valuable analytic tool that allows you to remove noise and quickly focus on packets that match certain criteria. In addition to writing your own display filters, you can access a variety of context-specific analysis tools by right clicking on any row of the Packet List or a field within the Packet Details pane. These tools can help you create a display filter based on the current packet or to investigate a conversation that spans multiple packets.","title":"Narrowing your Search"},{"location":"assignments/lab2/#instructions","text":"","title":"Instructions"},{"location":"assignments/lab2/#dhcp","text":"","title":"DHCP"},{"location":"assignments/lab2/#setup","text":"Stop any ongoing captures and configure a new capture on your wireless interface with capture filter arp || udp portrange 67-68 . This filter will prevent Wireshark from capturing excessive amounts of traffic so that we can leave the capture running for the entire lab. While our current capture should be fairly quiet owing to the previous capture filter, create a display filter to further reduce the number of visible packets (Hint: Type dhcp into the display filter input below the main wireshark toolbar). At the end of the lab, save your capture and submit it with your assignment.","title":"Setup"},{"location":"assignments/lab2/#request-a-new-dhcp-lease","text":"In order to properly complete this lab, you will need to terminate your current DHCP lease so that you can capture the process of DHCP initializing your network interface. This process will differ depending on your OS. Follow the instructions linked on the resources site to complete this process.","title":"Request a new DHCP Lease"},{"location":"assignments/lab2/#report","text":"Based on your capture, create an outline of your complete DHCP exchange. For each message: Include a screenshot of the packet details summary. Include a brief written summary, identifying: DHCP message type, DHCP transaction ID, source and destination Ethernet addresses, source and destination IP addresses, and UDP source and destination UDP ports associated. How can you determine which messages were sent by your own device versus the DHCP server? Based on the outline you created above, determine the purpose of the 0.0.0.0 address appearing within the DHCP exchange. What Ethernet-layer (Layer 2) address corresponds to the 255.255.255.255 (Layer 3) IP address? Using online resources as necessary, determine the purpose of these special addresses. Which of the fields that you have observed can be used to distinguish between different conversations between the same client and server? If you look closely at the packet details for each message, you'll notice that each DHCP message contains a variety of options. In DHCP, options allow DHCP clients and servers to adapt the protocol to their own needs. Like many other protocols, DHCP encodes options as a type , a length , and a value . Based on this structure, we can continue to extend the protocol without needing to change the basic foundation. Using your search engine of choice, identify the IETF RFC (# and name) that defines the common option types for the DHCP protocol. Which DHCP Option (#) tells us the DHCP message type? How many bytes are required to encode the type? Which DHCP Option (#) tells us the length of a DHCP lease? How many bytes are required to encode the duration of the lease? According to the RFC, is it possible to specify the lease length in any unit of time other than seconds? Compare the Lease Time option of the Discover message with the value in the Offer message. Did your device request a particular duration? If so, did the server honor this request? Using online resources as needed, determine what happens at the end of a DHCP address lease. Based on the order of the messages in the capture and the details we've asked you to examine, offer an explanation of how the DHCP protocol works to configure your network interface with appropriate settings. How does the protocol make use of Ethernet and IP broadcast functionality, and why is that important? Use your capture to illustrate your point.","title":"Report"},{"location":"assignments/lab2/#arp","text":"","title":"ARP"},{"location":"assignments/lab2/#setup_1","text":"You may continue to use the same capture for this section. If you launch a new capture, please save the first capture and submit both with your assignment. Before you begin the analysis questions, clear the ARP cache per instructions linked on the resources site and generate some Internet traffic, e.g., browse the web. Remove any existing display filters and create a new filter that will only show ARP related traffic. (Hint: type arp in the display filter input).","title":"Setup"},{"location":"assignments/lab2/#report_1","text":"Outline a complete ARP exchange (request and response). For each message: Include a screenshot of the packet details summary. Include a brief written summary, identifying: ARP Opcode, Sender and Target Ethernet addresses, Sender and Target IP addresses. Identify the 48-bit hardware address associated with your network interface and use this information to specify which message(s) originated from your local device? Determine which messages are sent to a broadcast destination. Why do you think the ARP protocol makes use of the broadcast destination? Aside from the broadcast address, what other differences do you notice between the contents of ARP requests and replies? Spend a moment comparing the overall packet structure (as seen in the Packet Details view) between DHCP and ARP. Identify any layers that are present in one protocol but not in the other. In order for a network message to be considered an IP packet, the message must contain an Internet Protocol layer that includes an IP header for the rest of the message. Does the ARP protocol use IP packets to communicate? Describe in your own words how ARP works to allow hosts to communicate in a Layer-2 network based on IP address. Use your capture to illustrate your points. Do not confuse display filters and capture filters. They serve very different purposes and even use distinct syntax. \u21a9","title":"Report"},{"location":"assignments/lab3/","text":"Lab 3 - Analyze Zeroconf in Wireshark \u00b6 Lab 3 Assignment page on Canvas Overview \u00b6 Most of the time, our discussion about IP addresses are focused on globally routable addresses or on RFC1918 private addresses. In this lab, we are going to explore another type of address that can be used without any explicit configuration (either by a user or network administrator). We\u2019re also going to look at how these addresses fit in to a group of protocols called the zero-configuration networking (zeroconf) protocols and explore how zeroconf appears in this class and in our daily use of network technology. This lab will require a combination of Wireshark analysis and Internet research. We\u2019ve provided links to several references as a starting point, but you are free to look up other resources as needed. Please cite all sources in your deliverable. Resources \u00b6 https://en.wikipedia.org/wiki/Link-local_address (Links to an external site.) https://tools.ietf.org/html/rfc3927 (Links to an external site.) https://en.wikipedia.org/wiki/.local (Links to an external site.) https://en.wikipedia.org/wiki/Zero-configuration_networking (Links to an external site.) Part I - Identification \u00b6 Report: Before you start, take a moment to record some details about your computer and your Ethernet network adapter. These details may be helpful to you in your analysis: Hostname (Computer, Pi) MAC Address (Computer, Pi) Part II - Powering on your Pi \u00b6 If you already started your Pi, shut it down and disconnect power before you begin. Launch a new Wireshark capture over the Ethernet connection to your Pi. Linux users should listen on the \u201cAll\u201d interface and may want to disable their wireless connection before capturing to reduce noise and focus on the important details. With your capture running, power on the Pi. You\u2019ll be keeping an eye on the capture in order to see what happens when your computer and your Pi first connect to the network. Report: Identify the link-local addresses and mDNS names associated with your computer and your Pi. Using your capture as a reference, identify the messages that your Pi sends while autoconfiguring its own IP addresses. Describe the autoconfiguration process used by hosts to choose a link-local address and confirm that it is unique on the local network segment. Part III - Contacting your Pi \u00b6 With your capture still running, let\u2019s try to contact your Pi. Try pinging your Pi based on the hostname \u201craspberrypi.local\u201d (substitute your own hostname if you\u2019ve already changed it). Likewise, try connecting to your pi via SSH. Report: Using your capture, identify an example of an IPv4 and IPv6 mDNS request. Identify the multicast addresses used by mDNS in IPv4 and IPv6. Using your capture, identify an example of an IPv4 and IPv6 mDNS response. Are mDNS responses sent to a multicast address or to a specific unicast address. Identify the destination addresses used to reach your Pi in the final ICMP echo request (ping) and SSH connection. Part IV - Manually Querying mDNS devices \u00b6 Lastly, let\u2019s look at some tools that will allow us to manually query mDNS devices on our network. Unlike DNS, we should see that individual devices answer their own queries. Windows users can use the powershell command Resolve-DNSName while macOS and Linux users should be able to use dns-sd . Report: Use man to look up more information about the relevant command and to determine the correct syntax for making an mDNS request to your Pi. Provide a screenshot of your mDNS request and the output received. Part V - Protocol Research \u00b6 Perform your own research into these protocols and answer the following questions. We recommend starting with the resources listed at the end of this guide. Describe the major difference between how link local addresses are assigned and used in IPv4 versus in IPv6. In your own words, summarize how RFC 3927 says we can determine whether hosts are located on the same network link. Based on what you\u2019ve learned, describe how we are able to connect with a Pi based on a pre-defined hostname without the need for any infrastructure like a DHCP or DNS server. Based on what you\u2019ve learned about link-local addresses, describe how you might use Wireshark in conjunction with other network utilities to troubleshoot the connection to a headless device (i.e., a device like the Pi that you can only access over the network). Extra Credit (Optional) \u00b6 Perform an mDNS scavenger hunt with Wireshark on a couple of different networks. Provide a short (about \u00bd page) analysis of your search along with capture samples. What types of devices were you able to discover? How does mDNS make your life more convenient?","title":"Lab 3 - Analyze Zeroconf in Wireshark"},{"location":"assignments/lab3/#lab-3-analyze-zeroconf-in-wireshark","text":"Lab 3 Assignment page on Canvas","title":"Lab 3 - Analyze Zeroconf in Wireshark"},{"location":"assignments/lab3/#overview","text":"Most of the time, our discussion about IP addresses are focused on globally routable addresses or on RFC1918 private addresses. In this lab, we are going to explore another type of address that can be used without any explicit configuration (either by a user or network administrator). We\u2019re also going to look at how these addresses fit in to a group of protocols called the zero-configuration networking (zeroconf) protocols and explore how zeroconf appears in this class and in our daily use of network technology. This lab will require a combination of Wireshark analysis and Internet research. We\u2019ve provided links to several references as a starting point, but you are free to look up other resources as needed. Please cite all sources in your deliverable.","title":"Overview"},{"location":"assignments/lab3/#resources","text":"https://en.wikipedia.org/wiki/Link-local_address (Links to an external site.) https://tools.ietf.org/html/rfc3927 (Links to an external site.) https://en.wikipedia.org/wiki/.local (Links to an external site.) https://en.wikipedia.org/wiki/Zero-configuration_networking (Links to an external site.)","title":"Resources"},{"location":"assignments/lab3/#part-i-identification","text":"Report: Before you start, take a moment to record some details about your computer and your Ethernet network adapter. These details may be helpful to you in your analysis: Hostname (Computer, Pi) MAC Address (Computer, Pi)","title":"Part I - Identification"},{"location":"assignments/lab3/#part-ii-powering-on-your-pi","text":"If you already started your Pi, shut it down and disconnect power before you begin. Launch a new Wireshark capture over the Ethernet connection to your Pi. Linux users should listen on the \u201cAll\u201d interface and may want to disable their wireless connection before capturing to reduce noise and focus on the important details. With your capture running, power on the Pi. You\u2019ll be keeping an eye on the capture in order to see what happens when your computer and your Pi first connect to the network. Report: Identify the link-local addresses and mDNS names associated with your computer and your Pi. Using your capture as a reference, identify the messages that your Pi sends while autoconfiguring its own IP addresses. Describe the autoconfiguration process used by hosts to choose a link-local address and confirm that it is unique on the local network segment.","title":"Part II - Powering on your Pi"},{"location":"assignments/lab3/#part-iii-contacting-your-pi","text":"With your capture still running, let\u2019s try to contact your Pi. Try pinging your Pi based on the hostname \u201craspberrypi.local\u201d (substitute your own hostname if you\u2019ve already changed it). Likewise, try connecting to your pi via SSH. Report: Using your capture, identify an example of an IPv4 and IPv6 mDNS request. Identify the multicast addresses used by mDNS in IPv4 and IPv6. Using your capture, identify an example of an IPv4 and IPv6 mDNS response. Are mDNS responses sent to a multicast address or to a specific unicast address. Identify the destination addresses used to reach your Pi in the final ICMP echo request (ping) and SSH connection.","title":"Part III - Contacting your Pi"},{"location":"assignments/lab3/#part-iv-manually-querying-mdns-devices","text":"Lastly, let\u2019s look at some tools that will allow us to manually query mDNS devices on our network. Unlike DNS, we should see that individual devices answer their own queries. Windows users can use the powershell command Resolve-DNSName while macOS and Linux users should be able to use dns-sd . Report: Use man to look up more information about the relevant command and to determine the correct syntax for making an mDNS request to your Pi. Provide a screenshot of your mDNS request and the output received.","title":"Part IV - Manually Querying mDNS devices"},{"location":"assignments/lab3/#part-v-protocol-research","text":"Perform your own research into these protocols and answer the following questions. We recommend starting with the resources listed at the end of this guide. Describe the major difference between how link local addresses are assigned and used in IPv4 versus in IPv6. In your own words, summarize how RFC 3927 says we can determine whether hosts are located on the same network link. Based on what you\u2019ve learned, describe how we are able to connect with a Pi based on a pre-defined hostname without the need for any infrastructure like a DHCP or DNS server. Based on what you\u2019ve learned about link-local addresses, describe how you might use Wireshark in conjunction with other network utilities to troubleshoot the connection to a headless device (i.e., a device like the Pi that you can only access over the network).","title":"Part V - Protocol Research"},{"location":"assignments/lab3/#extra-credit-optional","text":"Perform an mDNS scavenger hunt with Wireshark on a couple of different networks. Provide a short (about \u00bd page) analysis of your search along with capture samples. What types of devices were you able to discover? How does mDNS make your life more convenient?","title":"Extra Credit (Optional)"},{"location":"assignments/lab4/","text":"Lab 4 - Analyze TCP with ncat and Wireshark \u00b6 Lab 4 Assignment page on Canvas Overview \u00b6 The purpose of this lab is for students to gain hands on experience with TCP connections. By the end of the lab you will be familiar with: ncat TCP handshakes http https Security faults of http We highly recommend using search engines to help you find solutions. Setup \u00b6 For this lab, we are going to use the incredibly versatile ncat utility to directly read and write data to and from HTTP(s) servers. Some of you may already be familiar with a similar tool known as netcat ( nc from the command line on most Linux or macOS machines). ncat is a re-implementation of netcat that adds some handy features (like SSL/TLS connections). Windows \u00b6 Please follow instructions to install ncat from https://nmap.org/ncat/ . You can accomplish this either by installing the nmap port scanner suite or by installing the portable executable . Note You may need to update your system path to include the directory in which you installed ncat . macOS and Linux \u00b6 Install nmap from your preferred package manager (e.g., apt or brew ) or follow instructions provided at nmap.org . Part I - TCP Analysis Introduction \u00b6 Capture \u00b6 The instructions below can be used to manually perform an HTTP exchange with a server via the ncat tool. This process approximates the exchange that occurs between your web browser and a web server after you enter a URL into the address bar or click on a hyperlink. Why don't I see any output? At this point, we're interacting directly with a server in a text-based protocol. The server will wait silently for you to enter a valid message. Per RFC 2616, the request you are sending is multiple lines and is terminated by two new lines . If you wait too long or submit something that violates the specification, the server will respond with an error and close the connection. Capture Instructions \u00b6 Create a capture filter that will select traffic from TCP ports 80 or 443. Launch a new Wireshark capture on your primary network interface with the capture filter from Step 1. Launch a couple of new terminals (mac/linux) or Powershell consoles (windows) and follow these steps to make HTTP requests to neverssl.com and wikipedia.org (in separate consoles): NeverSSL a. Open a new connection: ncat neverssl.com 80 b. Start a new HTTP requests (terminated with a newline ) GET / HTTP/1.1 c. Add a Host header followed by two new lines Host: neverssl.com Wikipedia a. Open a new connection: ncat --ssl www.wikipedia.org 443 b. Start a new HTTP requests (terminated with a newline ) GET / HTTP/1.1 c. Add a Host header followed by two new lines Host: www.wikipedia.org Close your connections with CTRL-C End your Wireshark capture and save a copy of the capture to complete the remaining analysis. Save the ncat output to a notepad or file (for questions 3 & 4 on the lab report). Report \u00b6 What capture filter did you use to select TCP traffic on ports 80 and 443? Briefly describe the difference between a capture filter and a display filter. In what way do they serve different purposes? Paste in the first 10 lines of Wikipedia's server's response from the ncat output. Paste in the first 10 lines of NeverSSL's server's response from the ncat output. Part II - Plaintext (http) Analysis - NeverSSL \u00b6 Perform a search in Wireshark ( CMD-F or CTRL-F ) to find the string neverssl.com in packet details . Note You'll need to adjust the options for your search via dropdowns This search should lead you to the reassembled HTTP session. Review the summary of the reassembled TCP segments provided inside the Packet Details . For an alternate perspective, right click on any frame belonging to the connection and select Follow -> TCP Stream . Finally, right click on any frame in the connection and select Prepare Conversation Filter -> TCP Report \u00b6 Fill out the table in the lab report template for the first 10 frames of the NeverSSL connection in Wireshark by identifying each frame's: Frame # Source ( client or server ) Flags Sequence number Acknowledgement number Length of payload (additional data) (If you are confused about table syntax in Markdown, go here and scroll to to \"Tables\") Which information is used by the client to identify messages from the connection? Which information is used by the server to identify messages from the connection? Fill out the table in the lab report template for the last 5 frames of the NeverSSL connection in Wireshark Part III - Encrypted (https) Analysis - Wikipedia \u00b6 Perform a new search in Wireshark to find wikipedia.org . Be careful with this search since the search term appears in the page content from neverssl.com . Once you have identified the a frame from this TCP connection, prepare a new conversation filter so that you can take a closer look at the session. Hint We are looking for the term to appear in a Secure Sockets Layer option. We won't actually see the contents of our HTTPS session since the connection is encrypted by the time we enter it. Note It may be helpful to create a table or illustration that lists significant frames and their role in the session. Report \u00b6 Fill out the table in the lab report template for the first 10 frames of the Wikipedia connection in Wireshark Fill out the table in the lab report template for the last 5 frames of the Wikipedia connection in Wireshark What is the frame number of the first frame to contain a Server Sockets Layer header? Looking at the first frames of the SSL/TLS session, identify the messages sent in the TLS handshake (hint: look for Handshake Type in the packet details). Create a display filter to show the server side of the conversation only. Can you find any stream anomalies, e.g., duplicate data, out-of-order segments, or duplicate ACK numbers? (Hint: These are labeled in the Info field of the packet list) Part IV - General TCP Analysis \u00b6 Report \u00b6 What function does the opening handshake of TCP accomplish? Describe how you would identify stream anomalies by using sequence and acknowledgement numbers of TCP segments. Bonus (Optional) \u00b6 Report \u00b6 (5 points) Create a basic sequence diagram of the TCP segments sent in wikipedia.org session. Do not diagram all 100+ Do not diagram all 100+ frames of the wikipedia.org session, but you should include enough to illustrate the TLS handshake, the first few frames of encrypted data, and the closing of the TCP socket. You can draw this out on paper and submit a scan or use any other tool capable of building diagrams. Take a look at https://websequencediagrams.com . Your diagram should include annotations for the following details: Frame # (on each message) TCP Flags (on the setup/teardown handshake) TLS Handshake Protocol steps (if applicable) # of bytes transferred (messages carrying data) Hint: Be careful to exclude reassembled messages from your diagram (e.g., frames labeled HTTP that represent multiple TCP segments).","title":"Lab 4 - Analyze TCP with ncat and Wireshark"},{"location":"assignments/lab4/#lab-4-analyze-tcp-with-ncat-and-wireshark","text":"Lab 4 Assignment page on Canvas","title":"Lab 4 - Analyze TCP with ncat and Wireshark"},{"location":"assignments/lab4/#overview","text":"The purpose of this lab is for students to gain hands on experience with TCP connections. By the end of the lab you will be familiar with: ncat TCP handshakes http https Security faults of http We highly recommend using search engines to help you find solutions.","title":"Overview"},{"location":"assignments/lab4/#setup","text":"For this lab, we are going to use the incredibly versatile ncat utility to directly read and write data to and from HTTP(s) servers. Some of you may already be familiar with a similar tool known as netcat ( nc from the command line on most Linux or macOS machines). ncat is a re-implementation of netcat that adds some handy features (like SSL/TLS connections).","title":"Setup"},{"location":"assignments/lab4/#windows","text":"Please follow instructions to install ncat from https://nmap.org/ncat/ . You can accomplish this either by installing the nmap port scanner suite or by installing the portable executable . Note You may need to update your system path to include the directory in which you installed ncat .","title":"Windows"},{"location":"assignments/lab4/#macos-and-linux","text":"Install nmap from your preferred package manager (e.g., apt or brew ) or follow instructions provided at nmap.org .","title":"macOS and Linux"},{"location":"assignments/lab4/#part-i-tcp-analysis-introduction","text":"","title":"Part I - TCP Analysis Introduction"},{"location":"assignments/lab4/#capture","text":"The instructions below can be used to manually perform an HTTP exchange with a server via the ncat tool. This process approximates the exchange that occurs between your web browser and a web server after you enter a URL into the address bar or click on a hyperlink. Why don't I see any output? At this point, we're interacting directly with a server in a text-based protocol. The server will wait silently for you to enter a valid message. Per RFC 2616, the request you are sending is multiple lines and is terminated by two new lines . If you wait too long or submit something that violates the specification, the server will respond with an error and close the connection.","title":"Capture"},{"location":"assignments/lab4/#capture-instructions","text":"Create a capture filter that will select traffic from TCP ports 80 or 443. Launch a new Wireshark capture on your primary network interface with the capture filter from Step 1. Launch a couple of new terminals (mac/linux) or Powershell consoles (windows) and follow these steps to make HTTP requests to neverssl.com and wikipedia.org (in separate consoles): NeverSSL a. Open a new connection: ncat neverssl.com 80 b. Start a new HTTP requests (terminated with a newline ) GET / HTTP/1.1 c. Add a Host header followed by two new lines Host: neverssl.com Wikipedia a. Open a new connection: ncat --ssl www.wikipedia.org 443 b. Start a new HTTP requests (terminated with a newline ) GET / HTTP/1.1 c. Add a Host header followed by two new lines Host: www.wikipedia.org Close your connections with CTRL-C End your Wireshark capture and save a copy of the capture to complete the remaining analysis. Save the ncat output to a notepad or file (for questions 3 & 4 on the lab report).","title":"Capture Instructions"},{"location":"assignments/lab4/#report","text":"What capture filter did you use to select TCP traffic on ports 80 and 443? Briefly describe the difference between a capture filter and a display filter. In what way do they serve different purposes? Paste in the first 10 lines of Wikipedia's server's response from the ncat output. Paste in the first 10 lines of NeverSSL's server's response from the ncat output.","title":"Report"},{"location":"assignments/lab4/#part-ii-plaintext-http-analysis-neverssl","text":"Perform a search in Wireshark ( CMD-F or CTRL-F ) to find the string neverssl.com in packet details . Note You'll need to adjust the options for your search via dropdowns This search should lead you to the reassembled HTTP session. Review the summary of the reassembled TCP segments provided inside the Packet Details . For an alternate perspective, right click on any frame belonging to the connection and select Follow -> TCP Stream . Finally, right click on any frame in the connection and select Prepare Conversation Filter -> TCP","title":"Part II - Plaintext (http) Analysis - NeverSSL"},{"location":"assignments/lab4/#report_1","text":"Fill out the table in the lab report template for the first 10 frames of the NeverSSL connection in Wireshark by identifying each frame's: Frame # Source ( client or server ) Flags Sequence number Acknowledgement number Length of payload (additional data) (If you are confused about table syntax in Markdown, go here and scroll to to \"Tables\") Which information is used by the client to identify messages from the connection? Which information is used by the server to identify messages from the connection? Fill out the table in the lab report template for the last 5 frames of the NeverSSL connection in Wireshark","title":"Report"},{"location":"assignments/lab4/#part-iii-encrypted-https-analysis-wikipedia","text":"Perform a new search in Wireshark to find wikipedia.org . Be careful with this search since the search term appears in the page content from neverssl.com . Once you have identified the a frame from this TCP connection, prepare a new conversation filter so that you can take a closer look at the session. Hint We are looking for the term to appear in a Secure Sockets Layer option. We won't actually see the contents of our HTTPS session since the connection is encrypted by the time we enter it. Note It may be helpful to create a table or illustration that lists significant frames and their role in the session.","title":"Part III - Encrypted (https) Analysis - Wikipedia"},{"location":"assignments/lab4/#report_2","text":"Fill out the table in the lab report template for the first 10 frames of the Wikipedia connection in Wireshark Fill out the table in the lab report template for the last 5 frames of the Wikipedia connection in Wireshark What is the frame number of the first frame to contain a Server Sockets Layer header? Looking at the first frames of the SSL/TLS session, identify the messages sent in the TLS handshake (hint: look for Handshake Type in the packet details). Create a display filter to show the server side of the conversation only. Can you find any stream anomalies, e.g., duplicate data, out-of-order segments, or duplicate ACK numbers? (Hint: These are labeled in the Info field of the packet list)","title":"Report"},{"location":"assignments/lab4/#part-iv-general-tcp-analysis","text":"","title":"Part IV - General TCP Analysis"},{"location":"assignments/lab4/#report_3","text":"What function does the opening handshake of TCP accomplish? Describe how you would identify stream anomalies by using sequence and acknowledgement numbers of TCP segments.","title":"Report"},{"location":"assignments/lab4/#bonus-optional","text":"","title":"Bonus (Optional)"},{"location":"assignments/lab4/#report_4","text":"(5 points) Create a basic sequence diagram of the TCP segments sent in wikipedia.org session. Do not diagram all 100+ Do not diagram all 100+ frames of the wikipedia.org session, but you should include enough to illustrate the TLS handshake, the first few frames of encrypted data, and the closing of the TCP socket. You can draw this out on paper and submit a scan or use any other tool capable of building diagrams. Take a look at https://websequencediagrams.com . Your diagram should include annotations for the following details: Frame # (on each message) TCP Flags (on the setup/teardown handshake) TLS Handshake Protocol steps (if applicable) # of bytes transferred (messages carrying data) Hint: Be careful to exclude reassembled messages from your diagram (e.g., frames labeled HTTP that represent multiple TCP segments).","title":"Report"},{"location":"assignments/lab5/","text":"Lab 5 - Analyze DNS & HTTP in Wireshark \u00b6 Lab 5 Assignment page on Canvas Overview \u00b6 The purpose of this lab is for students to gain hands on experience with DNS. By the end of the lab you will be familiar with: dig (or PowerShell's Resolve-DnsName command) DNS queries security faults of DNS We highly recommend using search engines to help you find solutions. As usual, there will be multiple ways to complete this lab. Please use the template provided on Canvas under the Assignment \"Lab 3 - Analyze DNS & HTTP in Wireshark\" to complete your lab report. Part I - website \u00b6 Pick a popular website that has a lot of content on it. Ideally it should contain advertisements. You will be using it throughout this lab. Report : What website did you select? Part II - dig \u00b6 Before jumping into more complicated scenarios we would like you to learn how to use the dig command as it is an incredibly helpful and simple tool. We've provided some resources at Perform DNS Loookups Manually to help you get started. Use dig to lookup the domain name of the website you selected. Open up a new tab in your browser and enter (one of) the IP address(es) returned by dig to discover where it will take you. If dig returned more than one address, open up a second tab and enter it now. Note Don't panic if you receive an error instead of a live site. Some servers host more than one website and need the name to help route you to the right place. Try another site, e.g., uw.edu, and see if you get different results. Report : What addresses did the dig command return? Copy dig results to your report (code block or screenshot). What did you observe when you browsed to the IP addresses directly? Aside from A records containing IP addresses, did you discover any other DNS records from your query? List at least 3 other record types that DNS manages. Look closely at the output of the dig command. How can you be sure that the query completed successfully? Identify the IP address of the server used to handle your query. Part III - dev tools \u00b6 Open up a new tab preferably in a chromium based browser (Chrome, Brave, etc...). Open up the dev tools (right click on page and click Inspect), and go to the Network option. In that very same tab paste in your selected web page into the URL bar and click enter. You should see all of the GET and POST requests that the browser made for that webpage load up in the dev tools. Right-click the header of the Network Log table and select Domain. The domain of each resource is now shown. Take some time to scroll through the domains, files, and file types your website was requesting. Report : From a quick glance what is the most common file type requested? Approximately how many domains do you see in that list that don't matchup with the website domain you initially visited? Why do you think this page is getting information from other websites? If you had to guess, how many DNS requests do you think were sent in order to fully load this page? Part IV - wireshark \u00b6 Before examining DNS requests in Wireshark you will want to clear your DNS cache. Instructions on what that means, what it's for, and how to do so can be found here 314-docs/trouble/dns . Create a capture of you visiting your website by: Open Wireshark, begin a capture Quickly open a new tab and visit your website in your browser Once it has fully loaded end your Wireshark capture. Now filter for DNS packets only in the display filter. Identify the DNS response containing the information you needed in order to convert your website name into an IP address. Use the information contained within that packet for the following deliverable. Hint Learn how to use the search tool to find string content or research display filters that allow you to specify the domain name. Report : Assuming almost all of the DNS requests you see in Wireshark right now are for the one website you visited, how many DNS requests do you see? Overall were there less or more DNS queries than you'd expect? How did you identify the DNS packet(s) associated with the website you visited? Provide screenshots of the packet(s) (specifically of the DNS information in Packet Details). List the ip addresses you received for the website from the DNS server that resolved your request. Which transport layer protocol ( think OSI model ) is used to carry the DNS packet? Compare this DNS response to others in the capture (generate more if needed). Which port number(s) are shared in common across these DNS requests? Part V - security \u00b6 Open two packets in bytes view, a dns and a http packet that is encrypted with tls. Double click one of the DNS packets in order to be able to see the bytes view. Remove the dns display filter and replace it with tls (web traffic). Open one of the tls packets in byte view too. Report : Examine the bytes view of the two packets. Do you see any human readable values in the output? Looking at these two packets and others in your capture, does Wireshark provide any clues about whether or not your DNS is encrypted? Does it provide any clues on whether your web traffic is encrypted? Attacker: What information might an outside observer be able to glean about your computing activities by capturing your DNS traffic? Was any discernible information revealed (as far as you can tell) through your web traffic?","title":"Lab 5 - Analyze DNS & HTTP in Wireshark"},{"location":"assignments/lab5/#lab-5-analyze-dns-http-in-wireshark","text":"Lab 5 Assignment page on Canvas","title":"Lab 5 - Analyze DNS &amp; HTTP in Wireshark"},{"location":"assignments/lab5/#overview","text":"The purpose of this lab is for students to gain hands on experience with DNS. By the end of the lab you will be familiar with: dig (or PowerShell's Resolve-DnsName command) DNS queries security faults of DNS We highly recommend using search engines to help you find solutions. As usual, there will be multiple ways to complete this lab. Please use the template provided on Canvas under the Assignment \"Lab 3 - Analyze DNS & HTTP in Wireshark\" to complete your lab report.","title":"Overview"},{"location":"assignments/lab5/#part-i-website","text":"Pick a popular website that has a lot of content on it. Ideally it should contain advertisements. You will be using it throughout this lab. Report : What website did you select?","title":"Part I - website"},{"location":"assignments/lab5/#part-ii-dig","text":"Before jumping into more complicated scenarios we would like you to learn how to use the dig command as it is an incredibly helpful and simple tool. We've provided some resources at Perform DNS Loookups Manually to help you get started. Use dig to lookup the domain name of the website you selected. Open up a new tab in your browser and enter (one of) the IP address(es) returned by dig to discover where it will take you. If dig returned more than one address, open up a second tab and enter it now. Note Don't panic if you receive an error instead of a live site. Some servers host more than one website and need the name to help route you to the right place. Try another site, e.g., uw.edu, and see if you get different results. Report : What addresses did the dig command return? Copy dig results to your report (code block or screenshot). What did you observe when you browsed to the IP addresses directly? Aside from A records containing IP addresses, did you discover any other DNS records from your query? List at least 3 other record types that DNS manages. Look closely at the output of the dig command. How can you be sure that the query completed successfully? Identify the IP address of the server used to handle your query.","title":"Part II - dig"},{"location":"assignments/lab5/#part-iii-dev-tools","text":"Open up a new tab preferably in a chromium based browser (Chrome, Brave, etc...). Open up the dev tools (right click on page and click Inspect), and go to the Network option. In that very same tab paste in your selected web page into the URL bar and click enter. You should see all of the GET and POST requests that the browser made for that webpage load up in the dev tools. Right-click the header of the Network Log table and select Domain. The domain of each resource is now shown. Take some time to scroll through the domains, files, and file types your website was requesting. Report : From a quick glance what is the most common file type requested? Approximately how many domains do you see in that list that don't matchup with the website domain you initially visited? Why do you think this page is getting information from other websites? If you had to guess, how many DNS requests do you think were sent in order to fully load this page?","title":"Part III - dev tools"},{"location":"assignments/lab5/#part-iv-wireshark","text":"Before examining DNS requests in Wireshark you will want to clear your DNS cache. Instructions on what that means, what it's for, and how to do so can be found here 314-docs/trouble/dns . Create a capture of you visiting your website by: Open Wireshark, begin a capture Quickly open a new tab and visit your website in your browser Once it has fully loaded end your Wireshark capture. Now filter for DNS packets only in the display filter. Identify the DNS response containing the information you needed in order to convert your website name into an IP address. Use the information contained within that packet for the following deliverable. Hint Learn how to use the search tool to find string content or research display filters that allow you to specify the domain name. Report : Assuming almost all of the DNS requests you see in Wireshark right now are for the one website you visited, how many DNS requests do you see? Overall were there less or more DNS queries than you'd expect? How did you identify the DNS packet(s) associated with the website you visited? Provide screenshots of the packet(s) (specifically of the DNS information in Packet Details). List the ip addresses you received for the website from the DNS server that resolved your request. Which transport layer protocol ( think OSI model ) is used to carry the DNS packet? Compare this DNS response to others in the capture (generate more if needed). Which port number(s) are shared in common across these DNS requests?","title":"Part IV - wireshark"},{"location":"assignments/lab5/#part-v-security","text":"Open two packets in bytes view, a dns and a http packet that is encrypted with tls. Double click one of the DNS packets in order to be able to see the bytes view. Remove the dns display filter and replace it with tls (web traffic). Open one of the tls packets in byte view too. Report : Examine the bytes view of the two packets. Do you see any human readable values in the output? Looking at these two packets and others in your capture, does Wireshark provide any clues about whether or not your DNS is encrypted? Does it provide any clues on whether your web traffic is encrypted? Attacker: What information might an outside observer be able to glean about your computing activities by capturing your DNS traffic? Was any discernible information revealed (as far as you can tell) through your web traffic?","title":"Part V - security"},{"location":"assignments/lab6/","text":"Lab 6 - Socket Basics in Python \u00b6 Lab 6 Assignment page on Canvas Overview \u00b6 In the remaining weeks of the quarter, we will create a network service using the Python sockets API. In this lab, we will introduce the basic concepts of network programming with a Sockets API and build a pair of toy applications. Instructions \u00b6 Accept the Github Classroom assignment ( link ) and clone the base repository for the assignment. Review the first few sections of Real Python: Sockets Programming in Python (through Echo Client and Server ). Within a new branch called lab5-echo-server : Implement the basic echo client and echo server presented in the RealPython guide. Modify the echo client to allow you to include a custom message from the command line, e.g., echo-client \u201cyay python\u201d . (Hint: Use sys.argv ) 2 Encode 1 the message as UTF-8 text before sending (see linked resources). Test your code and ensure that the applications work as intended. Submit a working version of your code via pull request. Deliverables \u00b6 Open the lab report template (available in starter repository as lab5-report.md). In it, please answer the following questions: There are two major variants of Python (version 2 and 3). Briefly explain why it is important to know which version you have installed and are using to run your code. In your own words, explain the difference between server and client sockets. How are these differences seen in the sockets API? Complete the code and pull request as described above. Submit a link to your pull request via Canvas. https://www.pythoncentral.io/encoding-and-decoding-strings-in-python-3-x/ \u21a9 https://stackabuse.com/command-line-arguments-in-python/ \u21a9","title":"**Lab 6 - Socket Basics in Python**"},{"location":"assignments/lab6/#lab-6-socket-basics-in-python","text":"Lab 6 Assignment page on Canvas","title":"Lab 6 - Socket Basics in Python"},{"location":"assignments/lab6/#overview","text":"In the remaining weeks of the quarter, we will create a network service using the Python sockets API. In this lab, we will introduce the basic concepts of network programming with a Sockets API and build a pair of toy applications.","title":"Overview"},{"location":"assignments/lab6/#instructions","text":"Accept the Github Classroom assignment ( link ) and clone the base repository for the assignment. Review the first few sections of Real Python: Sockets Programming in Python (through Echo Client and Server ). Within a new branch called lab5-echo-server : Implement the basic echo client and echo server presented in the RealPython guide. Modify the echo client to allow you to include a custom message from the command line, e.g., echo-client \u201cyay python\u201d . (Hint: Use sys.argv ) 2 Encode 1 the message as UTF-8 text before sending (see linked resources). Test your code and ensure that the applications work as intended. Submit a working version of your code via pull request.","title":"Instructions"},{"location":"assignments/lab6/#deliverables","text":"Open the lab report template (available in starter repository as lab5-report.md). In it, please answer the following questions: There are two major variants of Python (version 2 and 3). Briefly explain why it is important to know which version you have installed and are using to run your code. In your own words, explain the difference between server and client sockets. How are these differences seen in the sockets API? Complete the code and pull request as described above. Submit a link to your pull request via Canvas. https://www.pythoncentral.io/encoding-and-decoding-strings-in-python-3-x/ \u21a9 https://stackabuse.com/command-line-arguments-in-python/ \u21a9","title":"Deliverables"},{"location":"assignments/lab7/","text":"Lab 7 - proxy part 1 \u00b6 Lab 7 Assignment page on Canvas Python concepts \u00b6 program structure find(), split(), strip() slicing lists / strings try / except dictionary control characters, e.g., \\r\\n Instructions \u00b6 Getting Started \u00b6 As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, add a new script named http-proxy.py based on resources/template.py . This file will be the main deliverable for your project. HTTP proxies incorporate server and client functionality into a single daemon. As a server, your proxy listens and process the requests it receives from browsers and other HTTP clients. As a client, your proxy will pass the clients' requests on to the intended destination and handle the responses in return. In this task, we will work exclusively on the server functionality of the proxy. Specifically, we'll build a server that processes the incoming TCP stream and parses out HTTP GET requests. In future assignments, we'll extend our code to handle other message types and implement the client functionality. Main Loop (Event Loop) \u00b6 Use a while loop to repeatedly accept() and process incoming requests. For each active connection, you will be making calls to Socket.recv() in order to fetch the next chunk of data from the TCP stream and process it. What it means to work with streams Remember that TCP is a stream-oriented protocol and that the Sockets API is built around the metaphor of the stream of bytes. Each attempt to read data from a socket pulls data from the stream in small chunks, e.g., Socket.recv(1024) returns up to 1024 bytes of data from the stream. Don't assume that recv() will return a complete HTTP message in one call. The Sockets API does not even guarantee that it will return the full number of bytes you requested. In order to know where messages begin and end, we have to inspect the incoming bytes based on HTTP message syntax. Since it is up to you to identify and reconstruct messages out of the stream, you should create a buffer that will hold your data while you work to identify complete HTTP messages. A buffer in this case is nothing more than a python bytes object that you append to each time a recv() returns successfully, for example: # Declare an empty buffer buffer = b '' # Receive new data and add it to the buffer data = conn . recv ( 1024 ) buffer = buffer + data Getting to HTTP Messages \u00b6 In order to recognize HTTP messages, you need to parse the bytes you've received and determine whether you have a complete message. Your task is to build a simple HTTP parser that accepts a byte buffer and attempts to parse an HTTP GET request (ignore other request types for now). We recommend that your parser returns the parsed message as a dictionary (see below) along with the bytes that were still left over in the buffer. As noted, the data coming from the socket will be in bytestring format, meaning it will appear as b'data' and not 'data' as with a normal string. You cannot use string methods such as split() on a btyestring. Therefore you will need to decode the btyestring with the str() or decode() method to turn it into a string. HTTP messages may be formatted as ASCII (per RFC 7230) or ISO-8859-1 (per historic RFCs). Decoding text as iso-8859-1 will allow for the maximum versatility. Based on this description, we can create a python function that resembles the following: def parse_message ( data ) # initialize an empty dictionary message = {} # parse bytes and assign key / value pairs such as ... message [ 'method' ] = # HTTP method name such as GET message [ 'uri' ] = # address or resource name from the request, such as www.uw.edu message [ 'version' ] = # HTTP version such as HTTP/1.0 message [ 'headers' ] = [] # List of headers # If parsing is successful, return a completed message (if applicable) and unused bytes return message , unparsed_data # If parsing fails, return the entire buffer and an indicator that parsing was incomplete return None , data Parsing \u00b6 HTTP messages follow a relatively simple syntax that can be used to make decisions about how to break the message into smaller parts (using tools like Python slicing and the functions find() , strip() , and split() ). For GET requests, the message structure is based entirely around lines and the Carriage Return / New Line line separators (think back to previous labs in which we sent GET requests using netcat). It's tempting for many students to read this and start parsing with a data.split('\\r\\n') . This strategy rarely works. Instead, we recommend that you create a dedicated function to split a single line off the buffer. You can do this with find() , strip() , and slices . Before you go any further, make sure you have a basic understanding of HTTP/1.0 message structure. See HTTP syntax overview or RFC 1945 . Output \u00b6 After successfully parsing a request, you should print the following summary and close the connection (return to the start of your loop to listen for new requests). Request summary Connection Source: \\<IP address returned from the call to Socket.accept()> HTTP Method: \\<Name of method, e.g., GET, OPTION, or POST> Destination: \\<URI extracted from the request> Headers: \\<Comma delimited list of header names> Testing your code with test.py \u00b6 The resources directory of the project repository contains a simple python script called test.py that you can use to send HTTP requests from a file into your proxy code. # Send the request from sample-request.txt # one line at a time with a short delay between python3 test.py 9999 sample-request.txt # Send the request from sample-request.txt 250 bytes at a time # with a short delay between python3 test.py 9999 sample-request.txt 250 Capturing proxied requests for testing \u00b6 Use the following method to capture valid requests that you can use for testing: Open ncat to listen for incoming connections, e.g., ncat -o <FILENAME> -l <PORT> Configure Firefox with an HTTP proxy on 127.0.0.1 <PORT> Enter the URL of an HTTP-only site into the FF address bar (the request will hang) Manually stop the request from the browser Verify that the request was captured in ncat (ncat will close automatically)","title":"Lab 7 - proxy part 1"},{"location":"assignments/lab7/#lab-7-proxy-part-1","text":"Lab 7 Assignment page on Canvas","title":"Lab 7 - proxy part 1"},{"location":"assignments/lab7/#python-concepts","text":"program structure find(), split(), strip() slicing lists / strings try / except dictionary control characters, e.g., \\r\\n","title":"Python concepts"},{"location":"assignments/lab7/#instructions","text":"","title":"Instructions"},{"location":"assignments/lab7/#getting-started","text":"As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, add a new script named http-proxy.py based on resources/template.py . This file will be the main deliverable for your project. HTTP proxies incorporate server and client functionality into a single daemon. As a server, your proxy listens and process the requests it receives from browsers and other HTTP clients. As a client, your proxy will pass the clients' requests on to the intended destination and handle the responses in return. In this task, we will work exclusively on the server functionality of the proxy. Specifically, we'll build a server that processes the incoming TCP stream and parses out HTTP GET requests. In future assignments, we'll extend our code to handle other message types and implement the client functionality.","title":"Getting Started"},{"location":"assignments/lab7/#main-loop-event-loop","text":"Use a while loop to repeatedly accept() and process incoming requests. For each active connection, you will be making calls to Socket.recv() in order to fetch the next chunk of data from the TCP stream and process it. What it means to work with streams Remember that TCP is a stream-oriented protocol and that the Sockets API is built around the metaphor of the stream of bytes. Each attempt to read data from a socket pulls data from the stream in small chunks, e.g., Socket.recv(1024) returns up to 1024 bytes of data from the stream. Don't assume that recv() will return a complete HTTP message in one call. The Sockets API does not even guarantee that it will return the full number of bytes you requested. In order to know where messages begin and end, we have to inspect the incoming bytes based on HTTP message syntax. Since it is up to you to identify and reconstruct messages out of the stream, you should create a buffer that will hold your data while you work to identify complete HTTP messages. A buffer in this case is nothing more than a python bytes object that you append to each time a recv() returns successfully, for example: # Declare an empty buffer buffer = b '' # Receive new data and add it to the buffer data = conn . recv ( 1024 ) buffer = buffer + data","title":"Main Loop (Event Loop)"},{"location":"assignments/lab7/#getting-to-http-messages","text":"In order to recognize HTTP messages, you need to parse the bytes you've received and determine whether you have a complete message. Your task is to build a simple HTTP parser that accepts a byte buffer and attempts to parse an HTTP GET request (ignore other request types for now). We recommend that your parser returns the parsed message as a dictionary (see below) along with the bytes that were still left over in the buffer. As noted, the data coming from the socket will be in bytestring format, meaning it will appear as b'data' and not 'data' as with a normal string. You cannot use string methods such as split() on a btyestring. Therefore you will need to decode the btyestring with the str() or decode() method to turn it into a string. HTTP messages may be formatted as ASCII (per RFC 7230) or ISO-8859-1 (per historic RFCs). Decoding text as iso-8859-1 will allow for the maximum versatility. Based on this description, we can create a python function that resembles the following: def parse_message ( data ) # initialize an empty dictionary message = {} # parse bytes and assign key / value pairs such as ... message [ 'method' ] = # HTTP method name such as GET message [ 'uri' ] = # address or resource name from the request, such as www.uw.edu message [ 'version' ] = # HTTP version such as HTTP/1.0 message [ 'headers' ] = [] # List of headers # If parsing is successful, return a completed message (if applicable) and unused bytes return message , unparsed_data # If parsing fails, return the entire buffer and an indicator that parsing was incomplete return None , data","title":"Getting to HTTP Messages"},{"location":"assignments/lab7/#parsing","text":"HTTP messages follow a relatively simple syntax that can be used to make decisions about how to break the message into smaller parts (using tools like Python slicing and the functions find() , strip() , and split() ). For GET requests, the message structure is based entirely around lines and the Carriage Return / New Line line separators (think back to previous labs in which we sent GET requests using netcat). It's tempting for many students to read this and start parsing with a data.split('\\r\\n') . This strategy rarely works. Instead, we recommend that you create a dedicated function to split a single line off the buffer. You can do this with find() , strip() , and slices . Before you go any further, make sure you have a basic understanding of HTTP/1.0 message structure. See HTTP syntax overview or RFC 1945 .","title":"Parsing"},{"location":"assignments/lab7/#output","text":"After successfully parsing a request, you should print the following summary and close the connection (return to the start of your loop to listen for new requests). Request summary Connection Source: \\<IP address returned from the call to Socket.accept()> HTTP Method: \\<Name of method, e.g., GET, OPTION, or POST> Destination: \\<URI extracted from the request> Headers: \\<Comma delimited list of header names>","title":"Output"},{"location":"assignments/lab7/#testing-your-code-with-testpy","text":"The resources directory of the project repository contains a simple python script called test.py that you can use to send HTTP requests from a file into your proxy code. # Send the request from sample-request.txt # one line at a time with a short delay between python3 test.py 9999 sample-request.txt # Send the request from sample-request.txt 250 bytes at a time # with a short delay between python3 test.py 9999 sample-request.txt 250","title":"Testing your code with test.py"},{"location":"assignments/lab7/#capturing-proxied-requests-for-testing","text":"Use the following method to capture valid requests that you can use for testing: Open ncat to listen for incoming connections, e.g., ncat -o <FILENAME> -l <PORT> Configure Firefox with an HTTP proxy on 127.0.0.1 <PORT> Enter the URL of an HTTP-only site into the FF address bar (the request will hang) Manually stop the request from the browser Verify that the request was captured in ncat (ncat will close automatically)","title":"Capturing proxied requests for testing"},{"location":"assignments/lab8/","text":"Lab 8 - proxy part II \u00b6 Lab 8 Assignment page on Canvas Python concepts \u00b6 Slicing lists / strings Converting strings to/from numbers Creating and using enumerations Format strings, e.g., \"{}: {}\\r\\n\".format(header_name, header_value) Instructions \u00b6 Getting Started \u00b6 As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, open up the http-proxy.py script you created in Lab 6 and continue working from the same file. In the previous lab, we started to build the server component of your proxy. This component is designed to receive incoming requests from web clients and then eventually forward responses that were received from an upstream web server. The core of the server is established on a request parser, which we also started to develop in the last assignment. In this lab, we'll extend the parser to handle additional HTTP request types and also HTTP responses. Likewise, we'll start to build out the client component of the proxy by writing a new function that rebuilds an HTTP request from a previously parsed message. Parsing Requests (cont.) \u00b6 Extend your parsing function to handle more complex HTTP requests, such as the POST or PUT type. While GET requests are terminated by an empty CRLF line after the headers, other request types append an additional message body. From a parsing perspective, a POST or PUT request proceeds exactly like the GET request up until reading the final CRLF that follows the header section. In order to read the remainder of the message, we need to first find out the length of the body component. In HTTP 1.0, the body length is defined by an HTTP header called Content-Length . 1 The value of Content-Length will be a numeric string that defines the length of the body payload. If the header exists and its integer value is non-zero, you should attempt to read Content-Length bytes from the buffer and save as an additional field in your parsed message. If you succeed in parsing a complete message, you should remove the data from the buffer and return a dictionary containing the parts of your message back to the main event loop. If parsing fails, you should leave the data in the buffer and return to your connection handling loop to wait for the rest of the message. Parsing Responses \u00b6 Structurally, there is almost no difference between an HTTP request with a message body and an HTTP response. In fact, the only difference from your parser's perspective is the order of fields in the first line of the message. 2 Extend your parser to handle both types of messages based on an additional message_type argument to your parser function. Modify the behavior of the function to parse the first line properly based on this argument, include the message_type in the parsed message. A standard way to represent a value representing a message type is using an enumeration, e.g.: # Required imports from enum import Enum , auto # Enumeration to represent message types class MessageType ( Enum ): REQUEST = auto () RESPONSE = auto () # Use the is operator rather than == to test an enumeration \u2026 # if message[\u2018type\u2019] is MessageType.REQUEST: Build Message \u00b6 Before you wrap up this lab, let's create one more component of the parser, a new function that takes a dictionary like the one generated by your parser and builds a new message (returning the message as a byte string). 3 The message you build should be modified in the following manner: Replace the HTTP version you received with HTTP/1.0 Add or update a Via header (per RFC 7230) for the proxied connection, e.g., Via: 1.0 127.0.0.1:9999 If a Via already exists, append your entry as a comma separated value to the end of the existing header Tips \u00b6 Use python format strings to recreate the line-delimited parts of the message, ensuring you terminate each line in \\r\\n and encode as iso-8859-1 Output \u00b6 Once all parts of your code are working, print the following summary and close the connection. This will return to the start of your loop to listen for new connections). Request summary Connection Source: < IP address returned from the call to Socket.accept() > HTTP Method: < Name of method, e.g., GET, OPTION, or POST > Destination: < URI extracted from the request > Headers: < Comma delimited list of header names > Ready to forward Request Target: < URI of server obtained from request > Message: < Raw bytes of the rebuilt request > What are these diamonds \"< >\" ? These are placeholders. When you see these it means you should fill in information that is between them and then delete the symbols. It's a quick way of saying \"hey something needs to be filled in\" for the developer world. Testing your code with test.py \u00b6 The resources directory of the project repository contains a simple python script called test.py that you can use to send HTTP requests from a file into your proxy code. # Send the request from sample-request.txt on port 9999 one line at a time with a short delay between python3 test . py 9999 sample - request . txt # Send the request from sample-request.txt on port 9999 250 bytes at a time with a short delay between python3 test . py 9999 sample - request . txt 250 Capturing proxied requests for testing \u00b6 Use the following method to capture valid requests that you can use for testing: Open ncat to listen for incoming connections, e.g., ncat -o <FILENAME> -l <PORT> Configure Firefox with an HTTP proxy on 127.0.0.1 <PORT> Enter the URL of an HTTP-only site into the FF address bar (the request will hang) Manually stop the request from the browser Verify that the request was captured in ncat (ncat will close automatically) This is an oversimplification of the RFC for HTTP/1.0, but it will be sufficient for our purposes. \u21a9 More information available at HTTP syntax overview \u21a9 I realize it seems strange to rebuild the message you just spent time tearing apart, but this approach gives you more leverage in terms of what functions your proxy can provide. For example, notice how easily we can modify the HTTP version and add new headers. \u21a9","title":"Lab 8 - proxy part II"},{"location":"assignments/lab8/#lab-8-proxy-part-ii","text":"Lab 8 Assignment page on Canvas","title":"Lab 8 - proxy part II"},{"location":"assignments/lab8/#python-concepts","text":"Slicing lists / strings Converting strings to/from numbers Creating and using enumerations Format strings, e.g., \"{}: {}\\r\\n\".format(header_name, header_value)","title":"Python concepts"},{"location":"assignments/lab8/#instructions","text":"","title":"Instructions"},{"location":"assignments/lab8/#getting-started","text":"As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, open up the http-proxy.py script you created in Lab 6 and continue working from the same file. In the previous lab, we started to build the server component of your proxy. This component is designed to receive incoming requests from web clients and then eventually forward responses that were received from an upstream web server. The core of the server is established on a request parser, which we also started to develop in the last assignment. In this lab, we'll extend the parser to handle additional HTTP request types and also HTTP responses. Likewise, we'll start to build out the client component of the proxy by writing a new function that rebuilds an HTTP request from a previously parsed message.","title":"Getting Started"},{"location":"assignments/lab8/#parsing-requests-cont","text":"Extend your parsing function to handle more complex HTTP requests, such as the POST or PUT type. While GET requests are terminated by an empty CRLF line after the headers, other request types append an additional message body. From a parsing perspective, a POST or PUT request proceeds exactly like the GET request up until reading the final CRLF that follows the header section. In order to read the remainder of the message, we need to first find out the length of the body component. In HTTP 1.0, the body length is defined by an HTTP header called Content-Length . 1 The value of Content-Length will be a numeric string that defines the length of the body payload. If the header exists and its integer value is non-zero, you should attempt to read Content-Length bytes from the buffer and save as an additional field in your parsed message. If you succeed in parsing a complete message, you should remove the data from the buffer and return a dictionary containing the parts of your message back to the main event loop. If parsing fails, you should leave the data in the buffer and return to your connection handling loop to wait for the rest of the message.","title":"Parsing Requests (cont.)"},{"location":"assignments/lab8/#parsing-responses","text":"Structurally, there is almost no difference between an HTTP request with a message body and an HTTP response. In fact, the only difference from your parser's perspective is the order of fields in the first line of the message. 2 Extend your parser to handle both types of messages based on an additional message_type argument to your parser function. Modify the behavior of the function to parse the first line properly based on this argument, include the message_type in the parsed message. A standard way to represent a value representing a message type is using an enumeration, e.g.: # Required imports from enum import Enum , auto # Enumeration to represent message types class MessageType ( Enum ): REQUEST = auto () RESPONSE = auto () # Use the is operator rather than == to test an enumeration \u2026 # if message[\u2018type\u2019] is MessageType.REQUEST:","title":"Parsing Responses"},{"location":"assignments/lab8/#build-message","text":"Before you wrap up this lab, let's create one more component of the parser, a new function that takes a dictionary like the one generated by your parser and builds a new message (returning the message as a byte string). 3 The message you build should be modified in the following manner: Replace the HTTP version you received with HTTP/1.0 Add or update a Via header (per RFC 7230) for the proxied connection, e.g., Via: 1.0 127.0.0.1:9999 If a Via already exists, append your entry as a comma separated value to the end of the existing header","title":"Build Message"},{"location":"assignments/lab8/#tips","text":"Use python format strings to recreate the line-delimited parts of the message, ensuring you terminate each line in \\r\\n and encode as iso-8859-1","title":"Tips"},{"location":"assignments/lab8/#output","text":"Once all parts of your code are working, print the following summary and close the connection. This will return to the start of your loop to listen for new connections). Request summary Connection Source: < IP address returned from the call to Socket.accept() > HTTP Method: < Name of method, e.g., GET, OPTION, or POST > Destination: < URI extracted from the request > Headers: < Comma delimited list of header names > Ready to forward Request Target: < URI of server obtained from request > Message: < Raw bytes of the rebuilt request > What are these diamonds \"< >\" ? These are placeholders. When you see these it means you should fill in information that is between them and then delete the symbols. It's a quick way of saying \"hey something needs to be filled in\" for the developer world.","title":"Output"},{"location":"assignments/lab8/#testing-your-code-with-testpy","text":"The resources directory of the project repository contains a simple python script called test.py that you can use to send HTTP requests from a file into your proxy code. # Send the request from sample-request.txt on port 9999 one line at a time with a short delay between python3 test . py 9999 sample - request . txt # Send the request from sample-request.txt on port 9999 250 bytes at a time with a short delay between python3 test . py 9999 sample - request . txt 250","title":"Testing your code with test.py"},{"location":"assignments/lab8/#capturing-proxied-requests-for-testing","text":"Use the following method to capture valid requests that you can use for testing: Open ncat to listen for incoming connections, e.g., ncat -o <FILENAME> -l <PORT> Configure Firefox with an HTTP proxy on 127.0.0.1 <PORT> Enter the URL of an HTTP-only site into the FF address bar (the request will hang) Manually stop the request from the browser Verify that the request was captured in ncat (ncat will close automatically) This is an oversimplification of the RFC for HTTP/1.0, but it will be sufficient for our purposes. \u21a9 More information available at HTTP syntax overview \u21a9 I realize it seems strange to rebuild the message you just spent time tearing apart, but this approach gives you more leverage in terms of what functions your proxy can provide. For example, notice how easily we can modify the HTTP version and add new headers. \u21a9","title":"Capturing proxied requests for testing"},{"location":"assignments/lab9/","text":"Lab 9 - proxy part III \u00b6 Lab 9 Assignment page on Canvas In this lab, we'll wire together the remaining components of a proxy based on the functionality we have built to parse / reconstruct messages. Instructions \u00b6 Getting Started \u00b6 As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, open up the http-proxy.py script you have been working on in Lab 6 - 7. You will continue working with the same file for Lab 8. In the last lab, we completed the parsing functionality needed by our proxy and added a function to reconstruct the HTTP message with a few changes &emdash; such as downgrading the connection to HTTP/1.0 . HTTP Version Please confirm that you have followed the instructions in previous labs to downgrade the HTTP version to HTTP/1.0. Newer versions of HTTP have more complicated connection management, where as HTTP/1.0 connections are used for just one request/response. In this lab, we'll return our focus to the sockets in the main event loop in order to establish the remaining connections needed to proxy requests to the intended destinations and return responses to the client. Server Port \u00b6 To streamline grading for this final task, please modify your current script to accept a port from the command-line, e.g., python3 http-proxy.py 9999 . This argument should override any constant value that you've been using until now for the server's port. Connection Flow \u00b6 The overall connection flow is described below. Additional helper code is provided later in this section: Upon receipt of a valid request, parse the URI (code provided) to determine the host and port for the destination server that's been requested by the client. Within your event handling code, create a new TCP connection to the new host and port. _This is a client connection and will be established in the same manner as the connection in your echo client of Lab 5. Reconstruct the request using the build_message function from the previous lab and send it out over your new server-facing socket. Set up a new loop to listen on this socket until you have receivedthe HTTP response coming back from the web server (You'll need to keep trying until you can parse the complete request) . Reconstruct the response and send it back to the client over the client-facing connection. Close the connection to the client and resume waiting for new connections. Parsing the URI \u00b6 In order to create a socket to a destination based on a URI, we need to parse out several components and determine the hostname/address and port that the client to the proxy had originally requested. The image below provides a good example demonstrating the different between a URL and URI. Since Python provides a URL parsing module, this is typically an easy task. In practice, however, there are quite a few edge cases. In order to constrain the difficulty of this lab, we are providing you with the following function to parse out the host and port. # Be sure to add the import to the top of your code from urllib.parse import urlparse # returns the host and port # run by doing: h, p = parse_uri(dest) def parse_uri ( uri ): uri = urlparse ( uri ) scheme = uri . scheme host = uri . hostname # urlparse can't deal with partial URI's that don't include the # protocol, e.g., push.services.mozilla.com:443 if host : # correctly parsed if uri . port : port = uri . port else : port = socket . getservbyname ( scheme ) else : # incorrectly parsed uri = uri . path . split ( ':' ) host = uri [ 0 ] if len ( uri ) > 1 : port = int ( uri [ 1 ]) else : port = 80 return host , port Testing \u00b6 While building the remaining functionality, the simplest mode of testing is to leverage the test.py script provided in your start repository (see instructions in Lab 7 and 8 for more details). When you reach the point that your code returns a successful HTTP response to the test script, you should move on to testing with the browser. Since it provides standalone proxy configuration, Firefox is the easiest browser to use for testing. Other common browsers rely on OS level configuration for proxies and tend to cause more issues for students. Open Firefox's general preferences/settings page Scroll to the bottom of the page and select Network Settings -> Settings Under Configure Proxy Access to the Internet , select Manual proxy configuration Set the HTTP Proxy to 127.0.0.1 with Port 9999 (match the port you used to run your proxy) Apply your settings and open a new tab to navigate to an HTTP-based site, e.g., http://www.washington.edu/ http://neverssl.com http://mit.edu Output \u00b6 Upon completing this task successfully, your code should proxy a request to a server and return the response back to the client over the existing network connection. If you've done this successfully, the pages should load successfully in your browser when you view a site via unencrypted HTTP. You should also print out a visual log of incoming connections, combining elements of the request and response as explained here. The format we will use for this log is consistent with the HTTP access logs seen in popular web servers like nginx and Apache. Log Entry Format \u00b6 Each line of the log contains the following entries separated by spaces: Remote host (client IP address) Timestamp of when your proxy received the HTTP request wrapped in square brackets how to get time stamp in Python import datetime now = datetime . datetime . now () now . strftime ( ' %d /%b/%Y:%H:%M:%S' ) The actual request-line received from the client wrapped in double quotes The HTTP status code returned by the target server in its response Content-Length of the HTTP response, i.e., the number of bytes in the payload zero if the payload is not present Referer header, or a dash if not used wrapped in double quotes replace with a single dash if Referer is not present User-Agent header (contains information about the client's browser/OS/etc) wrapped in double quotes replace with a single dash if the User-Agent is not present Examples 127.0.0.1 [10/Oct/2000:13:55:36 -0700] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 \"http://www.example.com/start.html\" \"Mozilla/4.08 [en] (Win98; I ;Nav)\" More information about the Apache access log is available at scalyr detailed apache access log .","title":"Lab 9 - proxy part III"},{"location":"assignments/lab9/#lab-9-proxy-part-iii","text":"Lab 9 Assignment page on Canvas In this lab, we'll wire together the remaining components of a proxy based on the functionality we have built to parse / reconstruct messages.","title":"Lab 9 - proxy part III"},{"location":"assignments/lab9/#instructions","text":"","title":"Instructions"},{"location":"assignments/lab9/#getting-started","text":"As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, open up the http-proxy.py script you have been working on in Lab 6 - 7. You will continue working with the same file for Lab 8. In the last lab, we completed the parsing functionality needed by our proxy and added a function to reconstruct the HTTP message with a few changes &emdash; such as downgrading the connection to HTTP/1.0 . HTTP Version Please confirm that you have followed the instructions in previous labs to downgrade the HTTP version to HTTP/1.0. Newer versions of HTTP have more complicated connection management, where as HTTP/1.0 connections are used for just one request/response. In this lab, we'll return our focus to the sockets in the main event loop in order to establish the remaining connections needed to proxy requests to the intended destinations and return responses to the client.","title":"Getting Started"},{"location":"assignments/lab9/#server-port","text":"To streamline grading for this final task, please modify your current script to accept a port from the command-line, e.g., python3 http-proxy.py 9999 . This argument should override any constant value that you've been using until now for the server's port.","title":"Server Port"},{"location":"assignments/lab9/#connection-flow","text":"The overall connection flow is described below. Additional helper code is provided later in this section: Upon receipt of a valid request, parse the URI (code provided) to determine the host and port for the destination server that's been requested by the client. Within your event handling code, create a new TCP connection to the new host and port. _This is a client connection and will be established in the same manner as the connection in your echo client of Lab 5. Reconstruct the request using the build_message function from the previous lab and send it out over your new server-facing socket. Set up a new loop to listen on this socket until you have receivedthe HTTP response coming back from the web server (You'll need to keep trying until you can parse the complete request) . Reconstruct the response and send it back to the client over the client-facing connection. Close the connection to the client and resume waiting for new connections.","title":"Connection Flow"},{"location":"assignments/lab9/#parsing-the-uri","text":"In order to create a socket to a destination based on a URI, we need to parse out several components and determine the hostname/address and port that the client to the proxy had originally requested. The image below provides a good example demonstrating the different between a URL and URI. Since Python provides a URL parsing module, this is typically an easy task. In practice, however, there are quite a few edge cases. In order to constrain the difficulty of this lab, we are providing you with the following function to parse out the host and port. # Be sure to add the import to the top of your code from urllib.parse import urlparse # returns the host and port # run by doing: h, p = parse_uri(dest) def parse_uri ( uri ): uri = urlparse ( uri ) scheme = uri . scheme host = uri . hostname # urlparse can't deal with partial URI's that don't include the # protocol, e.g., push.services.mozilla.com:443 if host : # correctly parsed if uri . port : port = uri . port else : port = socket . getservbyname ( scheme ) else : # incorrectly parsed uri = uri . path . split ( ':' ) host = uri [ 0 ] if len ( uri ) > 1 : port = int ( uri [ 1 ]) else : port = 80 return host , port","title":"Parsing the URI"},{"location":"assignments/lab9/#testing","text":"While building the remaining functionality, the simplest mode of testing is to leverage the test.py script provided in your start repository (see instructions in Lab 7 and 8 for more details). When you reach the point that your code returns a successful HTTP response to the test script, you should move on to testing with the browser. Since it provides standalone proxy configuration, Firefox is the easiest browser to use for testing. Other common browsers rely on OS level configuration for proxies and tend to cause more issues for students. Open Firefox's general preferences/settings page Scroll to the bottom of the page and select Network Settings -> Settings Under Configure Proxy Access to the Internet , select Manual proxy configuration Set the HTTP Proxy to 127.0.0.1 with Port 9999 (match the port you used to run your proxy) Apply your settings and open a new tab to navigate to an HTTP-based site, e.g., http://www.washington.edu/ http://neverssl.com http://mit.edu","title":"Testing"},{"location":"assignments/lab9/#output","text":"Upon completing this task successfully, your code should proxy a request to a server and return the response back to the client over the existing network connection. If you've done this successfully, the pages should load successfully in your browser when you view a site via unencrypted HTTP. You should also print out a visual log of incoming connections, combining elements of the request and response as explained here. The format we will use for this log is consistent with the HTTP access logs seen in popular web servers like nginx and Apache.","title":"Output"},{"location":"assignments/lab9/#log-entry-format","text":"Each line of the log contains the following entries separated by spaces: Remote host (client IP address) Timestamp of when your proxy received the HTTP request wrapped in square brackets how to get time stamp in Python import datetime now = datetime . datetime . now () now . strftime ( ' %d /%b/%Y:%H:%M:%S' ) The actual request-line received from the client wrapped in double quotes The HTTP status code returned by the target server in its response Content-Length of the HTTP response, i.e., the number of bytes in the payload zero if the payload is not present Referer header, or a dash if not used wrapped in double quotes replace with a single dash if Referer is not present User-Agent header (contains information about the client's browser/OS/etc) wrapped in double quotes replace with a single dash if the User-Agent is not present Examples 127.0.0.1 [10/Oct/2000:13:55:36 -0700] \"GET /apache_pb.gif HTTP/1.0\" 200 2326 \"http://www.example.com/start.html\" \"Mozilla/4.08 [en] (Win98; I ;Nav)\" More information about the Apache access log is available at scalyr detailed apache access log .","title":"Log Entry Format"},{"location":"assignments/networkd-setup/","text":"Networkd Setup for Raspbian (2020-01-22) \u00b6 Intro to Systemd \u00b6 An init provider is the first process that is launched on a Linux system. It is responsible for loading other essential services, and it ultimately becomes the parent of every other process on the system. Among the differences between different Linux distributions is the choice of init system. systemd is the initialization (init) provider most often deployed on recent Linux distributions. On Raspbian and other recent Debian-based distros systemd replaces the aging sysvinit . We will interact directly with systemd in this tutorial by issuing systemctl commands to start, stop, enable and disable various system-level services. Beyond its job of launching essential services, systemd provides a modular interface to control many parts of the system. We've already interacted with a few of these components when we used localectl , timedatectl , and hostnamectl during the initial setup of the RaspberryPi. In this tutorial we will leverage three more systemd subsystems: journald - Collects and catalogs log files from system services and applications. You can explore these files with journalctl as seen in Troubleshooting . networkd - Detects and configures network devices and performs various other network management functions. resolved - Provides network name resolution and maintains a list of DNS servers (network-based resolvers) to contact based on settings provided by DHCP or networkd configuration files. Danger: Risk of bricking your Pi A typo or other mistake within the core network configuration can result in total loss of network connectivity. If this happens, you will not be able to manage your Pi over SSH. Your only option will be to configure the Pi again from scratch or to troubleshoot using an external HDMI monitor and USB keyboard. We will not grant extensions for this type of incident. Before you begin to follow these instructions, make an external copy of critical configs such as wpa_supplicant using scp . We provide additional tips for rebuilding at the end of this guide. Systemd vs Default Networking \u00b6 By default, Raspbian networking relies on a component called dhcpcd to manage interface settings, addresses, etc. While this component works well for general purpose computing, but it is not a match for every scenario. The current version of Debian (the base OS for Raspbian) supports systemd based network management via the systemd-networkd service. Unlike dhcpcd , networkd is well-suited to managing the base configuration for our router. Enabling Networkd \u00b6 We will enable networkd in several steps. Try to complete this process in one sitting to avoid \"bricking\" your Pi (at least making it inaccessible over the network). Retain journald logs \u00b6 systemd-networkd stores its logs in systemd-journald . We want journald to keep these logs between boots, which we enable by creating the persistent log path. # Create the location for persistent log messages sudo mkdir -p /var/log/journal sudo systemd-tmpfiles --create --prefix /var/log/journal Configure network interfaces \u00b6 To configure the network with networkd , we create files in /etc/systemd/network/ that match named network interfaces and define our desired settings settings. Create the following .network files to handle the default settings for wired and wireless interfaces. Enabling link local addresses is a critical component of these default configurations so that you can still communicate with the Pi when DHCP is not available. Warning Networkd configuration is generally easy to work with, but there are a couple of footguns to be aware of: The files are case sensitive and sometimes sensitive to seemingly innocuous changes in spacing. A file with a missing or invalid [Match] statement will be applied to every interface that hasn't already been matched by an earlier configuration. FAQ: Networkd configuration files man systemd.network provides a comprehensive reference to the format of the networkd configuration files and the process for loading them. At runtime, networkd gathers files using the .network extension from several locations, including /etc/systemd/network/ . To determine the order in which to apply configuration, networkd sorts all of these files lexically. To maintain proper control over execution order, we can prepend a two digit numeric value to the filename. This allows us to set up high-numbered default configurations that are overriden on a case-by-case basis by low-numberd configs files. Default ethernet configuration \u00b6 /etc/systemd/network/99-eth.network [Match] # Applies to eth0, eth1, ... Name=eth* [Network] # Configure IPv4 using DHCP DHCP=ipv4 # Enable link local addresses for IPv4 (169.254.x.y) and IPv6 (FE80::) LinkLocalAddressing=yes Default wireless configuration \u00b6 /etc/systemd/network/99-wlan.network [Match] Name=wlan* [Network] DHCP=ipv4 Disable default networking \u00b6 Tip: Backup new configuration before proceeding If you've made any mistakes, you may lose access to your Pi after performing the following steps. Make an offline backup before you proceed by copying files to your local system with scp . # Disable default Raspbian networking sudo systemctl mask dhcpcd.service # Disable legacy Debian networking sudo systemctl mask networking.service # Disable resolvconf service, which manages DNS servers for the OS sudo nano /etc/resolvconf.conf # Add the line resolvconf=NO to the beginning of the file Enable systemd network services \u00b6 # Enable systemd-networkd to replace Raspbian and Debian networking sudo systemctl enable systemd-networkd # Enable systemd-resolved to replace the resolvconf service sudo systemctl enable systemd-resolved DNS resolvers for Linux are loaded from the /etc/resolv.conf . Rather than manage this directly or through resolvconf , we want to load resolvers dynamically from systemd-resolved . This is as simple as creating a link # Set up a symbolic link from systemd-resolved resolv.conf to the system resolv.conf sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf Modify Wireless Startup \u00b6 Our original setup was driven by assumptions about dhcpcd . Before we reboot, we'll make a few brief changes to manage wpa_supplicant on an interface-by-interface basis. # Rename configuration as a per-interface file sudo mv /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant-wlan0.conf # Enable the wpa_supplicant service specifically for wlan0 sudo systemctl enable wpa_supplicant@wlan0 # Disable the non-interface specific service sudo systemctl disable wpa_supplicant Test Your Configuration \u00b6 Call sudo reboot now to reboot the Pi. Log back in and verify that your Pi is fully operational: Confirm that your wireless interface is online cat /etc/resolv.conf to confirm that it is being populated by systemd-resolved Troubleshooting \u00b6 General Guidance \u00b6 When logging back into your Pi, you may find that some of the functionality is failing. In addition to validating log files and checking that you completed all instructions, log files can provide valuable information for detecting where an error is occurring. We have already mentioned journald earlier in this guide. In order to evaluate logs that are created by journald , we make use of the journalctl command. Read up on the less utility to learn how to efficiently navigate journalctl output. # Show log messages journalctl # Include messages marked secure sudo journalctl # Show messages from last boot journalctl -k -b -1 # Show networkd messages journalctl -u systemd-networkd # Show resolved messages journalctl -u systemd-resolved # Show wpa_supplicant messages for wlan0 journalctl -u wpa_supplicant@wlan0 # Load journal from a file path journalctl -D /PATH/TO/JOURNAL_FILE # Learn more about journald man journalctl Accessing a Bricked Pi \u00b6 If you made a mistake at the wrong point in the previous process, you may not even be able to connect anymore from the network. The only way to debug at this point will be to attach a keyboard/monitor to the Pi or to mount the memory card from another Linux machine or VM. Rebuilding Raspbian \u00b6 Alternatively, you may opt to reflash your memory card and repeat initial setup. If you find yourself in this position, the following recommendations will simplify the process: Copy a fully configured wpa_supplicant.conf to the boot volume of the memory card before the first boot. Raspbian will move the file to the proper location in /etc/wpa_supplicant and set its permissions on the first boot. Remove the previous server key hash from .ssh/known_hosts to prevent ssh from complaining about the Pi's new key. macOS/Linux - Run ssh-keygen -R raspberrypi.local Windows - Edit $HOME\\.ssh\\known_hosts and remove the lines that reference raspberrypi.local before you attempt to connect. macOS/Linux - Run ssh-copy-id -i ~/.ssh/id_ed25519 to quickly copy your public keys into authorized_keys . Windows users will have to manually set this file up as shown in previous guides.","title":"networkd Setup"},{"location":"assignments/networkd-setup/#networkd-setup-for-raspbian-2020-01-22","text":"","title":"Networkd Setup for Raspbian (2020-01-22)"},{"location":"assignments/networkd-setup/#intro-to-systemd","text":"An init provider is the first process that is launched on a Linux system. It is responsible for loading other essential services, and it ultimately becomes the parent of every other process on the system. Among the differences between different Linux distributions is the choice of init system. systemd is the initialization (init) provider most often deployed on recent Linux distributions. On Raspbian and other recent Debian-based distros systemd replaces the aging sysvinit . We will interact directly with systemd in this tutorial by issuing systemctl commands to start, stop, enable and disable various system-level services. Beyond its job of launching essential services, systemd provides a modular interface to control many parts of the system. We've already interacted with a few of these components when we used localectl , timedatectl , and hostnamectl during the initial setup of the RaspberryPi. In this tutorial we will leverage three more systemd subsystems: journald - Collects and catalogs log files from system services and applications. You can explore these files with journalctl as seen in Troubleshooting . networkd - Detects and configures network devices and performs various other network management functions. resolved - Provides network name resolution and maintains a list of DNS servers (network-based resolvers) to contact based on settings provided by DHCP or networkd configuration files. Danger: Risk of bricking your Pi A typo or other mistake within the core network configuration can result in total loss of network connectivity. If this happens, you will not be able to manage your Pi over SSH. Your only option will be to configure the Pi again from scratch or to troubleshoot using an external HDMI monitor and USB keyboard. We will not grant extensions for this type of incident. Before you begin to follow these instructions, make an external copy of critical configs such as wpa_supplicant using scp . We provide additional tips for rebuilding at the end of this guide.","title":"Intro to Systemd"},{"location":"assignments/networkd-setup/#systemd-vs-default-networking","text":"By default, Raspbian networking relies on a component called dhcpcd to manage interface settings, addresses, etc. While this component works well for general purpose computing, but it is not a match for every scenario. The current version of Debian (the base OS for Raspbian) supports systemd based network management via the systemd-networkd service. Unlike dhcpcd , networkd is well-suited to managing the base configuration for our router.","title":"Systemd vs Default Networking"},{"location":"assignments/networkd-setup/#enabling-networkd","text":"We will enable networkd in several steps. Try to complete this process in one sitting to avoid \"bricking\" your Pi (at least making it inaccessible over the network).","title":"Enabling Networkd"},{"location":"assignments/networkd-setup/#retain-journald-logs","text":"systemd-networkd stores its logs in systemd-journald . We want journald to keep these logs between boots, which we enable by creating the persistent log path. # Create the location for persistent log messages sudo mkdir -p /var/log/journal sudo systemd-tmpfiles --create --prefix /var/log/journal","title":"Retain journald logs"},{"location":"assignments/networkd-setup/#configure-network-interfaces","text":"To configure the network with networkd , we create files in /etc/systemd/network/ that match named network interfaces and define our desired settings settings. Create the following .network files to handle the default settings for wired and wireless interfaces. Enabling link local addresses is a critical component of these default configurations so that you can still communicate with the Pi when DHCP is not available. Warning Networkd configuration is generally easy to work with, but there are a couple of footguns to be aware of: The files are case sensitive and sometimes sensitive to seemingly innocuous changes in spacing. A file with a missing or invalid [Match] statement will be applied to every interface that hasn't already been matched by an earlier configuration. FAQ: Networkd configuration files man systemd.network provides a comprehensive reference to the format of the networkd configuration files and the process for loading them. At runtime, networkd gathers files using the .network extension from several locations, including /etc/systemd/network/ . To determine the order in which to apply configuration, networkd sorts all of these files lexically. To maintain proper control over execution order, we can prepend a two digit numeric value to the filename. This allows us to set up high-numbered default configurations that are overriden on a case-by-case basis by low-numberd configs files.","title":"Configure network interfaces"},{"location":"assignments/networkd-setup/#default-ethernet-configuration","text":"/etc/systemd/network/99-eth.network [Match] # Applies to eth0, eth1, ... Name=eth* [Network] # Configure IPv4 using DHCP DHCP=ipv4 # Enable link local addresses for IPv4 (169.254.x.y) and IPv6 (FE80::) LinkLocalAddressing=yes","title":"Default ethernet configuration"},{"location":"assignments/networkd-setup/#default-wireless-configuration","text":"/etc/systemd/network/99-wlan.network [Match] Name=wlan* [Network] DHCP=ipv4","title":"Default wireless configuration"},{"location":"assignments/networkd-setup/#disable-default-networking","text":"Tip: Backup new configuration before proceeding If you've made any mistakes, you may lose access to your Pi after performing the following steps. Make an offline backup before you proceed by copying files to your local system with scp . # Disable default Raspbian networking sudo systemctl mask dhcpcd.service # Disable legacy Debian networking sudo systemctl mask networking.service # Disable resolvconf service, which manages DNS servers for the OS sudo nano /etc/resolvconf.conf # Add the line resolvconf=NO to the beginning of the file","title":"Disable default networking"},{"location":"assignments/networkd-setup/#enable-systemd-network-services","text":"# Enable systemd-networkd to replace Raspbian and Debian networking sudo systemctl enable systemd-networkd # Enable systemd-resolved to replace the resolvconf service sudo systemctl enable systemd-resolved DNS resolvers for Linux are loaded from the /etc/resolv.conf . Rather than manage this directly or through resolvconf , we want to load resolvers dynamically from systemd-resolved . This is as simple as creating a link # Set up a symbolic link from systemd-resolved resolv.conf to the system resolv.conf sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf","title":"Enable systemd network services"},{"location":"assignments/networkd-setup/#modify-wireless-startup","text":"Our original setup was driven by assumptions about dhcpcd . Before we reboot, we'll make a few brief changes to manage wpa_supplicant on an interface-by-interface basis. # Rename configuration as a per-interface file sudo mv /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant-wlan0.conf # Enable the wpa_supplicant service specifically for wlan0 sudo systemctl enable wpa_supplicant@wlan0 # Disable the non-interface specific service sudo systemctl disable wpa_supplicant","title":"Modify Wireless Startup"},{"location":"assignments/networkd-setup/#test-your-configuration","text":"Call sudo reboot now to reboot the Pi. Log back in and verify that your Pi is fully operational: Confirm that your wireless interface is online cat /etc/resolv.conf to confirm that it is being populated by systemd-resolved","title":"Test Your Configuration"},{"location":"assignments/networkd-setup/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"assignments/networkd-setup/#general-guidance","text":"When logging back into your Pi, you may find that some of the functionality is failing. In addition to validating log files and checking that you completed all instructions, log files can provide valuable information for detecting where an error is occurring. We have already mentioned journald earlier in this guide. In order to evaluate logs that are created by journald , we make use of the journalctl command. Read up on the less utility to learn how to efficiently navigate journalctl output. # Show log messages journalctl # Include messages marked secure sudo journalctl # Show messages from last boot journalctl -k -b -1 # Show networkd messages journalctl -u systemd-networkd # Show resolved messages journalctl -u systemd-resolved # Show wpa_supplicant messages for wlan0 journalctl -u wpa_supplicant@wlan0 # Load journal from a file path journalctl -D /PATH/TO/JOURNAL_FILE # Learn more about journald man journalctl","title":"General Guidance"},{"location":"assignments/networkd-setup/#accessing-a-bricked-pi","text":"If you made a mistake at the wrong point in the previous process, you may not even be able to connect anymore from the network. The only way to debug at this point will be to attach a keyboard/monitor to the Pi or to mount the memory card from another Linux machine or VM.","title":"Accessing a Bricked Pi"},{"location":"assignments/networkd-setup/#rebuilding-raspbian","text":"Alternatively, you may opt to reflash your memory card and repeat initial setup. If you find yourself in this position, the following recommendations will simplify the process: Copy a fully configured wpa_supplicant.conf to the boot volume of the memory card before the first boot. Raspbian will move the file to the proper location in /etc/wpa_supplicant and set its permissions on the first boot. Remove the previous server key hash from .ssh/known_hosts to prevent ssh from complaining about the Pi's new key. macOS/Linux - Run ssh-keygen -R raspberrypi.local Windows - Edit $HOME\\.ssh\\known_hosts and remove the lines that reference raspberrypi.local before you attempt to connect. macOS/Linux - Run ssh-copy-id -i ~/.ssh/id_ed25519 to quickly copy your public keys into authorized_keys . Windows users will have to manually set this file up as shown in previous guides.","title":"Rebuilding Raspbian"},{"location":"assignments/pi-setup/","text":"Raspberry Pi Setup Guide (2020-01-14) \u00b6 Overview \u00b6 This guide will walk you through the steps necessary to install Raspbian on your Pi and connect it to Wifi. While we encourage you to search online and use other resources when you encounter questions, it's important that you follow our instructions closely. Though there are many different guides that can help you accomplish the same objectives, this guide has been built based on the needs and requirements of our projects and introduces you to tools you will need throughout the quarter. The core sections of this guide will walk you through the following steps: Installing Raspbian on a MicroSD and enabling SSH Updating defaults and other preliminary setup steps Configuring a wifi connection Updating Raspbian and installing additional packages with apt Before you start setting up your Pi, please review the tasks in the following section. These steps are particularly important for students running Windows and Linux. Before you start \u00b6 Everyone \u00b6 Download and install Etcher from https://etcher.io . Etcher is among the easiest options for writing a Pi OS image to a microSD. Windows Users \u00b6 Terminal \u00b6 Except when otherwise noted, I recommend that Windows users complete all Linux networking exercises within Windows PowerShell rather than Git Bash or the Command Prompt. Info For a much improved working experience, you should download the new Windows Terminal application. This app is available in the Microsoft Store or from https://github.com/microsoft/terminal/releases . By default, the terminal will run PowerShell, but it also supports Command Prompt and Windows Subsystem for Linux. Text Editor \u00b6 Among the many subtle differences between Windows and Unix-based machines is a difference in the control characters used to terminate lines in text files. In many cases, this difference will prevent Linux from parsing a file you've written and copied from Windows. To avoid this issue, install a code-oriented text editor that can be configured to use Unix-style line endings and use it exclusively for the labs and projects throughout this course. Visual Studio Code and Atom are common options. To configure VS Code to use Unix-style line endings: Open Settings Search for the term \u201cEol\u201d Change the default End-of-Line character to \\n To configure Atom to use Unix-style line endings: Open Settings Navigate to Packages / Line Ending Selector Change the Default line ending to LF Verify Support for mDNS \u00b6 Please check the full version of Windows that you have installed by running Get-ComputerInfo -Property Windows* in a PowerShell console. After a moment, you'll receive a message describing your current Windows installation (as illustrated below). WindowsBuildLabEx : 17763.1.amd64fre.rs5_release.180914-1434 WindowsCurrentVersion : 6.3 WindowsEditionId : Professional WindowsInstallationType : Client WindowsInstallDateFromRegistry : 1/10/2019 8:10:04 AM WindowsProductId : 00330-80000-00000-AA819 WindowsProductName : Windows 10 Pro WindowsRegisteredOrganization : WindowsRegisteredOwner : clementine WindowsSystemRoot : C:\\WINDOWS WindowsVersion : 1809 If the system reports that you are on Windows 10 and that the WindowsVerion is 1809 or newer, you are ready to proceed with main tutorial. Otherwise, you will need to upgrade Windows to a supported version. Linux Users \u00b6 Using your default package manager (likely yum or apt ), confirm that Avahi mDNS services are installed (mDNS is typically part of the default distribution). Install Raspbian \u00b6 The Raspberry Pi is built with Linux distributions in mind. The official distribution, which we'll use in our labs is known as Raspbian and is based on Debian Linux. If you're familiar at all with Ubuntu, you should be mostly at home working in Raspbian. Don't worry if Linux is not your jam. We'll provide plenty of guidance so that you can focus your energy on the network concepts. Write Raspbian to MicroSD \u00b6 Download a current image of Raspbian from http://www.raspberrypi.org/downloads . We will use Raspbian Buster Lite for this course. This version of Raspbian is headless, meaning that it does not include a desktop environment. We\u2019ll leverage SSH to do all of our configuration through the CLI. Use Etcher to write the image you've downloaded to a microSD. Be aware that this process will overwrite any data that was already stored on the card. Update Configuration \u00b6 Etcher will eject the microSD once the image is completely rewritten. We want to edit some files on the SD, so you will need to briefly remove the card before inserting it again. On macOS or Windows, you'll be limited to accessing the boot partition of the card. Use Explorer or Finder to locate and open the partition. You must complete the following step before the first boot. Enable SSH \u00b6 Due to security considerations, the newest versions of Raspian disable SSH by default, but it's easy to turn the feature on so that we can use it for initial setup. To enable SSH on the first boot, add an empty file named ssh to the boot volume. Instructions will vary slightly between macOS and Windows: macOS # Unix-based systems mount external storage to a path in the directory tree. For a freshly written Raspbian image, this path will be /Volumes/boot. touch /Volumes/boot/ssh Windows # Windows mounts external storage to a drive letter. Replace E: with the letter assigned on your system. New-Item -type File E : \\ ssh Raspbian will check for this file during the first startup and proceed to configure the SSH daemon to start automatically. The term daemon, by the way, is the name Unix operating systems use to describe a service that runs in the background (e.g., to respond to network requests). Initial Boot \u00b6 It's time to boot the Pi for the first time. Close your editor and any windows that are open to the microSD so that you can eject the card gracefully from your OS. Remove the microSD and insert into the card slot on your Pi. Connect power to the designated micro-USB port. Attach to your computer with an Ethernet cable and get ready to launch an SSH connection. From terminal or PowerShell, connect to the Pi for the first time by running the following command: # The default password for pi is raspberry ssh pi@raspberrypi.local This command directs your local SSH client to connect to a network host named raspberrypi.local with the username pi . Using the mDNS service, your computer will resolve the hostname to an IP address SSH will ask you to accept the connection of an unknown device before presenting you with a password prompt. $ ssh pi@raspberrypi.local The authenticity of host 'raspberrypi.local (fe80::1b9c:bcf2:acd6:bbbe%42)' can't be established. ECDSA key fingerprint is SHA256:QqhpMybvctuIxV03xcnlANU3cxWM1JhvSYxloSd69Rw. Are you sure you want to continue connecting (yes/no)? If you've previously connected to a host with the name raspberrypi.local , you may also see the warning shown below (please refer to the troubleshooting section to resolve this error): @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! If you are running Windows and receive a message that Windows cannot resolve the name raspberrypi.local , please refer to the instructions at the top of this guide. After confirming the prompt shown above, you will see another short message followed by a password prompt. Warning: Permanently added 'raspberrypi.local,fe80::1b9c:bcf2:acd6:bbbe%42' (ECDSA) to the list of known hosts. pi@raspberrypi.local's password: The default password for the pi user is raspberry . Once login is complete, you should be greeted with a message similar to that shown here. Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is disabled because the country is not set. Use raspi-config to set the country before use. pi@raspberrypi:~ $ Choose a New Password \u00b6 Before proceeding further with setup, you should change the default password by entering the passwd at the command prompt. You will be guided through three prompts to enter the current password and then to update/confirm the new password. Danger SSH is a favorite target of malicious attackers. Nothing makes their lives easier than devices that are configured with the default password for the type of system. Default Configuration \u00b6 After you complete this step, I also recommend the following changes on every new Linux device: Setting the timezone will ensure that log messages are displayed in local time, which is quite helpful for troubleshooting. # You can see a list of timezones by running `timedatectl list-timezones` sudo timedatectl set-timezone America/Los_Angeles Raspbian defaults to a British locale. This can cause issues if we ever need to troubleshoot your device using an external keyboard. Configure the locale and keymap to prevent these issues. # Update /etc/locale.gen with your preferences sudo nano /etc/locale.gen # Find and uncomment the en_US.UTF-8 locale # Re-generate locale information after updating the locale.gen file sudo locale-gen # Apply new settings sudo localectl set-locale \"LANG=en_US.UTF-8\" sudo localectl set-keymap us Occasionally we'll end up running a program that uses the default editor settings for your profile (or root if we have run the program with sudo ). It's helpful to have these configured so that you don't end up stuck in vi or ed without any way to exit. # Update default editor selections for the pi user select-editor # Modify the same setting for commands that require root privileges. sudo select-editor Update Hostname \u00b6 At first boot, we could locate our Pi on the network based on the default hostname of raspberrypi.local . This is fine in an isolated, point-to-point network, but it's a problem when we connect to shared networks. Use the hostnamectl command to set a unique name for your device. # This little pi likes to be called Titan sudo hostnamectl set-hostname titan The main change that hostnamectl makes is visible in /etc/hostname . We also need to update references to the hostname in /etc/hosts . The hosts file is present on most Operating Systems and provides a way of defining hostname/IP address associations without relying on DNS. Linux uses this file to associate your hostname to the loopback IP address. # Confirm your hostname is up to date in /etc/hostname cat /etc/hostname # Replace any references to raspberrypi in /etc/hosts sudo nano /etc/hosts FAQ: Why is sudo slow You might notice odd warnings and sudo latency immediately after changing the hostname. These should clear up once you update the hosts file . For reasons beyond the scope of this curriculum, sudo performs DNS lookups as part of its check to determine whether the current user is permitted to elevate privileges. The delay you experience is the tool waiting for a DNS response prior to its timeout. In order for the hostname changes to take full effect, reboot your pi by calling sudo reboot now . After 20 - 30 seconds your pi will be visible with the new name -- you will need to include the .local suffix on any command referencing the name. Example # ping by MDNS hostname ping titan.local # ssh by MDNS hostname ssh pi@titan.local Enable Passwordless Login \u00b6 We can significantly simplify the process of managing our Pi\u2019s by copying our public SSH keys into the authorized_keys file of the default pi user. To prepare the Raspberry Pi, we need to create a remote directory under the pi user's home directory. If you're still logged into your pi, you can create the directory using mkdir ~/.ssh . After that is done, type exit to terminate the connection and return to your local command prompt. FAQ: Why aren't ssh and scp working Please review the previous set of instructions closely. The commands below are run from your local shell. Running them inside of an existing SSH session will not have the effect you are looking for. With the directory in place, copy your public key (most likely ~/.ssh/id_ed25519.pub ) to the pi using the scp command. scp $HOME /.ssh/id_ed25519.pub pi@raspberrypi.local:.ssh/authorized_keys Info The second set of parameters in this command specifies the user ( pi ) the host ( titan.local ) and the location of the new file ( .ssh/authorized_keys ). Like ssh , scp is a user-based tool and will be executed relative to the home directory of the authenticated user ( /home/pi ). We can override the default by specifying an absolute path beginning with a / , e.g., /home/pi/.ssh/authorized_keys . Connect to Wifi \u00b6 To complete this guide, you will need to establish Internet connectivity for your Pi. Since the Pi 3 has integrated wireless capabilities, we can solve the problem by connecting to local wifi. Configure the WPA Supplicant \u00b6 Wireless settings for the Pi are controlled by a service called wpa_supplicant , which stores network connection settings inside /etc/wpa_supplicant/wpa_supplicant.conf . You can edit this directly on the Pi using the nano text editor (or vi for the daring). Alternatively, you can create the file on your local system and copy it into place on the Pi. For this project, you must configure a connection to the Eduroam network. It's also a good idea at this time to configure connections to your home network. Warning Do not associate your Pi with University of Washington unless given direct instructions to do so. Because the network requires a browser-based login, it has been a major source of trouble for former students. Begin your wpa_supplicant.conf file with the following lines. Example country=US ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 # INSERT WPA2 ENTERPRISE CONFIG FOR EDUROAM Afterwards add one or more network blocks ( including a connection to Eduroam ). If you are new to this, there are detailed configuration instructions on how to add network blocks are available in WPA Supplicant Configuration Reference . When you are finished updating wpa_supplicant.conf reconfigure the wireless interface by calling wpa_cli -i wlan0 reconfigure . The command should return OK after a few seconds. Check that you are attached to the wireless network by calling wpa_cli -i wlan0 status . Example of what wlan0 status should print wpa_cli -i wlan0 status bssid=ac:a3:1e:eb:53:c1 freq=2462 ssid=eduroam id=0 mode=station pairwise_cipher=CCMP group_cipher=CCMP key_mgmt=WPA2/IEEE 802.1X/EAP wpa_state=COMPLETED ip_address=10.18.185.176 p2p_device_address=fa:f8:ee:8c:fe:62 address=b8:27:eb:db:fe:93 Supplicant PAE state=AUTHENTICATED suppPortStatus=Authorized EAP state=SUCCESS selectedMethod=25 (EAP-PEAP) EAP TLS cipher=ECDHE-RSA-AES256-GCM-SHA384 tls_session_reused=0 EAP-PEAPv0 Phase2 method=MSCHAPV2 eap_session_id=19865aef996591ffbd01643fbcf1b5111ef04dd3ed4f3387752c8cc0cf3b8c88b95c40bfc4915b284b3b91f60f5cb71074baaf1360d39f7a91530143dcb3c8e4ce uuid=c4adf7c1-f863-5192-8179-f5d1d2e27fd7 Testing and Troubleshooting \u00b6 In addition to wpa_cli , there are several tools that can be used to check the current state of your wireless interface and determine whether it has received a valid configuration from DHCP. # Show the current state of the wlan0 interface ip link show wlan0 3 : wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DORMANT group default qlen 1000 link/ether b8:27:eb:db:fe:93 brd ff:ff:ff:ff:ff:ff # Show address configuration for the wlan0 interface ip addr show wlan0 3 : wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether b8:27:eb:db:fe:93 brd ff:ff:ff:ff:ff:ff inet 10 .18.185.176/15 brd 10 .19.255.255 scope global wlan0 valid_lft forever preferred_lft forever inet6 fe80::ce14:df50:b3f0:9c2a/64 scope link valid_lft forever preferred_lft forever Update Software Packages \u00b6 Let's finalize the initial setup by checking for updates to Raspbian and its default packages (this can take a few minutes on slow networks). As a Debian based Linux distribution, Raspbian relies on apt for package management. The apt update command is used to determine whether there are new packages to download. sudo apt update sudo apt upgrade sudo apt dist-upgrade # We've found that an additional update is sometimes needed after a dist-upgrade sudo apt update # Install some useful packages while you're at it sudo apt install dnsutils Graceful Shutdown \u00b6 Never yank the power from your Pi when it's time to quit. This can lead to data corruption on the microSD (they aren't as resilient as the drives installed in your laptop). Instead, you should always issue a proper shutdown via SSH. From an SSH connection, run sudo poweroff . If you ever need to reboot the Pi, call sudo reboot now . Wait about 15 - 20 seconds to allow the Pi to complete it\u2019s shutdown process before disconnecting the power. Tips and Troubleshooting \u00b6 Can't find raspberrypi.local \u00b6 To make an initial connection with the Raspberry Pi, you need Check Network Adapters \u00b6 If you are confident that you will need to check the configuration of the Ethernet port or USB device on your local computer. Run ipconfig on Windows or ifconfig on other devices to confirm that the interface registers a network connection. The local IPv4 address for this interface should begin with 169.254.x.x (link-local address range). If you do not see a valid connection, you may need to review the next section on missing drivers. Linux Most devices will assign a Link-Local address by default when DHCP cannot be found, but some versions of Linux, e.g., Ubuntu require you to choose between link-local addressing and DHCP. If you are on Ubuntu, explore your advanced adapter settings for Ethernet to configure your adapter settings. MDNS \u00b6 Windows Make sure that you are on the latest version of Windows 10. Though mDNS is now a draft standard, Microsoft did not include a full client until the most recent versions of Windows 10 (confirmed on 1809). Support for MDNS prior to Windows 10 depends on Bonjour Print Services, an MDNS client distributed by Apple and previously bundled with iTunes and various other applications. Bonjour-related Conflicts While Bonjour was a useful tool on older versions of Windows, we suspect that it causes conflicts on versions 1803+. You can determine whether Bonjour is installed and remove it through Settings or Control Panel. Linux Linux relies on the Avahi daemon to query/respond to MDNS. Review the requirements at the beginning of this guide . Missing Network Drivers \u00b6 If you are using a USB Ethernet port for the first time on your computer, it's possible that your first attempt to connect will be unsuccessful. Many of these issues are resolved by disconnecting the USB briefly and trying after you have plugged everything back in. If issues persist, search online to determine whether your computer is missing a driver needed for the specific model of Ethernet adapter. SSH Connection Warning \u00b6 At some point, you are likely to receive the following warning when trying to launch ssh . In most cases, what you are seeing is expected behavior. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! The first time you connect to a host, SSH will bind a cryptographic signature to the hostname, e.g., raspberrypi.local and store it within ~/.ssh/known_hosts . To prevent attacks, SSH warns us when the signature changes for a known host. In our case, it's likely that there is another explanation for the mismatched signature since SSH will create a new private key every time we set up or rebuild a Raspberry Pi. Since this is not an attack scenario, resolve the conflict with ssh-keygen -R raspberrypi.local , which will remove the existing entry. Missing features in Windows SSH The ssh-keygen -R feature isn't present before Windows 10 1809. If you are still running an older version of Windows, you will have to locate known_hosts within the .ssh configuration directory and remove the line indicated by the warning message. Permission Denied Errors \u00b6 When we're performing system and network administration, we are often in need of root privileges. Running an administrative command without the appropriate privileges will result in a permissions-related error. By default, the pi user is restricted in which parts of the system it can read and modify (Linux is heavily user-based in it's permissions model); however, the user is permitted to elevate itself to the admin level with sudo when it is necessary to perform privileged commands. As a general security precaution, don't sudo commands unless it's necessary. For now, we'll indicate when that's the case. In later tasks, you will need to make this determination on your own.","title":"Raspberry Pi Setup"},{"location":"assignments/pi-setup/#raspberry-pi-setup-guide-2020-01-14","text":"","title":"Raspberry Pi Setup Guide (2020-01-14)"},{"location":"assignments/pi-setup/#overview","text":"This guide will walk you through the steps necessary to install Raspbian on your Pi and connect it to Wifi. While we encourage you to search online and use other resources when you encounter questions, it's important that you follow our instructions closely. Though there are many different guides that can help you accomplish the same objectives, this guide has been built based on the needs and requirements of our projects and introduces you to tools you will need throughout the quarter. The core sections of this guide will walk you through the following steps: Installing Raspbian on a MicroSD and enabling SSH Updating defaults and other preliminary setup steps Configuring a wifi connection Updating Raspbian and installing additional packages with apt Before you start setting up your Pi, please review the tasks in the following section. These steps are particularly important for students running Windows and Linux.","title":"Overview"},{"location":"assignments/pi-setup/#before-you-start","text":"","title":"Before you start"},{"location":"assignments/pi-setup/#everyone","text":"Download and install Etcher from https://etcher.io . Etcher is among the easiest options for writing a Pi OS image to a microSD.","title":"Everyone"},{"location":"assignments/pi-setup/#windows-users","text":"","title":"Windows Users"},{"location":"assignments/pi-setup/#terminal","text":"Except when otherwise noted, I recommend that Windows users complete all Linux networking exercises within Windows PowerShell rather than Git Bash or the Command Prompt. Info For a much improved working experience, you should download the new Windows Terminal application. This app is available in the Microsoft Store or from https://github.com/microsoft/terminal/releases . By default, the terminal will run PowerShell, but it also supports Command Prompt and Windows Subsystem for Linux.","title":"Terminal"},{"location":"assignments/pi-setup/#text-editor","text":"Among the many subtle differences between Windows and Unix-based machines is a difference in the control characters used to terminate lines in text files. In many cases, this difference will prevent Linux from parsing a file you've written and copied from Windows. To avoid this issue, install a code-oriented text editor that can be configured to use Unix-style line endings and use it exclusively for the labs and projects throughout this course. Visual Studio Code and Atom are common options. To configure VS Code to use Unix-style line endings: Open Settings Search for the term \u201cEol\u201d Change the default End-of-Line character to \\n To configure Atom to use Unix-style line endings: Open Settings Navigate to Packages / Line Ending Selector Change the Default line ending to LF","title":"Text Editor"},{"location":"assignments/pi-setup/#verify-support-for-mdns","text":"Please check the full version of Windows that you have installed by running Get-ComputerInfo -Property Windows* in a PowerShell console. After a moment, you'll receive a message describing your current Windows installation (as illustrated below). WindowsBuildLabEx : 17763.1.amd64fre.rs5_release.180914-1434 WindowsCurrentVersion : 6.3 WindowsEditionId : Professional WindowsInstallationType : Client WindowsInstallDateFromRegistry : 1/10/2019 8:10:04 AM WindowsProductId : 00330-80000-00000-AA819 WindowsProductName : Windows 10 Pro WindowsRegisteredOrganization : WindowsRegisteredOwner : clementine WindowsSystemRoot : C:\\WINDOWS WindowsVersion : 1809 If the system reports that you are on Windows 10 and that the WindowsVerion is 1809 or newer, you are ready to proceed with main tutorial. Otherwise, you will need to upgrade Windows to a supported version.","title":"Verify Support for mDNS"},{"location":"assignments/pi-setup/#linux-users","text":"Using your default package manager (likely yum or apt ), confirm that Avahi mDNS services are installed (mDNS is typically part of the default distribution).","title":"Linux Users"},{"location":"assignments/pi-setup/#install-raspbian","text":"The Raspberry Pi is built with Linux distributions in mind. The official distribution, which we'll use in our labs is known as Raspbian and is based on Debian Linux. If you're familiar at all with Ubuntu, you should be mostly at home working in Raspbian. Don't worry if Linux is not your jam. We'll provide plenty of guidance so that you can focus your energy on the network concepts.","title":"Install Raspbian"},{"location":"assignments/pi-setup/#write-raspbian-to-microsd","text":"Download a current image of Raspbian from http://www.raspberrypi.org/downloads . We will use Raspbian Buster Lite for this course. This version of Raspbian is headless, meaning that it does not include a desktop environment. We\u2019ll leverage SSH to do all of our configuration through the CLI. Use Etcher to write the image you've downloaded to a microSD. Be aware that this process will overwrite any data that was already stored on the card.","title":"Write Raspbian to MicroSD"},{"location":"assignments/pi-setup/#update-configuration","text":"Etcher will eject the microSD once the image is completely rewritten. We want to edit some files on the SD, so you will need to briefly remove the card before inserting it again. On macOS or Windows, you'll be limited to accessing the boot partition of the card. Use Explorer or Finder to locate and open the partition. You must complete the following step before the first boot.","title":"Update Configuration"},{"location":"assignments/pi-setup/#enable-ssh","text":"Due to security considerations, the newest versions of Raspian disable SSH by default, but it's easy to turn the feature on so that we can use it for initial setup. To enable SSH on the first boot, add an empty file named ssh to the boot volume. Instructions will vary slightly between macOS and Windows: macOS # Unix-based systems mount external storage to a path in the directory tree. For a freshly written Raspbian image, this path will be /Volumes/boot. touch /Volumes/boot/ssh Windows # Windows mounts external storage to a drive letter. Replace E: with the letter assigned on your system. New-Item -type File E : \\ ssh Raspbian will check for this file during the first startup and proceed to configure the SSH daemon to start automatically. The term daemon, by the way, is the name Unix operating systems use to describe a service that runs in the background (e.g., to respond to network requests).","title":"Enable SSH"},{"location":"assignments/pi-setup/#initial-boot","text":"It's time to boot the Pi for the first time. Close your editor and any windows that are open to the microSD so that you can eject the card gracefully from your OS. Remove the microSD and insert into the card slot on your Pi. Connect power to the designated micro-USB port. Attach to your computer with an Ethernet cable and get ready to launch an SSH connection. From terminal or PowerShell, connect to the Pi for the first time by running the following command: # The default password for pi is raspberry ssh pi@raspberrypi.local This command directs your local SSH client to connect to a network host named raspberrypi.local with the username pi . Using the mDNS service, your computer will resolve the hostname to an IP address SSH will ask you to accept the connection of an unknown device before presenting you with a password prompt. $ ssh pi@raspberrypi.local The authenticity of host 'raspberrypi.local (fe80::1b9c:bcf2:acd6:bbbe%42)' can't be established. ECDSA key fingerprint is SHA256:QqhpMybvctuIxV03xcnlANU3cxWM1JhvSYxloSd69Rw. Are you sure you want to continue connecting (yes/no)? If you've previously connected to a host with the name raspberrypi.local , you may also see the warning shown below (please refer to the troubleshooting section to resolve this error): @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! If you are running Windows and receive a message that Windows cannot resolve the name raspberrypi.local , please refer to the instructions at the top of this guide. After confirming the prompt shown above, you will see another short message followed by a password prompt. Warning: Permanently added 'raspberrypi.local,fe80::1b9c:bcf2:acd6:bbbe%42' (ECDSA) to the list of known hosts. pi@raspberrypi.local's password: The default password for the pi user is raspberry . Once login is complete, you should be greeted with a message similar to that shown here. Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Linux raspberrypi 4.14.79-v7+ #1159 SMP Sun Nov 4 17:50:20 GMT 2018 armv7l The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is disabled because the country is not set. Use raspi-config to set the country before use. pi@raspberrypi:~ $","title":"Initial Boot"},{"location":"assignments/pi-setup/#choose-a-new-password","text":"Before proceeding further with setup, you should change the default password by entering the passwd at the command prompt. You will be guided through three prompts to enter the current password and then to update/confirm the new password. Danger SSH is a favorite target of malicious attackers. Nothing makes their lives easier than devices that are configured with the default password for the type of system.","title":"Choose a New Password"},{"location":"assignments/pi-setup/#default-configuration","text":"After you complete this step, I also recommend the following changes on every new Linux device: Setting the timezone will ensure that log messages are displayed in local time, which is quite helpful for troubleshooting. # You can see a list of timezones by running `timedatectl list-timezones` sudo timedatectl set-timezone America/Los_Angeles Raspbian defaults to a British locale. This can cause issues if we ever need to troubleshoot your device using an external keyboard. Configure the locale and keymap to prevent these issues. # Update /etc/locale.gen with your preferences sudo nano /etc/locale.gen # Find and uncomment the en_US.UTF-8 locale # Re-generate locale information after updating the locale.gen file sudo locale-gen # Apply new settings sudo localectl set-locale \"LANG=en_US.UTF-8\" sudo localectl set-keymap us Occasionally we'll end up running a program that uses the default editor settings for your profile (or root if we have run the program with sudo ). It's helpful to have these configured so that you don't end up stuck in vi or ed without any way to exit. # Update default editor selections for the pi user select-editor # Modify the same setting for commands that require root privileges. sudo select-editor","title":"Default Configuration"},{"location":"assignments/pi-setup/#update-hostname","text":"At first boot, we could locate our Pi on the network based on the default hostname of raspberrypi.local . This is fine in an isolated, point-to-point network, but it's a problem when we connect to shared networks. Use the hostnamectl command to set a unique name for your device. # This little pi likes to be called Titan sudo hostnamectl set-hostname titan The main change that hostnamectl makes is visible in /etc/hostname . We also need to update references to the hostname in /etc/hosts . The hosts file is present on most Operating Systems and provides a way of defining hostname/IP address associations without relying on DNS. Linux uses this file to associate your hostname to the loopback IP address. # Confirm your hostname is up to date in /etc/hostname cat /etc/hostname # Replace any references to raspberrypi in /etc/hosts sudo nano /etc/hosts FAQ: Why is sudo slow You might notice odd warnings and sudo latency immediately after changing the hostname. These should clear up once you update the hosts file . For reasons beyond the scope of this curriculum, sudo performs DNS lookups as part of its check to determine whether the current user is permitted to elevate privileges. The delay you experience is the tool waiting for a DNS response prior to its timeout. In order for the hostname changes to take full effect, reboot your pi by calling sudo reboot now . After 20 - 30 seconds your pi will be visible with the new name -- you will need to include the .local suffix on any command referencing the name. Example # ping by MDNS hostname ping titan.local # ssh by MDNS hostname ssh pi@titan.local","title":"Update Hostname"},{"location":"assignments/pi-setup/#enable-passwordless-login","text":"We can significantly simplify the process of managing our Pi\u2019s by copying our public SSH keys into the authorized_keys file of the default pi user. To prepare the Raspberry Pi, we need to create a remote directory under the pi user's home directory. If you're still logged into your pi, you can create the directory using mkdir ~/.ssh . After that is done, type exit to terminate the connection and return to your local command prompt. FAQ: Why aren't ssh and scp working Please review the previous set of instructions closely. The commands below are run from your local shell. Running them inside of an existing SSH session will not have the effect you are looking for. With the directory in place, copy your public key (most likely ~/.ssh/id_ed25519.pub ) to the pi using the scp command. scp $HOME /.ssh/id_ed25519.pub pi@raspberrypi.local:.ssh/authorized_keys Info The second set of parameters in this command specifies the user ( pi ) the host ( titan.local ) and the location of the new file ( .ssh/authorized_keys ). Like ssh , scp is a user-based tool and will be executed relative to the home directory of the authenticated user ( /home/pi ). We can override the default by specifying an absolute path beginning with a / , e.g., /home/pi/.ssh/authorized_keys .","title":"Enable Passwordless Login"},{"location":"assignments/pi-setup/#connect-to-wifi","text":"To complete this guide, you will need to establish Internet connectivity for your Pi. Since the Pi 3 has integrated wireless capabilities, we can solve the problem by connecting to local wifi.","title":"Connect to Wifi"},{"location":"assignments/pi-setup/#configure-the-wpa-supplicant","text":"Wireless settings for the Pi are controlled by a service called wpa_supplicant , which stores network connection settings inside /etc/wpa_supplicant/wpa_supplicant.conf . You can edit this directly on the Pi using the nano text editor (or vi for the daring). Alternatively, you can create the file on your local system and copy it into place on the Pi. For this project, you must configure a connection to the Eduroam network. It's also a good idea at this time to configure connections to your home network. Warning Do not associate your Pi with University of Washington unless given direct instructions to do so. Because the network requires a browser-based login, it has been a major source of trouble for former students. Begin your wpa_supplicant.conf file with the following lines. Example country=US ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 # INSERT WPA2 ENTERPRISE CONFIG FOR EDUROAM Afterwards add one or more network blocks ( including a connection to Eduroam ). If you are new to this, there are detailed configuration instructions on how to add network blocks are available in WPA Supplicant Configuration Reference . When you are finished updating wpa_supplicant.conf reconfigure the wireless interface by calling wpa_cli -i wlan0 reconfigure . The command should return OK after a few seconds. Check that you are attached to the wireless network by calling wpa_cli -i wlan0 status . Example of what wlan0 status should print wpa_cli -i wlan0 status bssid=ac:a3:1e:eb:53:c1 freq=2462 ssid=eduroam id=0 mode=station pairwise_cipher=CCMP group_cipher=CCMP key_mgmt=WPA2/IEEE 802.1X/EAP wpa_state=COMPLETED ip_address=10.18.185.176 p2p_device_address=fa:f8:ee:8c:fe:62 address=b8:27:eb:db:fe:93 Supplicant PAE state=AUTHENTICATED suppPortStatus=Authorized EAP state=SUCCESS selectedMethod=25 (EAP-PEAP) EAP TLS cipher=ECDHE-RSA-AES256-GCM-SHA384 tls_session_reused=0 EAP-PEAPv0 Phase2 method=MSCHAPV2 eap_session_id=19865aef996591ffbd01643fbcf1b5111ef04dd3ed4f3387752c8cc0cf3b8c88b95c40bfc4915b284b3b91f60f5cb71074baaf1360d39f7a91530143dcb3c8e4ce uuid=c4adf7c1-f863-5192-8179-f5d1d2e27fd7","title":"Configure the WPA Supplicant"},{"location":"assignments/pi-setup/#testing-and-troubleshooting","text":"In addition to wpa_cli , there are several tools that can be used to check the current state of your wireless interface and determine whether it has received a valid configuration from DHCP. # Show the current state of the wlan0 interface ip link show wlan0 3 : wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DORMANT group default qlen 1000 link/ether b8:27:eb:db:fe:93 brd ff:ff:ff:ff:ff:ff # Show address configuration for the wlan0 interface ip addr show wlan0 3 : wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether b8:27:eb:db:fe:93 brd ff:ff:ff:ff:ff:ff inet 10 .18.185.176/15 brd 10 .19.255.255 scope global wlan0 valid_lft forever preferred_lft forever inet6 fe80::ce14:df50:b3f0:9c2a/64 scope link valid_lft forever preferred_lft forever","title":"Testing and Troubleshooting"},{"location":"assignments/pi-setup/#update-software-packages","text":"Let's finalize the initial setup by checking for updates to Raspbian and its default packages (this can take a few minutes on slow networks). As a Debian based Linux distribution, Raspbian relies on apt for package management. The apt update command is used to determine whether there are new packages to download. sudo apt update sudo apt upgrade sudo apt dist-upgrade # We've found that an additional update is sometimes needed after a dist-upgrade sudo apt update # Install some useful packages while you're at it sudo apt install dnsutils","title":"Update Software Packages"},{"location":"assignments/pi-setup/#graceful-shutdown","text":"Never yank the power from your Pi when it's time to quit. This can lead to data corruption on the microSD (they aren't as resilient as the drives installed in your laptop). Instead, you should always issue a proper shutdown via SSH. From an SSH connection, run sudo poweroff . If you ever need to reboot the Pi, call sudo reboot now . Wait about 15 - 20 seconds to allow the Pi to complete it\u2019s shutdown process before disconnecting the power.","title":"Graceful Shutdown"},{"location":"assignments/pi-setup/#tips-and-troubleshooting","text":"","title":"Tips and Troubleshooting"},{"location":"assignments/pi-setup/#cant-find-raspberrypilocal","text":"To make an initial connection with the Raspberry Pi, you need","title":"Can't find raspberrypi.local"},{"location":"assignments/pi-setup/#check-network-adapters","text":"If you are confident that you will need to check the configuration of the Ethernet port or USB device on your local computer. Run ipconfig on Windows or ifconfig on other devices to confirm that the interface registers a network connection. The local IPv4 address for this interface should begin with 169.254.x.x (link-local address range). If you do not see a valid connection, you may need to review the next section on missing drivers. Linux Most devices will assign a Link-Local address by default when DHCP cannot be found, but some versions of Linux, e.g., Ubuntu require you to choose between link-local addressing and DHCP. If you are on Ubuntu, explore your advanced adapter settings for Ethernet to configure your adapter settings.","title":"Check Network Adapters"},{"location":"assignments/pi-setup/#mdns","text":"Windows Make sure that you are on the latest version of Windows 10. Though mDNS is now a draft standard, Microsoft did not include a full client until the most recent versions of Windows 10 (confirmed on 1809). Support for MDNS prior to Windows 10 depends on Bonjour Print Services, an MDNS client distributed by Apple and previously bundled with iTunes and various other applications. Bonjour-related Conflicts While Bonjour was a useful tool on older versions of Windows, we suspect that it causes conflicts on versions 1803+. You can determine whether Bonjour is installed and remove it through Settings or Control Panel. Linux Linux relies on the Avahi daemon to query/respond to MDNS. Review the requirements at the beginning of this guide .","title":"MDNS"},{"location":"assignments/pi-setup/#missing-network-drivers","text":"If you are using a USB Ethernet port for the first time on your computer, it's possible that your first attempt to connect will be unsuccessful. Many of these issues are resolved by disconnecting the USB briefly and trying after you have plugged everything back in. If issues persist, search online to determine whether your computer is missing a driver needed for the specific model of Ethernet adapter.","title":"Missing Network Drivers"},{"location":"assignments/pi-setup/#ssh-connection-warning","text":"At some point, you are likely to receive the following warning when trying to launch ssh . In most cases, what you are seeing is expected behavior. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! The first time you connect to a host, SSH will bind a cryptographic signature to the hostname, e.g., raspberrypi.local and store it within ~/.ssh/known_hosts . To prevent attacks, SSH warns us when the signature changes for a known host. In our case, it's likely that there is another explanation for the mismatched signature since SSH will create a new private key every time we set up or rebuild a Raspberry Pi. Since this is not an attack scenario, resolve the conflict with ssh-keygen -R raspberrypi.local , which will remove the existing entry. Missing features in Windows SSH The ssh-keygen -R feature isn't present before Windows 10 1809. If you are still running an older version of Windows, you will have to locate known_hosts within the .ssh configuration directory and remove the line indicated by the warning message.","title":"SSH Connection Warning"},{"location":"assignments/pi-setup/#permission-denied-errors","text":"When we're performing system and network administration, we are often in need of root privileges. Running an administrative command without the appropriate privileges will result in a permissions-related error. By default, the pi user is restricted in which parts of the system it can read and modify (Linux is heavily user-based in it's permissions model); however, the user is permitted to elevate itself to the admin level with sudo when it is necessary to perform privileged commands. As a general security precaution, don't sudo commands unless it's necessary. For now, we'll indicate when that's the case. In later tasks, you will need to make this determination on your own.","title":"Permission Denied Errors"},{"location":"assignments/proxy-labs/","text":"HTTP Proxy Labs \u00b6 What is a proxy? \u00b6 A proxy is a network service that receives a connection and reads data from a client, acts on it, and passes that data out to another server. The proxy will also read the server's response, act on it, and send it back to the client. This simple pattern appears frequently in networks and distributed systems and quite frequently provide The value provided by a proxy is determined by the actions it takes on the data. Here are a few applications of HTTP proxies: security (e.g., inspecting HTTP content for malware) policy enforcement (e.g., preventing employees from accessing unauthorized content at work) software development (e.g., decrypting and examining HTTPS traffic) For this sequence of assignments, we are building a proxy to log metadata about HTTP requests and responses. Project Overview \u00b6 This sequence of labs is divided into 3 parts. Create a simple TCP server that is able to parse incoming HTTP/1.0 GET requests and generate a log of requests that have been received. Extend your server so that it can parse the remaining HTTP/1.0 message types and build a new HTTP message from the fields it received. Background Material \u00b6 Application Layer Messages \u00b6 Data structure \u00b6 Application protocols follow predictable patterns to marshall more complex data into byte-oriented message structures. The following patterns are commonly used for marshalling/unmarshalling data and will be discussed briefly in lab: Delimiters Type/Length/Value Fixed length fields Text encoding \u00b6 In addition to the higher-level concern of marshalling the data structures into a stream of bytes, network applications must also define the manner in which they encode/decode between characters and byte representation. There are many different ways to encode a set of characters into bytes. These are generally grouped into single and multi-byte encodings based on the number of bytes that are required to encode each character. The most prominent single-byte encodings are ASCII and ISO-8859-1, which use 7-bits and 8-bits per character respectively. These encodings are simple to work with, but they are quite limited in the size of alphabet that they can support. The advantage of multi-byte encodings, such as those defined by the Unicode standard, is the ability to represent different languages, alphabets, and sets of symbols within the application. One of the most common encodings in modern applications is UTF-8, a variable-length encoding that provides backwards compatibility with ASCII while also supporting multi-byte encodings required for broad Unicode compatibility. For the bulk of our work on developing an HTTP proxy, we will utilize the ISO-8859-1 and ASCII encodings (per the RFCs that define the protocol). Control Characters \u00b6 As users, we're generally most concerned with the visible letters of the alphabet -- or cute symbols such as \ud83d\udca9(represented as F0 9F 92 A9 in UTF-8). As developers, we often need to pay attention to the non-printable character codes. For the sake of parsing the HTTP protocol, we will concern ourselves with various types of white space, including the CRLF (0D 0A in ASCII, ISO-8859-1, and UTF-8) sequence that is used to signify the end of a line in HTTP messages. HTTP Message Structure \u00b6 HTTP messages may be formatted as ASCII (per RFC 7230) or ISO-8859-1 (per historic RFCs). Decoding text as iso-8859-1 will allow for the maximum versatility. RFC 7230 defines the structures used to represent HTTP/1.1 requests and responses https://tools.ietf.org/html/rfc7230#section-3 . HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ] Requests \u00b6 request-line - method, URI, and protocol version [header]* empty line [message body] Responses \u00b6 status-line: protocol version, a success or error code, and textual reason phrase [header]* empty line [message body]","title":"HTTP Proxy Labs"},{"location":"assignments/proxy-labs/#http-proxy-labs","text":"","title":"HTTP Proxy Labs"},{"location":"assignments/proxy-labs/#what-is-a-proxy","text":"A proxy is a network service that receives a connection and reads data from a client, acts on it, and passes that data out to another server. The proxy will also read the server's response, act on it, and send it back to the client. This simple pattern appears frequently in networks and distributed systems and quite frequently provide The value provided by a proxy is determined by the actions it takes on the data. Here are a few applications of HTTP proxies: security (e.g., inspecting HTTP content for malware) policy enforcement (e.g., preventing employees from accessing unauthorized content at work) software development (e.g., decrypting and examining HTTPS traffic) For this sequence of assignments, we are building a proxy to log metadata about HTTP requests and responses.","title":"What is a proxy?"},{"location":"assignments/proxy-labs/#project-overview","text":"This sequence of labs is divided into 3 parts. Create a simple TCP server that is able to parse incoming HTTP/1.0 GET requests and generate a log of requests that have been received. Extend your server so that it can parse the remaining HTTP/1.0 message types and build a new HTTP message from the fields it received.","title":"Project Overview"},{"location":"assignments/proxy-labs/#background-material","text":"","title":"Background Material"},{"location":"assignments/proxy-labs/#application-layer-messages","text":"","title":"Application Layer Messages"},{"location":"assignments/proxy-labs/#data-structure","text":"Application protocols follow predictable patterns to marshall more complex data into byte-oriented message structures. The following patterns are commonly used for marshalling/unmarshalling data and will be discussed briefly in lab: Delimiters Type/Length/Value Fixed length fields","title":"Data structure"},{"location":"assignments/proxy-labs/#text-encoding","text":"In addition to the higher-level concern of marshalling the data structures into a stream of bytes, network applications must also define the manner in which they encode/decode between characters and byte representation. There are many different ways to encode a set of characters into bytes. These are generally grouped into single and multi-byte encodings based on the number of bytes that are required to encode each character. The most prominent single-byte encodings are ASCII and ISO-8859-1, which use 7-bits and 8-bits per character respectively. These encodings are simple to work with, but they are quite limited in the size of alphabet that they can support. The advantage of multi-byte encodings, such as those defined by the Unicode standard, is the ability to represent different languages, alphabets, and sets of symbols within the application. One of the most common encodings in modern applications is UTF-8, a variable-length encoding that provides backwards compatibility with ASCII while also supporting multi-byte encodings required for broad Unicode compatibility. For the bulk of our work on developing an HTTP proxy, we will utilize the ISO-8859-1 and ASCII encodings (per the RFCs that define the protocol).","title":"Text encoding"},{"location":"assignments/proxy-labs/#control-characters","text":"As users, we're generally most concerned with the visible letters of the alphabet -- or cute symbols such as \ud83d\udca9(represented as F0 9F 92 A9 in UTF-8). As developers, we often need to pay attention to the non-printable character codes. For the sake of parsing the HTTP protocol, we will concern ourselves with various types of white space, including the CRLF (0D 0A in ASCII, ISO-8859-1, and UTF-8) sequence that is used to signify the end of a line in HTTP messages.","title":"Control Characters"},{"location":"assignments/proxy-labs/#http-message-structure","text":"HTTP messages may be formatted as ASCII (per RFC 7230) or ISO-8859-1 (per historic RFCs). Decoding text as iso-8859-1 will allow for the maximum versatility. RFC 7230 defines the structures used to represent HTTP/1.1 requests and responses https://tools.ietf.org/html/rfc7230#section-3 . HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ]","title":"HTTP Message Structure"},{"location":"assignments/proxy-labs/#requests","text":"request-line - method, URI, and protocol version [header]* empty line [message body]","title":"Requests"},{"location":"assignments/proxy-labs/#responses","text":"status-line: protocol version, a success or error code, and textual reason phrase [header]* empty line [message body]","title":"Responses"},{"location":"assignments/resolver-setup/","text":"DNS Resolvers (last edited 2020-02-09) \u00b6 Overview \u00b6 In this assignment, we'll continue to extend the functionality of the Linux-based router by installing and configuring the open source BIND server to resolve DNS requests on behalf of hosts on your LAN. This new functionality will take the place of the public DNS resolvers we used in the previous assignments (e.g., 1.1.1.1 or 8.8.8.8 ). Important With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task. In this assignment, you will use an existing tutorial as a reference to help you complete the project specifications. Please note that you will not follow the tutorial verbatim, but instead make adjustments based on the project requirements. For some students, this can be a challenging adjustment, but it is also a valuable skill to learn and practice as you prepare for technical internships and jobs. Before you start \u00b6 Before you begin, make sure that you have completed all steps through Checkpoint #3 successfully. At this point, your Pi should operate as a NAT-router between the Ethernet LAN and a Wifi-based WAN. Likewise, DHCP is configured to provide LAN clients with a full network configuration, including a default gateway and a public DNS resolver. At times in this project, you will need to refer back to the configuration you defined in the previous LAN Planning Exercise . Instructions \u00b6 Review/Update your IP Address Plan \u00b6 Since we will be running our DNS resolver inside our LAN, we will need to provide it with an IP address on eth0 . Choose an unused static address from the ranges you defined in your initial LAN Planning. Before you can assign this address to a service, you will need to add another Address= line to your eth0 configuration in systemd-networkd . Further instructions were provided in Checkpoint #2 . While it may not be clear at this point, there are sometimes benefits to using separate addresses for diffferent services (in real-world scenarios) even though they're all running on the same device and network interface. The first benefit that comes to my mind is that planning for multiple addresses sets you up for easy changes to your network architecture in the future. It might make sense to combine all of these services onto one device today, but that might not always be the case depending on your requirements. Install BIND on the router \u00b6 BIND (also refered to as named ) is a robust and versatile DNS implementation developed by the Internet Services Consortium (ISC) -- the same folks that developed the DHCP server implementation we have deployed. The first version of BIND was released in 1986. At present, BIND 9 is the most widely deployed DNS server on the Internet. BIND and related utilities are packaged in the Debian/Raspbian software repositories, meaning that they can be installed and managed easily with the apt utilities that we are already familiar with. For our purposes, we want to install three different packages named bind9 , bind9utils , bind9-doc . Please refer to previous guides if you need to review the options for the apt command. Configure BIND as a caching DNS server \u00b6 The term DNS server can refer to several distinct roles that are defined in the DNS specifications 1 . BIND can be configured to operate in all of these roles, but in this checkpoint, we want to configure the service to handle recursive DNS resolution for our LAN clients. Until now, our clients relied on public DNS services. To accomplish this objective, refer to the section of Digital Ocean's tutorial 2 , which demonstrates how to set up a caching DNS server (be sure to stop after this section) and the notes below. You will need to make several adjustments to the configuration you created based on DO's guidance: Confirm that you have adapted the instructions to use your own IP address ranges. Disable IPv6 by changing listen-on-v6 { any; }; to listen-on-v6 { none; }; . Limit which IPv4 addresses will be listening for DNS queries by setting listen-on { 127.0.0.1; <DNS IP>; } . <DNS IP> will be replaced by the static IP on which you want to respond to DNS requests If the listen-on block is missing from the original file, you can add it immediately before or after listen-on-v6 . 127.0.0.1 is the loopback address. We're including this for times that your Pi will query its own resolver. Restrict the acl to include localhost and your own subnet range (CIDR format) If you added localnets while following the tutorial, remove it now. This setting would allow the resolver to be accessed on the external (wireless network) as well as your LAN. If you're curious to learn more about this security precaution, read up on Cache Poisoning Attacks or hit us up in office hours. Disable DNSSEC functionality by replacing the configuration line that reads dnssec-validation auto; with dnssec-enable no; . Disabling DNSSEC is necessary due to the limitations of using a Pi versus an always on network server. Specifically, the inability of the Pi to maintain accurate time when it is powered off interferes with the verification process for DNSSEC cryptographic signatures Test and verify that the new server is operating properly \u00b6 In addition to the troubleshooting tools that we're already familiar with. BIND comes with a utility called named-checkconf that will review its core configuration files for syntax errors. You should run it any time you modify the BIND configuration in this assignment or future checkpoints. Why didn't named-checkconf do anything If it doesn't find any syntax errors in your configuration files, named-checkconf will return without displaying any messages. To see what sort of errors are reported by the utility, create an intentional syntax error and run the tool again. Once your files are free of errors, use systemctl to restart the bind9 service and check that it's working with dig , e.g., dig @127.0.0.1 washington.edu . As we've discussed in other places, the @IP syntax of dig is used to override local resolver settings (which are still determined by DHCP on the wifi network). Update your DHCP Server Configuration \u00b6 To wrap up this project, you will need to update the DHCP server configuration so that LAN users will receive the address for the local resolver instead of the public resolver we previously used: Update DHCP server configuration so that your Pi will be used as the domain name server for the LAN Use systemctl to restart the DHCP server daemon Manually renew your DHCP configuration on your PC through the OS or by temporarily disconnecting the network cable Verify that your computer receives the updated parameters from DHCP See A Comparison of DNS Server Types \u21a9 See How to Configure Bind as a Caching or Forwarding DNS Server \u21a9","title":"DNS Resolvers (last edited 2020-02-09)"},{"location":"assignments/resolver-setup/#dns-resolvers-last-edited-2020-02-09","text":"","title":"DNS Resolvers (last edited 2020-02-09)"},{"location":"assignments/resolver-setup/#overview","text":"In this assignment, we'll continue to extend the functionality of the Linux-based router by installing and configuring the open source BIND server to resolve DNS requests on behalf of hosts on your LAN. This new functionality will take the place of the public DNS resolvers we used in the previous assignments (e.g., 1.1.1.1 or 8.8.8.8 ). Important With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task. In this assignment, you will use an existing tutorial as a reference to help you complete the project specifications. Please note that you will not follow the tutorial verbatim, but instead make adjustments based on the project requirements. For some students, this can be a challenging adjustment, but it is also a valuable skill to learn and practice as you prepare for technical internships and jobs.","title":"Overview"},{"location":"assignments/resolver-setup/#before-you-start","text":"Before you begin, make sure that you have completed all steps through Checkpoint #3 successfully. At this point, your Pi should operate as a NAT-router between the Ethernet LAN and a Wifi-based WAN. Likewise, DHCP is configured to provide LAN clients with a full network configuration, including a default gateway and a public DNS resolver. At times in this project, you will need to refer back to the configuration you defined in the previous LAN Planning Exercise .","title":"Before you start"},{"location":"assignments/resolver-setup/#instructions","text":"","title":"Instructions"},{"location":"assignments/resolver-setup/#reviewupdate-your-ip-address-plan","text":"Since we will be running our DNS resolver inside our LAN, we will need to provide it with an IP address on eth0 . Choose an unused static address from the ranges you defined in your initial LAN Planning. Before you can assign this address to a service, you will need to add another Address= line to your eth0 configuration in systemd-networkd . Further instructions were provided in Checkpoint #2 . While it may not be clear at this point, there are sometimes benefits to using separate addresses for diffferent services (in real-world scenarios) even though they're all running on the same device and network interface. The first benefit that comes to my mind is that planning for multiple addresses sets you up for easy changes to your network architecture in the future. It might make sense to combine all of these services onto one device today, but that might not always be the case depending on your requirements.","title":"Review/Update your IP Address Plan"},{"location":"assignments/resolver-setup/#install-bind-on-the-router","text":"BIND (also refered to as named ) is a robust and versatile DNS implementation developed by the Internet Services Consortium (ISC) -- the same folks that developed the DHCP server implementation we have deployed. The first version of BIND was released in 1986. At present, BIND 9 is the most widely deployed DNS server on the Internet. BIND and related utilities are packaged in the Debian/Raspbian software repositories, meaning that they can be installed and managed easily with the apt utilities that we are already familiar with. For our purposes, we want to install three different packages named bind9 , bind9utils , bind9-doc . Please refer to previous guides if you need to review the options for the apt command.","title":"Install BIND on the router"},{"location":"assignments/resolver-setup/#configure-bind-as-a-caching-dns-server","text":"The term DNS server can refer to several distinct roles that are defined in the DNS specifications 1 . BIND can be configured to operate in all of these roles, but in this checkpoint, we want to configure the service to handle recursive DNS resolution for our LAN clients. Until now, our clients relied on public DNS services. To accomplish this objective, refer to the section of Digital Ocean's tutorial 2 , which demonstrates how to set up a caching DNS server (be sure to stop after this section) and the notes below. You will need to make several adjustments to the configuration you created based on DO's guidance: Confirm that you have adapted the instructions to use your own IP address ranges. Disable IPv6 by changing listen-on-v6 { any; }; to listen-on-v6 { none; }; . Limit which IPv4 addresses will be listening for DNS queries by setting listen-on { 127.0.0.1; <DNS IP>; } . <DNS IP> will be replaced by the static IP on which you want to respond to DNS requests If the listen-on block is missing from the original file, you can add it immediately before or after listen-on-v6 . 127.0.0.1 is the loopback address. We're including this for times that your Pi will query its own resolver. Restrict the acl to include localhost and your own subnet range (CIDR format) If you added localnets while following the tutorial, remove it now. This setting would allow the resolver to be accessed on the external (wireless network) as well as your LAN. If you're curious to learn more about this security precaution, read up on Cache Poisoning Attacks or hit us up in office hours. Disable DNSSEC functionality by replacing the configuration line that reads dnssec-validation auto; with dnssec-enable no; . Disabling DNSSEC is necessary due to the limitations of using a Pi versus an always on network server. Specifically, the inability of the Pi to maintain accurate time when it is powered off interferes with the verification process for DNSSEC cryptographic signatures","title":"Configure BIND as a caching DNS server"},{"location":"assignments/resolver-setup/#test-and-verify-that-the-new-server-is-operating-properly","text":"In addition to the troubleshooting tools that we're already familiar with. BIND comes with a utility called named-checkconf that will review its core configuration files for syntax errors. You should run it any time you modify the BIND configuration in this assignment or future checkpoints. Why didn't named-checkconf do anything If it doesn't find any syntax errors in your configuration files, named-checkconf will return without displaying any messages. To see what sort of errors are reported by the utility, create an intentional syntax error and run the tool again. Once your files are free of errors, use systemctl to restart the bind9 service and check that it's working with dig , e.g., dig @127.0.0.1 washington.edu . As we've discussed in other places, the @IP syntax of dig is used to override local resolver settings (which are still determined by DHCP on the wifi network).","title":"Test and verify that the new server is operating properly"},{"location":"assignments/resolver-setup/#update-your-dhcp-server-configuration","text":"To wrap up this project, you will need to update the DHCP server configuration so that LAN users will receive the address for the local resolver instead of the public resolver we previously used: Update DHCP server configuration so that your Pi will be used as the domain name server for the LAN Use systemctl to restart the DHCP server daemon Manually renew your DHCP configuration on your PC through the OS or by temporarily disconnecting the network cable Verify that your computer receives the updated parameters from DHCP See A Comparison of DNS Server Types \u21a9 See How to Configure Bind as a Caching or Forwarding DNS Server \u21a9","title":"Update your DHCP Server Configuration"},{"location":"assignments/router-setup/","text":"Build a NAT - enabled Router \u00b6 Overview \u00b6 This assignment builds on the DHCP server functionality you set up in the previous project. Follow the instructions provided here to set up NAT and enable packet forwarding on your Pi. At the end of the project, you will have a working network gateway. Note With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task. Before you Start \u00b6 Before you begin, make sure that you have completed all steps from Checkpoints #1 and #2 successfully. By now, your pi should be able to connect to the Internet via wireless, and it should provide DHCP services via a pre-defined address range on the ethernet-based LAN. At times in this project, you will need to refer back to the configuration you defined in the previous LAN Planning Exercise . Objectives \u00b6 In this assignment, you will be configuring the Pi as a simple Internet gateway that routes traffic between an isolated, wired LAN and an Internet-connected wireless network. Practically speaking, you'll be tethering your computer to the Pi and using it to access the rest of the Internet. Whether it is immediately obvious or not, this architecture has practical applications. It is not always a good idea to connect your computer directly to an untrusted network. With a few more components, the Pi provides a simple firewall that can protect against many types of threats. Further, the Pi can be used to tunnel your traffic through a personal VPN, ensuring that that it cannot be intercepted or tampered with on a public network or local ISP. Project outline \u00b6 The main steps of this project are listed below: Configure basic firewall rules and NAT Enable packet forwarding settings within Raspbian Update DHCP to provide gateway and DNS settings Test and troubleshoot your configuration What is NAT \u00b6 The hosts in our network use RFC-1918 addresses, which are restricted to private networks and cannot be used as a source or destination for addresses on packets being sent over the Internet. We'll address this problem with network address translation (NAT), which will allow your Pi to communicate on the Internet by masquerading with the public address assigned to the WAN port of the router. This setup is a special case of source NAT (SNAT) in that many private IP addresses will be mapped to one public address on the external interface. To accommodate, the Pi will need to monitor the state of each connection and other network traffic so that it can route to the correct host on the internal network when incoming traffic is received. Configuring NAT \u00b6 NAT functionality is supported natively in Linux through the netfilter firewall . We'll use a common Linux tool known as iptables to manage this mechanism. Iptables defines rules in a hierarchical structure that are used to filter and manipulate packets. Attention Throughout the instructions, we'll refer to the wired interface as <LAN> (because it serves our local network) and the wireless interface as the <WAN> (because it connects us to the Internet). Your configuration files will reflect the Raspbian-assigned interface names, such as: eth0 and wlan0. We have prepared an iptables tutorial that focuses specifically on the features that are required to implement NAT. Read this tutorial first, and then use it as a reference to fill in the missing values in the starter template (which is included at the ended of the tutorial). Copy/Paste Warning This template has missing values that you must define before trying to load on your Pi. Rule Specification \u00b6 The included template provides most of what is needed to establish a basic NAT configuration. Save a copy of this template in the home directory of your pi and fill in the missing values so that the final ruleset complies with the listed requirements: Append a new rule to the POSTROUTING chain that masquerades outbound packets on the WAN interface. Set the default policy for the FORWARD chain of the filter table to drop all packets. Create a rule to forward all outbound packets. Create a rule to forward inbound packets if they are related to previous packets or already established connections. While best practice would have us further configure the firewalls for the internal and external interfaces on the Raspberry Pi, we will save this step for a future assignment. Testing and Applying Rules \u00b6 After you finish filling out the missing values in the reference template according to the above specifications, you should follow the instructions in the provided tutorial to set up your rules to be loaded persistently. Note You will not be able to completely test your rules until you complete the upcoming steps. What you should ensure at this point is that the rules are applied and that you are not locked out of the Pi. Enable Packet Forwarding \u00b6 Once you are confident that you have set up NAT and filtering properly within iptables, you need to instruct the Linux kernel to begin forwarding packets. You can enable the setting temporarily from the command line by calling sudo sysctl -w net.ipv4.ip_forward=1 , but it will not persist across reboots. Make this change persistent inside /etc/sysctl.d/99-sysctl.conf by setting net.ipv4.ip_forward=1 (the rule is already included in the file but commented out). Update DHCP Configuration \u00b6 Update the DHCP configuration written in the previous assignment to provide clients with settings for a default router and a public DNS resolver (called domain name servers in isc-dhcp-server ). Use the examples provided in the default dhcpd.conf as the basis for your changes. You will need to restart isc-dhcp-server in order to load the new configuration. Renew your DHCP lease by temporarily disconnecting Ethernet or following instructions provided in the resources section of this site. Test your Configuration \u00b6 Once you have completed these changes, you should be able to access external networks by way of the Raspberry Pi. Disable other network interfaces so that the Pi is your only route to the Internet. Try connecting to a well-known website from your browser. From the command line (your laptop), run a traceroute ( tracert on Windows) to confirm that your Pi is the first hop of this route. Troubleshooting \u00b6 If you run into problems here, there are a few points to check. First, try to ping a known address such as 1.1.1.1 from your computer. This will tell you whether or not you have connectivity outside your network. If you're at UW, try pinging 128.95.112.1, to determine whether you can access hosts on campus. You may also try pinging a known domain name like amazon.com (and washington.edu if you're on campus). If you can't ping anything, you may have an issue with the network configuration on your computer. Try pinging the static address you created for the Pi. If this fails with no route to host, go back and make sure you set up the Pi and your computer correctly. If you can ping by IP address, but not name, you have an issue with DNS. Verify that DHCP is providing a valid name server address. If you're able to ping your Pi by it's IP and you're certain that you've set up your local network correctly, go back and confirm that the Pi has forwarding enabled for IP and that your iptables rules are loading.","title":"Build a NAT - enabled Router"},{"location":"assignments/router-setup/#build-a-nat-enabled-router","text":"","title":"Build a NAT - enabled Router"},{"location":"assignments/router-setup/#overview","text":"This assignment builds on the DHCP server functionality you set up in the previous project. Follow the instructions provided here to set up NAT and enable packet forwarding on your Pi. At the end of the project, you will have a working network gateway. Note With each checkpoint, we expect you to do more of the work on your own. While the initial Pi setup gave clear instructions, we are slowly moving toward giving you specifications and additional context that you need in order to determine the right steps to accomplish the task.","title":"Overview"},{"location":"assignments/router-setup/#before-you-start","text":"Before you begin, make sure that you have completed all steps from Checkpoints #1 and #2 successfully. By now, your pi should be able to connect to the Internet via wireless, and it should provide DHCP services via a pre-defined address range on the ethernet-based LAN. At times in this project, you will need to refer back to the configuration you defined in the previous LAN Planning Exercise .","title":"Before you Start"},{"location":"assignments/router-setup/#objectives","text":"In this assignment, you will be configuring the Pi as a simple Internet gateway that routes traffic between an isolated, wired LAN and an Internet-connected wireless network. Practically speaking, you'll be tethering your computer to the Pi and using it to access the rest of the Internet. Whether it is immediately obvious or not, this architecture has practical applications. It is not always a good idea to connect your computer directly to an untrusted network. With a few more components, the Pi provides a simple firewall that can protect against many types of threats. Further, the Pi can be used to tunnel your traffic through a personal VPN, ensuring that that it cannot be intercepted or tampered with on a public network or local ISP.","title":"Objectives"},{"location":"assignments/router-setup/#project-outline","text":"The main steps of this project are listed below: Configure basic firewall rules and NAT Enable packet forwarding settings within Raspbian Update DHCP to provide gateway and DNS settings Test and troubleshoot your configuration","title":"Project outline"},{"location":"assignments/router-setup/#what-is-nat","text":"The hosts in our network use RFC-1918 addresses, which are restricted to private networks and cannot be used as a source or destination for addresses on packets being sent over the Internet. We'll address this problem with network address translation (NAT), which will allow your Pi to communicate on the Internet by masquerading with the public address assigned to the WAN port of the router. This setup is a special case of source NAT (SNAT) in that many private IP addresses will be mapped to one public address on the external interface. To accommodate, the Pi will need to monitor the state of each connection and other network traffic so that it can route to the correct host on the internal network when incoming traffic is received.","title":"What is NAT"},{"location":"assignments/router-setup/#configuring-nat","text":"NAT functionality is supported natively in Linux through the netfilter firewall . We'll use a common Linux tool known as iptables to manage this mechanism. Iptables defines rules in a hierarchical structure that are used to filter and manipulate packets. Attention Throughout the instructions, we'll refer to the wired interface as <LAN> (because it serves our local network) and the wireless interface as the <WAN> (because it connects us to the Internet). Your configuration files will reflect the Raspbian-assigned interface names, such as: eth0 and wlan0. We have prepared an iptables tutorial that focuses specifically on the features that are required to implement NAT. Read this tutorial first, and then use it as a reference to fill in the missing values in the starter template (which is included at the ended of the tutorial). Copy/Paste Warning This template has missing values that you must define before trying to load on your Pi.","title":"Configuring NAT"},{"location":"assignments/router-setup/#rule-specification","text":"The included template provides most of what is needed to establish a basic NAT configuration. Save a copy of this template in the home directory of your pi and fill in the missing values so that the final ruleset complies with the listed requirements: Append a new rule to the POSTROUTING chain that masquerades outbound packets on the WAN interface. Set the default policy for the FORWARD chain of the filter table to drop all packets. Create a rule to forward all outbound packets. Create a rule to forward inbound packets if they are related to previous packets or already established connections. While best practice would have us further configure the firewalls for the internal and external interfaces on the Raspberry Pi, we will save this step for a future assignment.","title":"Rule Specification"},{"location":"assignments/router-setup/#testing-and-applying-rules","text":"After you finish filling out the missing values in the reference template according to the above specifications, you should follow the instructions in the provided tutorial to set up your rules to be loaded persistently. Note You will not be able to completely test your rules until you complete the upcoming steps. What you should ensure at this point is that the rules are applied and that you are not locked out of the Pi.","title":"Testing and Applying Rules"},{"location":"assignments/router-setup/#enable-packet-forwarding","text":"Once you are confident that you have set up NAT and filtering properly within iptables, you need to instruct the Linux kernel to begin forwarding packets. You can enable the setting temporarily from the command line by calling sudo sysctl -w net.ipv4.ip_forward=1 , but it will not persist across reboots. Make this change persistent inside /etc/sysctl.d/99-sysctl.conf by setting net.ipv4.ip_forward=1 (the rule is already included in the file but commented out).","title":"Enable Packet Forwarding"},{"location":"assignments/router-setup/#update-dhcp-configuration","text":"Update the DHCP configuration written in the previous assignment to provide clients with settings for a default router and a public DNS resolver (called domain name servers in isc-dhcp-server ). Use the examples provided in the default dhcpd.conf as the basis for your changes. You will need to restart isc-dhcp-server in order to load the new configuration. Renew your DHCP lease by temporarily disconnecting Ethernet or following instructions provided in the resources section of this site.","title":"Update DHCP Configuration"},{"location":"assignments/router-setup/#test-your-configuration","text":"Once you have completed these changes, you should be able to access external networks by way of the Raspberry Pi. Disable other network interfaces so that the Pi is your only route to the Internet. Try connecting to a well-known website from your browser. From the command line (your laptop), run a traceroute ( tracert on Windows) to confirm that your Pi is the first hop of this route.","title":"Test your Configuration"},{"location":"assignments/router-setup/#troubleshooting","text":"If you run into problems here, there are a few points to check. First, try to ping a known address such as 1.1.1.1 from your computer. This will tell you whether or not you have connectivity outside your network. If you're at UW, try pinging 128.95.112.1, to determine whether you can access hosts on campus. You may also try pinging a known domain name like amazon.com (and washington.edu if you're on campus). If you can't ping anything, you may have an issue with the network configuration on your computer. Try pinging the static address you created for the Pi. If this fails with no route to host, go back and make sure you set up the Pi and your computer correctly. If you can ping by IP address, but not name, you have an issue with DNS. Verify that DHCP is providing a valid name server address. If you're able to ping your Pi by it's IP and you're certain that you've set up your local network correctly, go back and confirm that the Pi has forwarding enabled for IP and that your iptables rules are loading.","title":"Troubleshooting"},{"location":"assignments/vlan-challenge/","text":"VLAN Challenge (last edited 2020-02-06) \u00b6 Overview \u00b6 The objective of this assignment is to determine a VLAN strategy and port configuration that overlays the given routing topology onto a managed 8-port switch. The routing topology that you will be working with in this challenge is representative of the topology used in our final, group project. In this topology, we have three autonomous systems, i.e., networks that are managed independently from one another. Each of our three routers serves a group of local users via a LAN segment in addition to being connected to external networks via point-to-point routing links. The network positioned at the top of the diagram will function as an Internet Service Provider (ISP) for the other networks networks, routing traffic between them and other groups within the class. The links between routers are known as routing links. Each one represents a separate point-to-point network over which the routers will forward messages and share information about the inter-network topology. Instructions \u00b6 Identify broadcast domains \u00b6 Identify the distinct broadcast domains in the system and assign a different VLAN label (between 2 and 4094) to each of these network segments. Define physical connections \u00b6 Assign each physical connection to a port on the switch. Since the topology is determined by port configuration, you will need to keep track of which device and network interface is associated with each port. Choose an order that is easy to remember. Create port configurations \u00b6 Once you have identified the VLANs and mapped ports to physical topology, you can begin to define the port configurations. For each port, you will define a native VLAN (untagged) and zero or more tagged VLANs. A port can have both types of VLANs associated with it, though there can only be one native VLAN configured for any port. Untagged ethernet frames received on a port will be mapped internally to the native VLAN of the port and can only be forwarded (or flooded) through links attached to ports that are configured with the same VLAN (tagged or untagged). When a VLAN is configured to be tagged on a specific port, that port will add a VLAN identifier to outgoing frames and read/remove the identifiers from incoming frames. Adding a tagged VLAN to a port creates a trunk. Trunk links expect the same tag configuration on both ends of the link, i.e., they require explicit configuration on both sides of the trunk. Ports without any tagged VLANs are called access ports. These are preferred for most applications since the VLAN configuration will be encapsulated within the switch and transparent to users. LAN connections \u00b6 For simplicity, start the process by defining the port configurations for a single broadcast domain associated with one of the LANs in the topology, e.g., LAN A. Pay close attention to the requirements given in the next section, which state that LAN connections to A, B, and C should be accessible without tagging. Routing links \u00b6 Once you have completed the configuration for independent LANs, turn your attention to the routing links between the LANs. Update the configuration for each side of the routing link (two physical ports) with the appropriate VLAN configurations. Uplink \u00b6 Finally, turn your attention to the connection that forms the uplink to the core network for the class. The uplink is a routing link, and it is configured in much the same manner as the other routing links in our topology. However, pay close attention to the assignment specifications and the implications for the final port configuration. Specifications \u00b6 In addition to the following the given network layer topology, please align your VLAN strategy with requirements below: Layer-3 Network Diagram Example Physical Diagram Access links to general LANs \u00b6 LANs A, B, and C are general purpose networks and should be exposed as untagged VLANs. This enables us to alternate seamlessly between a direct connect from our laptop to Pi and a connection that runs through the switch. If we were to rely on tagged VLANs to access a given LAN, you would need to configure VLANs on your laptop in order to connect directly to the Pi. Tagged Routing Links \u00b6 Routing links may rely on tagged VLANs. The router will connect to these VLANs via virtual network interfaces that are configured to exchange tagged Ethernet traffic rather than standard, untagged frames. The router side of this configuration is beyond the scope of this exercise. Untagged Uplink Connection \u00b6 The remote end of the uplink connection will be untagged. Make sure that you configure the associated port accordingly. Eliminate Extraneous Connections \u00b6 For each port, only expose the VLANs that are necessary to satisfy the routing requirements indicated in the diagram. Adding additional VLANs creates unintended paths for communication, e.g., allowing Laptop A to communicate directly with Laptop B. For the purposes of this assignment, treat this sort of unintended pathway as a security exposure.","title":"VLAN Challenge (last edited 2020-02-06)"},{"location":"assignments/vlan-challenge/#vlan-challenge-last-edited-2020-02-06","text":"","title":"VLAN Challenge (last edited 2020-02-06)"},{"location":"assignments/vlan-challenge/#overview","text":"The objective of this assignment is to determine a VLAN strategy and port configuration that overlays the given routing topology onto a managed 8-port switch. The routing topology that you will be working with in this challenge is representative of the topology used in our final, group project. In this topology, we have three autonomous systems, i.e., networks that are managed independently from one another. Each of our three routers serves a group of local users via a LAN segment in addition to being connected to external networks via point-to-point routing links. The network positioned at the top of the diagram will function as an Internet Service Provider (ISP) for the other networks networks, routing traffic between them and other groups within the class. The links between routers are known as routing links. Each one represents a separate point-to-point network over which the routers will forward messages and share information about the inter-network topology.","title":"Overview"},{"location":"assignments/vlan-challenge/#instructions","text":"","title":"Instructions"},{"location":"assignments/vlan-challenge/#identify-broadcast-domains","text":"Identify the distinct broadcast domains in the system and assign a different VLAN label (between 2 and 4094) to each of these network segments.","title":"Identify broadcast domains"},{"location":"assignments/vlan-challenge/#define-physical-connections","text":"Assign each physical connection to a port on the switch. Since the topology is determined by port configuration, you will need to keep track of which device and network interface is associated with each port. Choose an order that is easy to remember.","title":"Define physical connections"},{"location":"assignments/vlan-challenge/#create-port-configurations","text":"Once you have identified the VLANs and mapped ports to physical topology, you can begin to define the port configurations. For each port, you will define a native VLAN (untagged) and zero or more tagged VLANs. A port can have both types of VLANs associated with it, though there can only be one native VLAN configured for any port. Untagged ethernet frames received on a port will be mapped internally to the native VLAN of the port and can only be forwarded (or flooded) through links attached to ports that are configured with the same VLAN (tagged or untagged). When a VLAN is configured to be tagged on a specific port, that port will add a VLAN identifier to outgoing frames and read/remove the identifiers from incoming frames. Adding a tagged VLAN to a port creates a trunk. Trunk links expect the same tag configuration on both ends of the link, i.e., they require explicit configuration on both sides of the trunk. Ports without any tagged VLANs are called access ports. These are preferred for most applications since the VLAN configuration will be encapsulated within the switch and transparent to users.","title":"Create port configurations"},{"location":"assignments/vlan-challenge/#lan-connections","text":"For simplicity, start the process by defining the port configurations for a single broadcast domain associated with one of the LANs in the topology, e.g., LAN A. Pay close attention to the requirements given in the next section, which state that LAN connections to A, B, and C should be accessible without tagging.","title":"LAN connections"},{"location":"assignments/vlan-challenge/#routing-links","text":"Once you have completed the configuration for independent LANs, turn your attention to the routing links between the LANs. Update the configuration for each side of the routing link (two physical ports) with the appropriate VLAN configurations.","title":"Routing links"},{"location":"assignments/vlan-challenge/#uplink","text":"Finally, turn your attention to the connection that forms the uplink to the core network for the class. The uplink is a routing link, and it is configured in much the same manner as the other routing links in our topology. However, pay close attention to the assignment specifications and the implications for the final port configuration.","title":"Uplink"},{"location":"assignments/vlan-challenge/#specifications","text":"In addition to the following the given network layer topology, please align your VLAN strategy with requirements below: Layer-3 Network Diagram Example Physical Diagram","title":"Specifications"},{"location":"assignments/vlan-challenge/#access-links-to-general-lans","text":"LANs A, B, and C are general purpose networks and should be exposed as untagged VLANs. This enables us to alternate seamlessly between a direct connect from our laptop to Pi and a connection that runs through the switch. If we were to rely on tagged VLANs to access a given LAN, you would need to configure VLANs on your laptop in order to connect directly to the Pi.","title":"Access links to general LANs"},{"location":"assignments/vlan-challenge/#tagged-routing-links","text":"Routing links may rely on tagged VLANs. The router will connect to these VLANs via virtual network interfaces that are configured to exchange tagged Ethernet traffic rather than standard, untagged frames. The router side of this configuration is beyond the scope of this exercise.","title":"Tagged Routing Links"},{"location":"assignments/vlan-challenge/#untagged-uplink-connection","text":"The remote end of the uplink connection will be untagged. Make sure that you configure the associated port accordingly.","title":"Untagged Uplink Connection"},{"location":"assignments/vlan-challenge/#eliminate-extraneous-connections","text":"For each port, only expose the VLANs that are necessary to satisfy the routing requirements indicated in the diagram. Adding additional VLANs creates unintended paths for communication, e.g., allowing Laptop A to communicate directly with Laptop B. For the purposes of this assignment, treat this sort of unintended pathway as a security exposure.","title":"Eliminate Extraneous Connections"},{"location":"notes/dns-overview/","text":"Domain Name System \u00b6 Overview \u00b6 The domain name system (DNS) is a distributed, hierarchical data store and name resolution service that is used primarily to resolve IP addresses based on much more user-friendly domain names. DNS is a powerful and rather complex system that plays a variety of crucial roles in modern systems and applications. It is so central to these systems that any degradation of service will severely impact the usability of a network-connected computer or mobile device (e.g., resulting in extremely slow boot and application launch times). Our objective is to gain a functional understanding of the system, which we can apply broadly to our work in other areas of the informatics domain. The following videos provide a highly accessible starting point. Pieter Explains Tech https://www.youtube.com/watch?v=GlZC4Jwf3xQ Khan Academy https://www.khanacademy.org/computing/computer-science/internet-intro/internet-works-intro/v/the-internet-ip-addresses-and-dns DNS Namespace and Zones \u00b6 As you've seen, domain names are structured in a hierarchical manner that reflects the decentralized nature of the domain name system. The DNS namespace can be represented by a tree, with branches descending from a common root. A fully-qualified domain name (FQDN) is written by concatenating labels from left-to-right, tracing the path from a leaf node to the root by way of the parent nodes. A trailing dot, representative of the root, is appended to the FQDN for DNS operations though it is omitted in most user-facing applications. Below the root, the top-most level of the graph represents top-level domains (TLD), such as com, net, and edu, that appear at the end of every FQDN. IANA and its parent organization ICANN oversee the governance of the DNS root and top-level domains, though it delegates registration functions and operation of root and TLD name servers to independent organizations. Names appearing as children of each TLD are assigned to organizations through the domain registration process. An organization registers a domain name by working with an ICANN-accredited registrar or a reseller subcontracted by an accredited registrar. https://whois.icann.org/en/domain-name-registration-process Further subdivisions of the registered namespace can be created by the registrant. These subdomains appear as children of the registrant domains in the DNS tree described previously. DNS Zones \u00b6 The hierarchical structure of DNS lends to dividing administrative responsibility of the global namespace. The term \"zone\" refers to these administrative divisions. Each zone in DNS is a contiguous portion of the namespace under the administrative responsibility of a single manager. While zones are often aligned with individual domain registrations, the relationship is not one-to-one. A zone may include multiple domains. Likewise, a domain may be divided into additional zones encapsulating distinct subtrees. The root zone database is managed by IANA and contains the authority records for the TLDs. Likewise, IANA assigns operators for the TLDs. These operators maintain the authoritative database of all domain names and authority records registered in the TLD. These databases are referred to as the DNS registries and can be queried to identify the authoritative nameservers for child zones. DNS Name Servers \u00b6 Each zone, including the root, is hosted by one or more name servers that store collection of resource records associated with the corresponding subset of the DNS namespace. The primary service of root name servers and TLD name servers is to provide information about where to query the next level of the namespace. Roots point to TLD name servers and TLDs point to authoritative name servers for second-level domains. The primary records served by these servers are NS records along with A/AAAA glue records that identify the IP addresses for the provided servers. Likewise, the root and TLD servers distribute records related to DNS Security (DNSSEC) mechanisms. In addition to the root servers and TLD servers described above, resource records for each zone are hosted by at least one authoritative name server. These authoritative name servers may be hosted by the registrant itself or by a third-party DNS hosting service. Many organizations maintain internal, private zones serving records that are only available within well-defined network boundaries. Not all name servers are authoritative for a zone. Plenty of servers are created to satisfy service requirements for performance, redundancy, or security. Recursive name servers are used by clients to resolve DNS requests without having to perform iterative queries of root, TLD, and registrant name servers. When a recursive name server receives a query that it cannot resolve independently, it queries the upper-level zones to find the answer that it returns to the original client. This process can be sped up significantly by caching results, though care must be observed to prevent serving stale records from a cache. https://www.lifewire.com/dns-root-name-servers-3971336 https://www.iana.org/domains/root/servers http://root-servers.org Redundancy and Reliability \u00b6 The modern internet is heavily dependent on DNS, so much so that DNS disruptions and failures can take businesses and users offline. Even seemingly minor performance issues can multiply and cause noticeable delays for networking operations. To combat these issues, many DNS service providers rely heavily on IPv4/v6 Anycast to ensure that a fleet of servers are available to answer queries. These service providers leverage BGP, the dynamic routing protocol of the Internet to assign the same IP address, e.g., 1.1.1.1, to each of their servers scattered around the world. Each DNS request that passes through the Internet will be routed to exactly one of these servers, typically the server that is closest to the sender. http://dyn.com/blog/unicast-vs-anycast-dns-nameserver-routing/ http://blog.catchpoint.com/2015/06/16/dns-anycast/ Protocol \u00b6 As the prior sections have suggested, the DNS protocol is a query response protocol that is used to resolve IP addresses and other metadata stored in resource records based on DNS names. The protocol can be run atop both UDP and TCP for transport and uses port 53 in both cases. Basic DNS queries are most likely to be served over UDP, as this protocol provides the most efficient transport mechanism by avoiding the multi-round trip cost associated with the TCP handshake. The connection-oriented TCP protocol is most likely to be used for responses over 512 bytes to ensure that the message fits in a single datagram. Zone transfers used to transfer domain information between primary and secondary name servers are a common example of TCP-based DNS transactions. The DNS protocol itself is unicast, though a multicast version (mDNS) has been defined to support communication on local networks without the need for supporting infrastructure. Multicast DNS is served on port 5353 of the 224.0.0.251 multicast address. The mDNS protocol was popularized by Apple under the Bonjour trademark, but it has more recently made its way into the most popular mobile and desktop operating systems by way of zeroconf initiatives. Common Resource Record (RR) Types \u00b6 DNS-related RFCs define many different record types for general use and specific applications. We address the most common records here: Start of Authority (SOA) records identify the primary name server and administrator responsible for a given zone as well as version information and base parameters that impact communication between servers in a zone and caching of records related to the zone. Name Server (NS) records indicate which name servers are authoritative for a given zone. These records are also accompanied by so-called glue records that store the IP addresses associated with the server name stored in an NS. Address (A) records are among the most familiar DNS records. Their role is simple in that they associate the IPv4 address of a resource with the server's name. Address records are structured for forward lookup, i.e., resolving the address given the name. A similar, yet separate address record (AAAA) is defined to support IPv6-related queries. Canonical Name (CNAME) records are used to set aliases for existing DNS names rather than directly associating a name with an IP address. These records are commonly used when a resource is hosted by an organization other than the registrant itself and to avoid the necessity of maintaining static IP addresses for these resources. The hostname of a web site that runs on a service like SquareSpace or Wix is likely to point to a CNAME alias that can be resolved to an IP within the parent (service-provider's) domain. Text (TXT) records store additional information required by other protocols. Quite often, TXT records are created to demonstrate ownership of a certain namespace. This action is required, e.g., when attaching a private domain to a hosted service such as Office 365 or GSuite mail. TXT records are also used to store Sender Policy Framework (SPF) records leveraged by SMTP servers to combat email spam. Mail Exchange (MX) records point to SMTP servers for a domain, enabling other SMTP servers to locate and route mail between domains. Each MX record contains the FQDN for a mail host. An associated A (or AAAA) record must exist to resolve the hostname to an IP address. The MX record also contains a preference field, which is used to determine priority among multiple MX records. It is quite common to provide multiple MX records to balance load between mail servers and gain redundancy. Servers with smaller preference values are tried first, while clients are expected to choose randomly between servers with equal preference. The MX record is the starting point for mail configuration. To combat spam and fraud, most organizations will configure SMTP to check for additional records, such as the TXT-based SPF records. Read https://www.rackaid.com/blog/email-dns-records/ to learn more about these applications. Reverse DNS Pointer (PTR) records enable lookups from IPv4 address to hostnames. These reverse lookups are required, or at least recommended, for the proper operation of certain application-level protocols such as email. Additional Topics \u00b6 Tools \u00b6 Dig - https://help.dyn.com/how-to-use-binds-dig-tool/ Nslookup - https://en.wikipedia.org/wiki/Nslookup Whois - https://whois.icann.org/en/dns-and-whois-how-it-works Service Discovery \u00b6 Service (SRV) records are used in conjunction with application layer protocols to identify resources based on role or function rather than hostname. This application is known as Service Discovery (DNS-SD) and is described in RFC 6763. SRV records can be queried just like any other record, though they are identified by a distinct convention of _service._transport in place of a standard host name. Practically speaking, SRV records function much like a general purpose MX pointing to named address records that can be further queried to obtain the IP address for a resource. $ dig -t srv _sip._tls.microsoft.com ; <<>> DiG 9.8.3-P1 <<>> srv _sip._tls.microsoft.com ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 33094 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; QUESTION SECTION: ;_sip._tls.microsoft.com. IN SRV ;; ANSWER SECTION: _sip._tls.microsoft.com. 3600 IN SRV 0 0 443 sip.microsoft.com. ;; ADDITIONAL SECTION: sip.microsoft.com. 895 IN A 167.220.67.163 ;; Query time: 15 msec ;; SERVER: 199.66.140.50#53(199.66.140.50) ;; WHEN: Tue May 9 16:19:39 2017 ;; MSG SIZE rcvd: 98 The preceding query highlights the use of SRV by the session initiation protocol (SIP), a component in voice-over-IP and other types of real-time communication systems that is used to establish connections between peers. https://en.wikipedia.org/wiki/SRV_record https://www.onsip.com/blog/dns-srv-records-sip Security and Privacy \u00b6 The distributed nature of DNS infrastructure offers many benefits. The database is independent of any single network or entity. The load of DNS queries is distributed broadly across many different servers. Clients can query servers that are geographically close to them, reducing overall time for name resolution. Moreover, DNS can withstand many types of failures and disruptions and resists many types of broad scale interference. Nevertheless, DNS has some significant limitations in the realm of security and privacy that are important to understand. In standard DNS, queries and responses are neither encrypted nor authenticated. Targeted manipulation of DNS responses, e.g., spoofing, can be used to direct victims to attacker-controlled resources or to inject advertisements into user traffic. http://erichelgeson.github.io/blog/2013/12/31/i-fought-my-isps-bad-behavior-and-won/ Likewise, passive monitoring reveals significant amounts of information about a victim's identity, beyond just telling us which server they have visited. This type of monitoring is often conducted by network administrators, ISPs, governments, passive observers on wireless networks, and hackers who have managed to hijack network traffic through a MITM attack. https://nakedsecurity.sophos.com/2016/10/05/unmasking-tor-users-with-dns/ https://dnsprivacy.org/wiki/display/DP/DNS+Privacy+-+The+Problem This is a double-edged sword. The same properties of DNS can make it a powerful tool for detecting and preventing malicious attacks. The Cisco Umbrella service (originally OpenDNS), for example, can detect malware infections, phishing scams, and more through sophisticated analysis of DNS queries ( https://umbrella.cisco.com/ ). One approach to securing DNS against privacy incursions is to use a resolver that encrypts connections between clients and recursive servers. The dnscrypt project ( https://dnscrypt.org/ ) provides such a tool, though it is not supported by the vast majority of public DNS servers. More than privacy, the integrity of DNS is arguably the primary concern for most applications. DNSSEC provides a basic integrity mechanism akin to the public key infrastructure and X.509 certificates that underly SSL. DNSSEC is a complex topic and controversial topic. https://www.cloudflare.com/dns/dnssec/how-dnssec-works/ For most users, the most important thing to remember about DNS security is to take steps to protect records under their own purview. Basic DNS security hygiene involves the following tasks: Choosing trustworthy and secure DNS providers Keep DNS registrations active so that attackers cannot hijack the expired domain Limiting access to zone management accounts Implementing strong passwords and secondary authentication mechanisms It's difficult to overstate the importance of these practices. Attackers target DNS to hijack web traffic, entire email systems, and more. For this reason, applications are often deployed with higher-layer integrity mechanisms, e.g., X.509 certificates used in SSL and fingerprinting / key pinning in SSH. These systems, however, are not foolproof. Each has its limitations, therefore DNS security remains a top priority.","title":"Domain Name System (DNS)"},{"location":"notes/dns-overview/#domain-name-system","text":"","title":"Domain Name System"},{"location":"notes/dns-overview/#overview","text":"The domain name system (DNS) is a distributed, hierarchical data store and name resolution service that is used primarily to resolve IP addresses based on much more user-friendly domain names. DNS is a powerful and rather complex system that plays a variety of crucial roles in modern systems and applications. It is so central to these systems that any degradation of service will severely impact the usability of a network-connected computer or mobile device (e.g., resulting in extremely slow boot and application launch times). Our objective is to gain a functional understanding of the system, which we can apply broadly to our work in other areas of the informatics domain. The following videos provide a highly accessible starting point. Pieter Explains Tech https://www.youtube.com/watch?v=GlZC4Jwf3xQ Khan Academy https://www.khanacademy.org/computing/computer-science/internet-intro/internet-works-intro/v/the-internet-ip-addresses-and-dns","title":"Overview"},{"location":"notes/dns-overview/#dns-namespace-and-zones","text":"As you've seen, domain names are structured in a hierarchical manner that reflects the decentralized nature of the domain name system. The DNS namespace can be represented by a tree, with branches descending from a common root. A fully-qualified domain name (FQDN) is written by concatenating labels from left-to-right, tracing the path from a leaf node to the root by way of the parent nodes. A trailing dot, representative of the root, is appended to the FQDN for DNS operations though it is omitted in most user-facing applications. Below the root, the top-most level of the graph represents top-level domains (TLD), such as com, net, and edu, that appear at the end of every FQDN. IANA and its parent organization ICANN oversee the governance of the DNS root and top-level domains, though it delegates registration functions and operation of root and TLD name servers to independent organizations. Names appearing as children of each TLD are assigned to organizations through the domain registration process. An organization registers a domain name by working with an ICANN-accredited registrar or a reseller subcontracted by an accredited registrar. https://whois.icann.org/en/domain-name-registration-process Further subdivisions of the registered namespace can be created by the registrant. These subdomains appear as children of the registrant domains in the DNS tree described previously.","title":"DNS Namespace and Zones"},{"location":"notes/dns-overview/#dns-zones","text":"The hierarchical structure of DNS lends to dividing administrative responsibility of the global namespace. The term \"zone\" refers to these administrative divisions. Each zone in DNS is a contiguous portion of the namespace under the administrative responsibility of a single manager. While zones are often aligned with individual domain registrations, the relationship is not one-to-one. A zone may include multiple domains. Likewise, a domain may be divided into additional zones encapsulating distinct subtrees. The root zone database is managed by IANA and contains the authority records for the TLDs. Likewise, IANA assigns operators for the TLDs. These operators maintain the authoritative database of all domain names and authority records registered in the TLD. These databases are referred to as the DNS registries and can be queried to identify the authoritative nameservers for child zones.","title":"DNS Zones"},{"location":"notes/dns-overview/#dns-name-servers","text":"Each zone, including the root, is hosted by one or more name servers that store collection of resource records associated with the corresponding subset of the DNS namespace. The primary service of root name servers and TLD name servers is to provide information about where to query the next level of the namespace. Roots point to TLD name servers and TLDs point to authoritative name servers for second-level domains. The primary records served by these servers are NS records along with A/AAAA glue records that identify the IP addresses for the provided servers. Likewise, the root and TLD servers distribute records related to DNS Security (DNSSEC) mechanisms. In addition to the root servers and TLD servers described above, resource records for each zone are hosted by at least one authoritative name server. These authoritative name servers may be hosted by the registrant itself or by a third-party DNS hosting service. Many organizations maintain internal, private zones serving records that are only available within well-defined network boundaries. Not all name servers are authoritative for a zone. Plenty of servers are created to satisfy service requirements for performance, redundancy, or security. Recursive name servers are used by clients to resolve DNS requests without having to perform iterative queries of root, TLD, and registrant name servers. When a recursive name server receives a query that it cannot resolve independently, it queries the upper-level zones to find the answer that it returns to the original client. This process can be sped up significantly by caching results, though care must be observed to prevent serving stale records from a cache. https://www.lifewire.com/dns-root-name-servers-3971336 https://www.iana.org/domains/root/servers http://root-servers.org","title":"DNS Name Servers"},{"location":"notes/dns-overview/#redundancy-and-reliability","text":"The modern internet is heavily dependent on DNS, so much so that DNS disruptions and failures can take businesses and users offline. Even seemingly minor performance issues can multiply and cause noticeable delays for networking operations. To combat these issues, many DNS service providers rely heavily on IPv4/v6 Anycast to ensure that a fleet of servers are available to answer queries. These service providers leverage BGP, the dynamic routing protocol of the Internet to assign the same IP address, e.g., 1.1.1.1, to each of their servers scattered around the world. Each DNS request that passes through the Internet will be routed to exactly one of these servers, typically the server that is closest to the sender. http://dyn.com/blog/unicast-vs-anycast-dns-nameserver-routing/ http://blog.catchpoint.com/2015/06/16/dns-anycast/","title":"Redundancy and Reliability"},{"location":"notes/dns-overview/#protocol","text":"As the prior sections have suggested, the DNS protocol is a query response protocol that is used to resolve IP addresses and other metadata stored in resource records based on DNS names. The protocol can be run atop both UDP and TCP for transport and uses port 53 in both cases. Basic DNS queries are most likely to be served over UDP, as this protocol provides the most efficient transport mechanism by avoiding the multi-round trip cost associated with the TCP handshake. The connection-oriented TCP protocol is most likely to be used for responses over 512 bytes to ensure that the message fits in a single datagram. Zone transfers used to transfer domain information between primary and secondary name servers are a common example of TCP-based DNS transactions. The DNS protocol itself is unicast, though a multicast version (mDNS) has been defined to support communication on local networks without the need for supporting infrastructure. Multicast DNS is served on port 5353 of the 224.0.0.251 multicast address. The mDNS protocol was popularized by Apple under the Bonjour trademark, but it has more recently made its way into the most popular mobile and desktop operating systems by way of zeroconf initiatives.","title":"Protocol"},{"location":"notes/dns-overview/#common-resource-record-rr-types","text":"DNS-related RFCs define many different record types for general use and specific applications. We address the most common records here: Start of Authority (SOA) records identify the primary name server and administrator responsible for a given zone as well as version information and base parameters that impact communication between servers in a zone and caching of records related to the zone. Name Server (NS) records indicate which name servers are authoritative for a given zone. These records are also accompanied by so-called glue records that store the IP addresses associated with the server name stored in an NS. Address (A) records are among the most familiar DNS records. Their role is simple in that they associate the IPv4 address of a resource with the server's name. Address records are structured for forward lookup, i.e., resolving the address given the name. A similar, yet separate address record (AAAA) is defined to support IPv6-related queries. Canonical Name (CNAME) records are used to set aliases for existing DNS names rather than directly associating a name with an IP address. These records are commonly used when a resource is hosted by an organization other than the registrant itself and to avoid the necessity of maintaining static IP addresses for these resources. The hostname of a web site that runs on a service like SquareSpace or Wix is likely to point to a CNAME alias that can be resolved to an IP within the parent (service-provider's) domain. Text (TXT) records store additional information required by other protocols. Quite often, TXT records are created to demonstrate ownership of a certain namespace. This action is required, e.g., when attaching a private domain to a hosted service such as Office 365 or GSuite mail. TXT records are also used to store Sender Policy Framework (SPF) records leveraged by SMTP servers to combat email spam. Mail Exchange (MX) records point to SMTP servers for a domain, enabling other SMTP servers to locate and route mail between domains. Each MX record contains the FQDN for a mail host. An associated A (or AAAA) record must exist to resolve the hostname to an IP address. The MX record also contains a preference field, which is used to determine priority among multiple MX records. It is quite common to provide multiple MX records to balance load between mail servers and gain redundancy. Servers with smaller preference values are tried first, while clients are expected to choose randomly between servers with equal preference. The MX record is the starting point for mail configuration. To combat spam and fraud, most organizations will configure SMTP to check for additional records, such as the TXT-based SPF records. Read https://www.rackaid.com/blog/email-dns-records/ to learn more about these applications. Reverse DNS Pointer (PTR) records enable lookups from IPv4 address to hostnames. These reverse lookups are required, or at least recommended, for the proper operation of certain application-level protocols such as email.","title":"Common Resource Record (RR) Types"},{"location":"notes/dns-overview/#additional-topics","text":"","title":"Additional Topics"},{"location":"notes/dns-overview/#tools","text":"Dig - https://help.dyn.com/how-to-use-binds-dig-tool/ Nslookup - https://en.wikipedia.org/wiki/Nslookup Whois - https://whois.icann.org/en/dns-and-whois-how-it-works","title":"Tools"},{"location":"notes/dns-overview/#service-discovery","text":"Service (SRV) records are used in conjunction with application layer protocols to identify resources based on role or function rather than hostname. This application is known as Service Discovery (DNS-SD) and is described in RFC 6763. SRV records can be queried just like any other record, though they are identified by a distinct convention of _service._transport in place of a standard host name. Practically speaking, SRV records function much like a general purpose MX pointing to named address records that can be further queried to obtain the IP address for a resource. $ dig -t srv _sip._tls.microsoft.com ; <<>> DiG 9.8.3-P1 <<>> srv _sip._tls.microsoft.com ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 33094 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; QUESTION SECTION: ;_sip._tls.microsoft.com. IN SRV ;; ANSWER SECTION: _sip._tls.microsoft.com. 3600 IN SRV 0 0 443 sip.microsoft.com. ;; ADDITIONAL SECTION: sip.microsoft.com. 895 IN A 167.220.67.163 ;; Query time: 15 msec ;; SERVER: 199.66.140.50#53(199.66.140.50) ;; WHEN: Tue May 9 16:19:39 2017 ;; MSG SIZE rcvd: 98 The preceding query highlights the use of SRV by the session initiation protocol (SIP), a component in voice-over-IP and other types of real-time communication systems that is used to establish connections between peers. https://en.wikipedia.org/wiki/SRV_record https://www.onsip.com/blog/dns-srv-records-sip","title":"Service Discovery"},{"location":"notes/dns-overview/#security-and-privacy","text":"The distributed nature of DNS infrastructure offers many benefits. The database is independent of any single network or entity. The load of DNS queries is distributed broadly across many different servers. Clients can query servers that are geographically close to them, reducing overall time for name resolution. Moreover, DNS can withstand many types of failures and disruptions and resists many types of broad scale interference. Nevertheless, DNS has some significant limitations in the realm of security and privacy that are important to understand. In standard DNS, queries and responses are neither encrypted nor authenticated. Targeted manipulation of DNS responses, e.g., spoofing, can be used to direct victims to attacker-controlled resources or to inject advertisements into user traffic. http://erichelgeson.github.io/blog/2013/12/31/i-fought-my-isps-bad-behavior-and-won/ Likewise, passive monitoring reveals significant amounts of information about a victim's identity, beyond just telling us which server they have visited. This type of monitoring is often conducted by network administrators, ISPs, governments, passive observers on wireless networks, and hackers who have managed to hijack network traffic through a MITM attack. https://nakedsecurity.sophos.com/2016/10/05/unmasking-tor-users-with-dns/ https://dnsprivacy.org/wiki/display/DP/DNS+Privacy+-+The+Problem This is a double-edged sword. The same properties of DNS can make it a powerful tool for detecting and preventing malicious attacks. The Cisco Umbrella service (originally OpenDNS), for example, can detect malware infections, phishing scams, and more through sophisticated analysis of DNS queries ( https://umbrella.cisco.com/ ). One approach to securing DNS against privacy incursions is to use a resolver that encrypts connections between clients and recursive servers. The dnscrypt project ( https://dnscrypt.org/ ) provides such a tool, though it is not supported by the vast majority of public DNS servers. More than privacy, the integrity of DNS is arguably the primary concern for most applications. DNSSEC provides a basic integrity mechanism akin to the public key infrastructure and X.509 certificates that underly SSL. DNSSEC is a complex topic and controversial topic. https://www.cloudflare.com/dns/dnssec/how-dnssec-works/ For most users, the most important thing to remember about DNS security is to take steps to protect records under their own purview. Basic DNS security hygiene involves the following tasks: Choosing trustworthy and secure DNS providers Keep DNS registrations active so that attackers cannot hijack the expired domain Limiting access to zone management accounts Implementing strong passwords and secondary authentication mechanisms It's difficult to overstate the importance of these practices. Attackers target DNS to hijack web traffic, entire email systems, and more. For this reason, applications are often deployed with higher-layer integrity mechanisms, e.g., X.509 certificates used in SSL and fingerprinting / key pinning in SSH. These systems, however, are not foolproof. Each has its limitations, therefore DNS security remains a top priority.","title":"Security and Privacy"},{"location":"notes/ethernet-switches/","text":"Key concepts: Shared transmission medium, topology, hub, congestion, collision domain, broadcast domain, segment (layer-2), bridge, switch, forwarding information base (FIB) Introduction \u00b6 Ethernet switches are one of the most widely deployed network components, providing physical ports for attaching other network components or endpoints at the data-link layer of the TCP/IP stack. Barring advanced configurations, devices that are attached through switching infrastructure are part of the same layer-2 network and can communicate directy through the switch using layer-2 addresses. Collisions and Media Access Control \u00b6 Switches are not the only layer-2 game in town for wired Ethernet, though they are one of the few you should even consider in 2020. Once upon a time we connected devices in a bus configuration, where each node would tap into a segment of coaxial cable or other suitable transmission medium. In this configuration, the bus provides a resource that must be shared between all nodes attached to it. One consequence of this configuration is that data frames are visible to every other node since the signal is transmitted across the entire bus. Likewise, since the bus is shared, collisions between data frames may occur when nodes try to use the resource at the same time. For this reason, we say that bus represents a single collision domain . Ethernet copes with collisions using a media access control (MAC) mechanism that allows the NIC to identify a failure and make another attempt after a variable delay. This mechanism is known as Carrier Sense Multiple Access with Collision Detection (CSMA/CD) . While CSMA/CD enables the network to continue functioning despite collisions, congestion occur as the shared medium becomes more contested. A highly congested network is inefficient since failures and retransmission consume an increasing amount of its bandwidth. Star Topology \u00b6 Congestion is not the only architectural concern associated with the bus topology. Physical challenges such as signal interference and attenuation limit the overall length of a bus. As such, the layout of the bus relative to the physical location of each node must be carefully planned. Hubs alleviated these latter concerns by offering a more flexible topology. In a star topology , multiple nodes connect back to a central point through dedicated, indepenent links, e.g., lengths of CAT-5 cable. Beneath the hood, hubs still operate on the underlying principle of transmitting signals across an entire network segment. In fact, each port of a hub acts as a repeater for the physical signals that were received on other ports. As such, hubs do not eliminate the concern of congestion and collisions or snooping on communication within a segment since endpoints connected by hubs are still members of a single collision domain. Bridging and Switches \u00b6 Bridging provide a layer-2 solution to the congestion problem by splitting a network into independent collision domains and intelligently forwarding frames between these layer-2 segments . When a bridge observes a frame on one of its ports, it inspects Ethernet headers to learn about the topology of the network based on the MAC address of the sender. The bridge uses the information it learns about the topology to optimize forwarding, which is only necessary when the recipient and sender are on different segments. xxx NO CHANGES TO ETHERNET Classic Ethernet bridges provides two ports/collision domains and are rarely seen in modern networks. A switch combines multiple bridges in a device that physically resembles a hub. Unlike a hub, however, each switch port represents a distinct segment on its own collision domain. From a performance perspective, a well-placed bridge can reduce the amount of activity on a domain by about half (discounting for broadcast traffic). Adding more bridges further improves the situation. In a switched network, every link is isolated within an independent collision domain, allowing a much greater level of overall throughput on the network. Forwarding Mechanics \u00b6 The forwarding mechanics of a switch are identical to a bridge. As switches learn the topology of a layer-2 network, they populate a Forwarding Information Base (FIB) with MAC/port associations. Until a switch knows which port is associated with a particular destination MAC address, a frame received on one port will be flooded over every other port on the switch. Broadcast Domains \u00b6 As we've seen, switches support standard Ethernet modes of communication between all nodes of the layer-2 network based on MAC address. Virtual LAN (VLAN) \u00b6 VLANs provide a solution to isolate broadcast domains from one another without requiring an investment of dedicated hardware for each domain. In the simplest sense, VLANs provide virtual separation of broadcast domains by identifying switch ports as VLAN members and referencing this configuration to enforce the separation of ethernet traffic. A switch configured with more than one VLAN behaves like multiple standalone switches. The ports assigned to a given VLAN maintain their own view of the FIB that is based only on the MAC addresses seen on those ports. In port-based VLANs, which use the mode of operation described above, a router would need to be attached to each set of ports to assign forwarding across the VLAN boundary. Many switches, support a more dynamic mode that enables network-attached devices to distinguish between traffic from multiple VLANs running over a single link. Links that carry traffic for multiple VLANs are called trunks (the associated switch ports are called trunk ports). With trunking, connections between infrastructure components is simplified since multiple broadcast domains can be collapsed onto a single physical link. Trunks generally rely on tags (as specified in 802.1q) to control distribution of frames over VLANs. Despite implementation differences, tag and port-based VLANs obey the same rules. Layer-2 frames received on any port/tag are only distributed within the associated VLAN. Switch Architecture Planning \u00b6 Larger networks require multi-tier switch deployments to satisfy the requirements of core communication, distribution, and network access. Switches at the access tier need to provide enough port density to support endpoints in the network. Switches participating in the distribution tier of the network architecture may prioritize VLAN trunking, basic redundancy, and incorporate layer-3 functionality to handle routing and security policies internally. Core functionality will likely incorporate multiple levels of redundancy and higher capacity links. Redundancy and Switch Loops \u00b6 Redundancy is a common requirement in network infrastructure for the corporate world. Organizations have a greater dependence on information technology and a low threshold for system outages that disrupt operations or productivity. In LAN design, we need to plan for redundant components and links based on the impact of a failure at a given point in the network. Redundancy at this layer has an interesting effect with regard to forwarding behavior. A frame that passes through one side of a redundant connection is expected to return to the switch through the other side of the connection. This situation is commonly known as a switching loop. Frames that are caught in a loop degrade the performance of the switches involved. Broadcast traffic exacerbates the problem and may create a broadcast storm. Spanning tree protocol (STP) is present on many business-grade switches to alleviate this problem. FIBs sometimes referred to as a MAC address table or a CAM table. CAM stands for content addressable memory, which is the implementation mechanism used for the FIB on many switches. \u21a9","title":"Ethernet Switches"},{"location":"notes/ethernet-switches/#introduction","text":"Ethernet switches are one of the most widely deployed network components, providing physical ports for attaching other network components or endpoints at the data-link layer of the TCP/IP stack. Barring advanced configurations, devices that are attached through switching infrastructure are part of the same layer-2 network and can communicate directy through the switch using layer-2 addresses.","title":"Introduction"},{"location":"notes/ethernet-switches/#collisions-and-media-access-control","text":"Switches are not the only layer-2 game in town for wired Ethernet, though they are one of the few you should even consider in 2020. Once upon a time we connected devices in a bus configuration, where each node would tap into a segment of coaxial cable or other suitable transmission medium. In this configuration, the bus provides a resource that must be shared between all nodes attached to it. One consequence of this configuration is that data frames are visible to every other node since the signal is transmitted across the entire bus. Likewise, since the bus is shared, collisions between data frames may occur when nodes try to use the resource at the same time. For this reason, we say that bus represents a single collision domain . Ethernet copes with collisions using a media access control (MAC) mechanism that allows the NIC to identify a failure and make another attempt after a variable delay. This mechanism is known as Carrier Sense Multiple Access with Collision Detection (CSMA/CD) . While CSMA/CD enables the network to continue functioning despite collisions, congestion occur as the shared medium becomes more contested. A highly congested network is inefficient since failures and retransmission consume an increasing amount of its bandwidth.","title":"Collisions and Media Access Control"},{"location":"notes/ethernet-switches/#star-topology","text":"Congestion is not the only architectural concern associated with the bus topology. Physical challenges such as signal interference and attenuation limit the overall length of a bus. As such, the layout of the bus relative to the physical location of each node must be carefully planned. Hubs alleviated these latter concerns by offering a more flexible topology. In a star topology , multiple nodes connect back to a central point through dedicated, indepenent links, e.g., lengths of CAT-5 cable. Beneath the hood, hubs still operate on the underlying principle of transmitting signals across an entire network segment. In fact, each port of a hub acts as a repeater for the physical signals that were received on other ports. As such, hubs do not eliminate the concern of congestion and collisions or snooping on communication within a segment since endpoints connected by hubs are still members of a single collision domain.","title":"Star Topology"},{"location":"notes/ethernet-switches/#bridging-and-switches","text":"Bridging provide a layer-2 solution to the congestion problem by splitting a network into independent collision domains and intelligently forwarding frames between these layer-2 segments . When a bridge observes a frame on one of its ports, it inspects Ethernet headers to learn about the topology of the network based on the MAC address of the sender. The bridge uses the information it learns about the topology to optimize forwarding, which is only necessary when the recipient and sender are on different segments. xxx NO CHANGES TO ETHERNET Classic Ethernet bridges provides two ports/collision domains and are rarely seen in modern networks. A switch combines multiple bridges in a device that physically resembles a hub. Unlike a hub, however, each switch port represents a distinct segment on its own collision domain. From a performance perspective, a well-placed bridge can reduce the amount of activity on a domain by about half (discounting for broadcast traffic). Adding more bridges further improves the situation. In a switched network, every link is isolated within an independent collision domain, allowing a much greater level of overall throughput on the network.","title":"Bridging and Switches"},{"location":"notes/ethernet-switches/#forwarding-mechanics","text":"The forwarding mechanics of a switch are identical to a bridge. As switches learn the topology of a layer-2 network, they populate a Forwarding Information Base (FIB) with MAC/port associations. Until a switch knows which port is associated with a particular destination MAC address, a frame received on one port will be flooded over every other port on the switch.","title":"Forwarding Mechanics"},{"location":"notes/ethernet-switches/#broadcast-domains","text":"As we've seen, switches support standard Ethernet modes of communication between all nodes of the layer-2 network based on MAC address.","title":"Broadcast Domains"},{"location":"notes/ethernet-switches/#virtual-lan-vlan","text":"VLANs provide a solution to isolate broadcast domains from one another without requiring an investment of dedicated hardware for each domain. In the simplest sense, VLANs provide virtual separation of broadcast domains by identifying switch ports as VLAN members and referencing this configuration to enforce the separation of ethernet traffic. A switch configured with more than one VLAN behaves like multiple standalone switches. The ports assigned to a given VLAN maintain their own view of the FIB that is based only on the MAC addresses seen on those ports. In port-based VLANs, which use the mode of operation described above, a router would need to be attached to each set of ports to assign forwarding across the VLAN boundary. Many switches, support a more dynamic mode that enables network-attached devices to distinguish between traffic from multiple VLANs running over a single link. Links that carry traffic for multiple VLANs are called trunks (the associated switch ports are called trunk ports). With trunking, connections between infrastructure components is simplified since multiple broadcast domains can be collapsed onto a single physical link. Trunks generally rely on tags (as specified in 802.1q) to control distribution of frames over VLANs. Despite implementation differences, tag and port-based VLANs obey the same rules. Layer-2 frames received on any port/tag are only distributed within the associated VLAN.","title":"Virtual LAN (VLAN)"},{"location":"notes/ethernet-switches/#switch-architecture-planning","text":"Larger networks require multi-tier switch deployments to satisfy the requirements of core communication, distribution, and network access. Switches at the access tier need to provide enough port density to support endpoints in the network. Switches participating in the distribution tier of the network architecture may prioritize VLAN trunking, basic redundancy, and incorporate layer-3 functionality to handle routing and security policies internally. Core functionality will likely incorporate multiple levels of redundancy and higher capacity links.","title":"Switch Architecture Planning"},{"location":"notes/ethernet-switches/#redundancy-and-switch-loops","text":"Redundancy is a common requirement in network infrastructure for the corporate world. Organizations have a greater dependence on information technology and a low threshold for system outages that disrupt operations or productivity. In LAN design, we need to plan for redundant components and links based on the impact of a failure at a given point in the network. Redundancy at this layer has an interesting effect with regard to forwarding behavior. A frame that passes through one side of a redundant connection is expected to return to the switch through the other side of the connection. This situation is commonly known as a switching loop. Frames that are caught in a loop degrade the performance of the switches involved. Broadcast traffic exacerbates the problem and may create a broadcast storm. Spanning tree protocol (STP) is present on many business-grade switches to alleviate this problem. FIBs sometimes referred to as a MAC address table or a CAM table. CAM stands for content addressable memory, which is the implementation mechanism used for the FIB on many switches. \u21a9","title":"Redundancy and Switch Loops"},{"location":"notes/router-overview/","text":"Routers \u00b6 Routers and routing are frequent topics when we discuss networking, and it is all too easy for newcomers to overlook or misunderstand some of the assumptions we make about these terms. Let\u2019s take a step back and review the fundamentals. What is a Router \u00b6 A router is a computing device that is attached to two or more networks and is set up so that it can forward packets from one network to another. Both of these conditions are necessary in order for us to call something a router. You might think that all routers are special purpose, embedded devices like the ones you see on most home or office networks. In reality, most computers 1 are capable of routing, so long as the hardware supports multiple network connections and the software supports forwarding between networks. Routers vs Multi-homed Hosts \u00b6 It is not uncommon for a device to be connected to multiple networks without being configured to route traffic. A device with this configuration, e.g., your Pi prior to checkpoint #3, is known as a multi-homed host. A non-routing, multi-homed hosts will drop packets that aren\u2019t directly addressed to it at both Layer-2 (MAC address) and Layer-3 (IP address). This behavior is exactly the same as an ordinary host attached to a single network. Routers and Incoming Packets \u00b6 On an ethernet-based network, a router will process any frame for which the destination MAC address matches the MAC of the NIC on which the frame was received. After processing Layer-2, the router examines the packet\u2019s IP headers. Assuming that the destination IP address is not a match for the router\u2019s IP address, the router will consult its route table in order to forward the packet closer to its final destination. Packets addressed directly to the router will continue to be processed so that they can be delivered to an internal process via a socket. Routers and Outgoing Packets \u00b6 Most of the unique magic that distinguishes routers from ordinary hosts takes place on inbound packets. You might be surprised to learn that the process of sending a packet is the same for packets from local applications as it is for packets forwarded between networks. No matter where a packet comes from or where it is going, packet-communication occurs on a hop-by-hop basis. Every host starts this process by comparing its destination address to entries defined in its own routing table. Matches are identified when the network bits of the destination match a network id in the based on the correspondence netmask or CIDR defined in the routing table 2 . After finding a match, the network stack can start the process of forwarding to the next hop. If the final destination is on a directly attached network, ARP is used to determine the MAC address of the destination and the packet will be forwarded directly. Otherwise, the routing table can be used to find a next hop IP address for a directly attached network. Once again, with the next hop IP, ARP can be used to determine the MAC address so that the packet can be forwarded directly. Terminology \u00b6 Routing terminology is a common sticking point for many students and professionals. In particular, it can be useful to understand the finer distinctions between the terms routing and forwarding . At Layer-3, the word forwarding describes the mechanics of passing an inbound packet from its origin interface back onto a different network through an outbound interface. The mechanics of finding a matching route and pushing the packet out the appropriate interface are all part of the forwarding process. In contrast, routing refers to the entire end-to-end process that gets a packet to the right place. When we say most computers, we mean it. Have you ever used your mobile phone as a hotspot for your tablet or computer? Give it a shot, and if you\u2019re able, use traceroute or tracert to observe the routing process in action. \u21a9 It is possible for a routing table to find multiple matches. In this case, ties are broken by looking for the most specific entry, i.e., the longest matching network prefix. Other metrics may be used if there are multiple entries for a given network ID. \u21a9","title":"Routers"},{"location":"notes/router-overview/#routers","text":"Routers and routing are frequent topics when we discuss networking, and it is all too easy for newcomers to overlook or misunderstand some of the assumptions we make about these terms. Let\u2019s take a step back and review the fundamentals.","title":"Routers"},{"location":"notes/router-overview/#what-is-a-router","text":"A router is a computing device that is attached to two or more networks and is set up so that it can forward packets from one network to another. Both of these conditions are necessary in order for us to call something a router. You might think that all routers are special purpose, embedded devices like the ones you see on most home or office networks. In reality, most computers 1 are capable of routing, so long as the hardware supports multiple network connections and the software supports forwarding between networks.","title":"What is a Router"},{"location":"notes/router-overview/#routers-vs-multi-homed-hosts","text":"It is not uncommon for a device to be connected to multiple networks without being configured to route traffic. A device with this configuration, e.g., your Pi prior to checkpoint #3, is known as a multi-homed host. A non-routing, multi-homed hosts will drop packets that aren\u2019t directly addressed to it at both Layer-2 (MAC address) and Layer-3 (IP address). This behavior is exactly the same as an ordinary host attached to a single network.","title":"Routers vs Multi-homed Hosts"},{"location":"notes/router-overview/#routers-and-incoming-packets","text":"On an ethernet-based network, a router will process any frame for which the destination MAC address matches the MAC of the NIC on which the frame was received. After processing Layer-2, the router examines the packet\u2019s IP headers. Assuming that the destination IP address is not a match for the router\u2019s IP address, the router will consult its route table in order to forward the packet closer to its final destination. Packets addressed directly to the router will continue to be processed so that they can be delivered to an internal process via a socket.","title":"Routers and Incoming Packets"},{"location":"notes/router-overview/#routers-and-outgoing-packets","text":"Most of the unique magic that distinguishes routers from ordinary hosts takes place on inbound packets. You might be surprised to learn that the process of sending a packet is the same for packets from local applications as it is for packets forwarded between networks. No matter where a packet comes from or where it is going, packet-communication occurs on a hop-by-hop basis. Every host starts this process by comparing its destination address to entries defined in its own routing table. Matches are identified when the network bits of the destination match a network id in the based on the correspondence netmask or CIDR defined in the routing table 2 . After finding a match, the network stack can start the process of forwarding to the next hop. If the final destination is on a directly attached network, ARP is used to determine the MAC address of the destination and the packet will be forwarded directly. Otherwise, the routing table can be used to find a next hop IP address for a directly attached network. Once again, with the next hop IP, ARP can be used to determine the MAC address so that the packet can be forwarded directly.","title":"Routers and Outgoing Packets"},{"location":"notes/router-overview/#terminology","text":"Routing terminology is a common sticking point for many students and professionals. In particular, it can be useful to understand the finer distinctions between the terms routing and forwarding . At Layer-3, the word forwarding describes the mechanics of passing an inbound packet from its origin interface back onto a different network through an outbound interface. The mechanics of finding a matching route and pushing the packet out the appropriate interface are all part of the forwarding process. In contrast, routing refers to the entire end-to-end process that gets a packet to the right place. When we say most computers, we mean it. Have you ever used your mobile phone as a hotspot for your tablet or computer? Give it a shot, and if you\u2019re able, use traceroute or tracert to observe the routing process in action. \u21a9 It is possible for a routing table to find multiple matches. In this case, ties are broken by looking for the most specific entry, i.e., the longest matching network prefix. Other metrics may be used if there are multiple entries for a given network ID. \u21a9","title":"Terminology"},{"location":"resources/address-planning/","text":"Basic IP Address Planning (2020-04-09) \u00b6 Don't try to build a network without a plan. A good network design is built on parameters and constraints that are appropriate for the intended use-cases. This guide offers a simple procedure that can serve as a starting point for basic planning needs. Private versus Public \u00b6 We can't pull addresses from thin air. The laws of the TCP/IP universe restrict what addresses we can use on networks we can control. Make sure that you understand where addresses come from and can distinguish between private and public address space. Private Addresses Within the boundaries of our own network, we are relatively free to set our rules as long as we use addresses that are reserved for private use. Your reference point for these addresses is RFC-1918 . Public Addresses For packets we send on the public Internet, we must use public addresses that are in our control. These addresses will either be leased (short-term or long-term reservation) to us by an ISP or allocated on a more permanent basis by a Regional Internet Registry (RIR) 1 . A contiguous group of addresses allocated in this way is referred to as a block . Configuration Strategies \u00b6 As you get started, you will need to make decisions about how you will configure devices on your network with appropriate IP addresses and network parameters. Before you proceed, make sure that you understand the following classifications. Leased Addresses As much as possible, you'll want to avoid the need for manual configuration when a new device joins the network. DHCP allows you to allocate a range of addresses that the server can use to issue address leases to hosts that request them. Leased addresses are dynamic in the sense that they aren't determined until a host joins the network and initiates the DHCP process. Static Addresses Dynamic address assignment won't work for every scenario, e.g., when an address should be fixed and a dependency on DHCP isn't possible. Some devices, including the DHCP server itself should be directly configured. We describe their addresses as static because they are coded into a network node's configuration and won't change base on external factors. Procedure \u00b6 Step 1 - Examine address needs \u00b6 Determine the number of addresses required, accounting for static, and DHCP Leased address pools. Identify additional address constraints, such as the number of distinct subnets needed or potential subnet conflicts Step 2 - Identify the base network \u00b6 Identify the base network from which you will be subnetting. If you do not have a permanent select a block from the RFC-1918 address range. Step 3 - Select subnet parameters \u00b6 Based on the inventory you conducted in step #1, determine the number of address bits that are required in order to give an address to each host on your LAN. You can use this number to determine the CIDR length and network mask for your Subnet. Given a base network and a CIDR length, choose an available subnet id for your network. 2 To complete the set of basic configuration parameters, compute the broadcast address associated with your chosen subnet ID and CIDR. Step 4 - Document important addresses and ranges \u00b6 Finally, let's connect the dots between what we've done in the first three steps by splitting your subnet up according to static, and dynamic addresses. Static addresses will usually be assigned to core network devices, e.g., a router or DHCP server, that should operate independently of DHCP. For other devices that need consistent addresses -- perhaps DNS servers or printers -- you can also assign a static address. If you operate multiple networks, it is helpful to be consistent with your static assignments. For example, most network administrators will assign the router to either the first or last address in the subnet. Don't deviate from convention unless you have a good reason. Once you've documented your static addresses, identify a range of addresses within your subnet that can be used for the DHCP address pool. This should be a contiguous block of addresses and it cannot overlap with your a) network ID, b) subnet broadcast address, or c) static addresses that you've defined. More information about RIRs can be found at https://www.nro.net/about/rirs/ . \u21a9 The subnet ID or network prefix is the portion of the address that stays the same for all hosts on the same layer-2 network segment. \u21a9","title":"Basic IP Address Planning"},{"location":"resources/address-planning/#basic-ip-address-planning-2020-04-09","text":"Don't try to build a network without a plan. A good network design is built on parameters and constraints that are appropriate for the intended use-cases. This guide offers a simple procedure that can serve as a starting point for basic planning needs.","title":"Basic IP Address Planning (2020-04-09)"},{"location":"resources/address-planning/#private-versus-public","text":"We can't pull addresses from thin air. The laws of the TCP/IP universe restrict what addresses we can use on networks we can control. Make sure that you understand where addresses come from and can distinguish between private and public address space. Private Addresses Within the boundaries of our own network, we are relatively free to set our rules as long as we use addresses that are reserved for private use. Your reference point for these addresses is RFC-1918 . Public Addresses For packets we send on the public Internet, we must use public addresses that are in our control. These addresses will either be leased (short-term or long-term reservation) to us by an ISP or allocated on a more permanent basis by a Regional Internet Registry (RIR) 1 . A contiguous group of addresses allocated in this way is referred to as a block .","title":"Private versus Public"},{"location":"resources/address-planning/#configuration-strategies","text":"As you get started, you will need to make decisions about how you will configure devices on your network with appropriate IP addresses and network parameters. Before you proceed, make sure that you understand the following classifications. Leased Addresses As much as possible, you'll want to avoid the need for manual configuration when a new device joins the network. DHCP allows you to allocate a range of addresses that the server can use to issue address leases to hosts that request them. Leased addresses are dynamic in the sense that they aren't determined until a host joins the network and initiates the DHCP process. Static Addresses Dynamic address assignment won't work for every scenario, e.g., when an address should be fixed and a dependency on DHCP isn't possible. Some devices, including the DHCP server itself should be directly configured. We describe their addresses as static because they are coded into a network node's configuration and won't change base on external factors.","title":"Configuration Strategies"},{"location":"resources/address-planning/#procedure","text":"","title":"Procedure"},{"location":"resources/address-planning/#step-1-examine-address-needs","text":"Determine the number of addresses required, accounting for static, and DHCP Leased address pools. Identify additional address constraints, such as the number of distinct subnets needed or potential subnet conflicts","title":"Step 1 - Examine address needs"},{"location":"resources/address-planning/#step-2-identify-the-base-network","text":"Identify the base network from which you will be subnetting. If you do not have a permanent select a block from the RFC-1918 address range.","title":"Step 2 - Identify the base network"},{"location":"resources/address-planning/#step-3-select-subnet-parameters","text":"Based on the inventory you conducted in step #1, determine the number of address bits that are required in order to give an address to each host on your LAN. You can use this number to determine the CIDR length and network mask for your Subnet. Given a base network and a CIDR length, choose an available subnet id for your network. 2 To complete the set of basic configuration parameters, compute the broadcast address associated with your chosen subnet ID and CIDR.","title":"Step 3 - Select subnet parameters"},{"location":"resources/address-planning/#step-4-document-important-addresses-and-ranges","text":"Finally, let's connect the dots between what we've done in the first three steps by splitting your subnet up according to static, and dynamic addresses. Static addresses will usually be assigned to core network devices, e.g., a router or DHCP server, that should operate independently of DHCP. For other devices that need consistent addresses -- perhaps DNS servers or printers -- you can also assign a static address. If you operate multiple networks, it is helpful to be consistent with your static assignments. For example, most network administrators will assign the router to either the first or last address in the subnet. Don't deviate from convention unless you have a good reason. Once you've documented your static addresses, identify a range of addresses within your subnet that can be used for the DHCP address pool. This should be a contiguous block of addresses and it cannot overlap with your a) network ID, b) subnet broadcast address, or c) static addresses that you've defined. More information about RIRs can be found at https://www.nro.net/about/rirs/ . \u21a9 The subnet ID or network prefix is the portion of the address that stays the same for all hosts on the same layer-2 network segment. \u21a9","title":"Step 4 - Document important addresses and ranges"},{"location":"resources/bash/","text":"Intro to Bash \u00b6 Bash command, terminal command, command line command, for the purpose of our class these all mean the same things. You should already be familiar with bash from INFO 201 and INFO 340. This following section will help you refresh some of the basics. Huh, Bash? If you feel completely lost and have never seen terminal commands we recommend watching these two videos: Beginner's Guide to the Bash Terminal Udacity Shell Workshop Directories \u00b6 cd to change directories ls to show files and directories at your current path ls -a to also show hidden files Editing files \u00b6 If you are editing a file on a remote server such as your Pi, you will not have the luxury of using a nice editor such as VS Code, Atom, or Sublime. Nevertheless, there are many powerful terminal editors. Use nano or vim to edit files through your terminal. How to edit a file that's on a linux server/your Pi: Use nano <fileName> or vim <filename> Nano is beginner friendly. If you are unfamiliar with these I recommend looking up a nano tutorial. Command documentation \u00b6 If you don't know what a command does or how to use it simply use the man command! man <commandName> will print out an documentation. Once you're done reading hit q on your keyboard to quit out. In the following screenshots I enter man nslookup which provides me with more information on what nslookup does and how it's used. Services: starting, stopping, status \u00b6 Control services by using the systemctl command. The format is sudo systemctl <action> <service name> . Example Restart NGINX service: sudo systemctl restart nginx Copying Files Across Servers with scp \u00b6 You can copy files from your laptop to a server or a server to your laptop by using scp . It uses our ssh tunnel to securely transfer your files back and forth. You can find great examples at hyperx.org . Copy all of the contents of a folder: scp -r ava/* root@157.230.163.231:/var/www/html/ This copies everything in the ava folder to the html folder. Local vs Remote \u00b6 A typical confusion for students when deadling with scp is whether their current terminal session is doing work on their local machine (your laptop), or on a remote machine (your Raspberry Pi or another server). You can tell which device your terminal session is doing work in by checking the hostname, that is whatever is after the @ symbol. Take a look at the two example tabs below. Local # hostname = macbook-pro # This tells me I'm on my laptop. ben@macbook-pro:~/Desktop/info-314/ Remote # hostname = debian-lab1 # I must be on my server now. ben@debian-lab1:~$ Logs \u00b6 Check a service's logs. This is a great way to see if it ran into any errors. If for some reason a service keeps crashing or behaving strangely you'd want to dig into its logs and see if it's unhappy with something. sudo journcalctl -u <service name> If you specifically only want to see the most recent parts of the log, you can pipe the information it gives you into the tail command, which only shows any files' ending lines. sudo journalctl -u <service name here>.service | tail -n 100","title":"Intro to Bash"},{"location":"resources/bash/#intro-to-bash","text":"Bash command, terminal command, command line command, for the purpose of our class these all mean the same things. You should already be familiar with bash from INFO 201 and INFO 340. This following section will help you refresh some of the basics. Huh, Bash? If you feel completely lost and have never seen terminal commands we recommend watching these two videos: Beginner's Guide to the Bash Terminal Udacity Shell Workshop","title":"Intro to Bash"},{"location":"resources/bash/#directories","text":"cd to change directories ls to show files and directories at your current path ls -a to also show hidden files","title":"Directories"},{"location":"resources/bash/#editing-files","text":"If you are editing a file on a remote server such as your Pi, you will not have the luxury of using a nice editor such as VS Code, Atom, or Sublime. Nevertheless, there are many powerful terminal editors. Use nano or vim to edit files through your terminal. How to edit a file that's on a linux server/your Pi: Use nano <fileName> or vim <filename> Nano is beginner friendly. If you are unfamiliar with these I recommend looking up a nano tutorial.","title":"Editing files"},{"location":"resources/bash/#command-documentation","text":"If you don't know what a command does or how to use it simply use the man command! man <commandName> will print out an documentation. Once you're done reading hit q on your keyboard to quit out. In the following screenshots I enter man nslookup which provides me with more information on what nslookup does and how it's used.","title":"Command documentation"},{"location":"resources/bash/#services-starting-stopping-status","text":"Control services by using the systemctl command. The format is sudo systemctl <action> <service name> . Example Restart NGINX service: sudo systemctl restart nginx","title":"Services: starting, stopping, status"},{"location":"resources/bash/#copying-files-across-servers-with-scp","text":"You can copy files from your laptop to a server or a server to your laptop by using scp . It uses our ssh tunnel to securely transfer your files back and forth. You can find great examples at hyperx.org . Copy all of the contents of a folder: scp -r ava/* root@157.230.163.231:/var/www/html/ This copies everything in the ava folder to the html folder.","title":"Copying Files Across Servers with scp"},{"location":"resources/bash/#local-vs-remote","text":"A typical confusion for students when deadling with scp is whether their current terminal session is doing work on their local machine (your laptop), or on a remote machine (your Raspberry Pi or another server). You can tell which device your terminal session is doing work in by checking the hostname, that is whatever is after the @ symbol. Take a look at the two example tabs below. Local # hostname = macbook-pro # This tells me I'm on my laptop. ben@macbook-pro:~/Desktop/info-314/ Remote # hostname = debian-lab1 # I must be on my server now. ben@debian-lab1:~$","title":"Local vs Remote"},{"location":"resources/bash/#logs","text":"Check a service's logs. This is a great way to see if it ran into any errors. If for some reason a service keeps crashing or behaving strangely you'd want to dig into its logs and see if it's unhappy with something. sudo journcalctl -u <service name> If you specifically only want to see the most recent parts of the log, you can pipe the information it gives you into the tail command, which only shows any files' ending lines. sudo journalctl -u <service name here>.service | tail -n 100","title":"Logs"},{"location":"resources/configure-routing-links/","text":"Configure a Routing Link for BGP Peers \u00b6 Determine Requirements \u00b6 In order to configure your your router to peer with other BGP routers, you will need to identify several parameters associated with the routing configuration. First, identify your ASN and select a unique IP address that you will assign as the router ID. Next determine which interface to use for the routing link, and identify the address ranges to be advertised to neighboring routers. We'll use the following values in this example: - Interface for routing link: vlan10 - Autonomous System Number (ASN): 65000 - Router ID: 172.23.0.129 - Advertise Network(s): 172.23.0.0/24 Prepare Interfaces \u00b6 To begin, we need to prepare the interface that we'll be using to peer with neighboring routers. In the past, this would have meant configuring IPv4 addresses for each side of the connection; however, we will be taking advantage of unnumbered BGP to identify and connect to our peers based on auto-configured IPv6 addresses. This simplification is welcome since the addresses we assign on point-to-point routing links generally serve no purpose other than facilitating communication between the adjacent routers. Our main task is to enable auto-configuration for IPv6 and to disable auto-configuration privacy extensions so that our MAC address will be encoded into the link-local IPv6 address for the interface. We also need to ensure that the routing interface will listen for and accept ICMPv6 router advertisements from its peer. Configure interface \u00b6 Create or edit a networkd .network configuration for the routing link, e.g., /etc/systemd/network/24-vlan10.network and ensure that the following IPv6 settings are in place. No IPv4 configuration will be performed on this link. [Match] Name=vlan10 [Network] # Enable link local addressing for IPv6 only LinkLocalAddressing=ipv6 # Watch for router advertisements so that we can learn about neighboring routers IPv6AcceptRA=yes # Required due to a bug in FRR (https://github.com/FRRouting/frr/issues/2205) IPv6PrivacyExtensions=no Configure FRRouting \u00b6 Set up address for BGP router ID \u00b6 The router can use any locally defined address as a router ID attached to BGP advertisements. Though we could use any one of our directly attached addresses, it is common to configure an ID on the loopback interface of the network device to ensure that it is available regardless of link status -- static addresses attached to physical interfaces are offline when the link is down. We'll perform this configuration within the FRR VTY shell ( launch using vtysh ): configure terminal interface lo ip address 172.23.0.129/32 quit Additional unnumbered routing configuration \u00b6 Routers in an unnumbered peering relationship rely on ICMPv6 router advertisements to discover peers on a routing link. We previously configured our interface to accept these messages, but we still need to set up the routing daemon to generate the messages on the specified interface. The following commands will turn on ICMPv6 router advertisements and set an interval of one advertisement every 5 seconds (as recommended by FRR documentation). Enter the following commands in the VTY shell: configure terminal interface vlan10 ipv6 nd ra-interval 5 no ipv6 nd suppress-ra quit Configure BGP Routing \u00b6 Once the preliminary configuration is complete, we can setup the BGP daemon to peer on the specified interface. The following example will enable a new router in ASN 65000 that peers over the vlan10 interface and advertises routes for 172.23.0.0/24. Enter the following commands in VTY shell: configure terminal router bgp 65000 bgp router-id 172.23.0.129 neighbor vlan10 interface remote-as external network 172.23.0.0/24 quit Supporting multiple routing links on a single router requires a simple modification to this script to add additional neighbor statements. If you've already configured other details, you don't need to repeat them to add an aditional neighbor. Enter the following commands to resume editing your existing router: configure terminal router bgp 65000 Save Your Changes \u00b6 Don't forget that live updates to FRR are not persistent. Rebooting the router or restarting frr will dispose of any settings that are not written to the startup config. To save your changes, you need to be in enable mode. Exit out of configure mode, if necessary, and call copy running-config startup-config or write memory . From the Linux commandline, you can view the current startup configuration within /etc/frr/frr.conf .","title":"Configuring Routing Links"},{"location":"resources/configure-routing-links/#configure-a-routing-link-for-bgp-peers","text":"","title":"Configure a Routing Link for BGP Peers"},{"location":"resources/configure-routing-links/#determine-requirements","text":"In order to configure your your router to peer with other BGP routers, you will need to identify several parameters associated with the routing configuration. First, identify your ASN and select a unique IP address that you will assign as the router ID. Next determine which interface to use for the routing link, and identify the address ranges to be advertised to neighboring routers. We'll use the following values in this example: - Interface for routing link: vlan10 - Autonomous System Number (ASN): 65000 - Router ID: 172.23.0.129 - Advertise Network(s): 172.23.0.0/24","title":"Determine Requirements"},{"location":"resources/configure-routing-links/#prepare-interfaces","text":"To begin, we need to prepare the interface that we'll be using to peer with neighboring routers. In the past, this would have meant configuring IPv4 addresses for each side of the connection; however, we will be taking advantage of unnumbered BGP to identify and connect to our peers based on auto-configured IPv6 addresses. This simplification is welcome since the addresses we assign on point-to-point routing links generally serve no purpose other than facilitating communication between the adjacent routers. Our main task is to enable auto-configuration for IPv6 and to disable auto-configuration privacy extensions so that our MAC address will be encoded into the link-local IPv6 address for the interface. We also need to ensure that the routing interface will listen for and accept ICMPv6 router advertisements from its peer.","title":"Prepare Interfaces"},{"location":"resources/configure-routing-links/#configure-interface","text":"Create or edit a networkd .network configuration for the routing link, e.g., /etc/systemd/network/24-vlan10.network and ensure that the following IPv6 settings are in place. No IPv4 configuration will be performed on this link. [Match] Name=vlan10 [Network] # Enable link local addressing for IPv6 only LinkLocalAddressing=ipv6 # Watch for router advertisements so that we can learn about neighboring routers IPv6AcceptRA=yes # Required due to a bug in FRR (https://github.com/FRRouting/frr/issues/2205) IPv6PrivacyExtensions=no","title":"Configure interface"},{"location":"resources/configure-routing-links/#configure-frrouting","text":"","title":"Configure FRRouting"},{"location":"resources/configure-routing-links/#set-up-address-for-bgp-router-id","text":"The router can use any locally defined address as a router ID attached to BGP advertisements. Though we could use any one of our directly attached addresses, it is common to configure an ID on the loopback interface of the network device to ensure that it is available regardless of link status -- static addresses attached to physical interfaces are offline when the link is down. We'll perform this configuration within the FRR VTY shell ( launch using vtysh ): configure terminal interface lo ip address 172.23.0.129/32 quit","title":"Set up address for BGP router ID"},{"location":"resources/configure-routing-links/#additional-unnumbered-routing-configuration","text":"Routers in an unnumbered peering relationship rely on ICMPv6 router advertisements to discover peers on a routing link. We previously configured our interface to accept these messages, but we still need to set up the routing daemon to generate the messages on the specified interface. The following commands will turn on ICMPv6 router advertisements and set an interval of one advertisement every 5 seconds (as recommended by FRR documentation). Enter the following commands in the VTY shell: configure terminal interface vlan10 ipv6 nd ra-interval 5 no ipv6 nd suppress-ra quit","title":"Additional unnumbered routing configuration"},{"location":"resources/configure-routing-links/#configure-bgp-routing","text":"Once the preliminary configuration is complete, we can setup the BGP daemon to peer on the specified interface. The following example will enable a new router in ASN 65000 that peers over the vlan10 interface and advertises routes for 172.23.0.0/24. Enter the following commands in VTY shell: configure terminal router bgp 65000 bgp router-id 172.23.0.129 neighbor vlan10 interface remote-as external network 172.23.0.0/24 quit Supporting multiple routing links on a single router requires a simple modification to this script to add additional neighbor statements. If you've already configured other details, you don't need to repeat them to add an aditional neighbor. Enter the following commands to resume editing your existing router: configure terminal router bgp 65000","title":"Configure BGP Routing"},{"location":"resources/configure-routing-links/#save-your-changes","text":"Don't forget that live updates to FRR are not persistent. Rebooting the router or restarting frr will dispose of any settings that are not written to the startup config. To save your changes, you need to be in enable mode. Exit out of configure mode, if necessary, and call copy running-config startup-config or write memory . From the Linux commandline, you can view the current startup configuration within /etc/frr/frr.conf .","title":"Save Your Changes"},{"location":"resources/digital-ocean/","text":"Digital Ocean Signup \u00b6 In our first lab, you will learn how to interact with a headless (no monitor, only a terminal) Linux server. We will interact with Linux a lot in this class, as your Raspberry Pi will run only as a headless Linux server. To dive into Linux servers, we will have you use DigitalOcean, a web hosting platform, to create a virtual machine. Please follow these instructions to sign up for DigitalOcean. Warning Please use our link to sign-up or you will not get any free credits! In order to be able to complete week 1's lab, you will need to complete the following steps before class Make a new account in DigitalOcean: Sign-up Link Please use our link to sign-up or you will not get any free credits! You can sign up with Google or GitHub if you'd like, or create new credentials, it doesn't matter Note: Some students were having issues using their @uw.edu email, I would suggest using something else, like a gmail account Confirm your DigitalOcean account by clicking the link you are emailed after signing up Next, you'll be taken to a billing page for DigitalOcean. You will need to add a credit or debit card. Don't worry, we'll only be using free credits, you won't be charged on your card. As long as you close your virtual machine when we email you in a few weeks, you will be fine and spend nothing. Please don't use PayPal, because that requires you making an initial deposit of $5 in your account. Next, you'll be taken to a page to create your first project. Skip this step by clicking your user icon in the top right of the screen and selecting 'Account' You should now see '$100.00 Credit Remaining' at the top-right of your window. If you do, you're good to go! On Tuesday (3/31), we will set up a server in DigitalOcean and introduce you to the tools that allow you to work remotely.","title":"Digital Ocean Signup"},{"location":"resources/digital-ocean/#digital-ocean-signup","text":"In our first lab, you will learn how to interact with a headless (no monitor, only a terminal) Linux server. We will interact with Linux a lot in this class, as your Raspberry Pi will run only as a headless Linux server. To dive into Linux servers, we will have you use DigitalOcean, a web hosting platform, to create a virtual machine. Please follow these instructions to sign up for DigitalOcean. Warning Please use our link to sign-up or you will not get any free credits! In order to be able to complete week 1's lab, you will need to complete the following steps before class Make a new account in DigitalOcean: Sign-up Link Please use our link to sign-up or you will not get any free credits! You can sign up with Google or GitHub if you'd like, or create new credentials, it doesn't matter Note: Some students were having issues using their @uw.edu email, I would suggest using something else, like a gmail account Confirm your DigitalOcean account by clicking the link you are emailed after signing up Next, you'll be taken to a billing page for DigitalOcean. You will need to add a credit or debit card. Don't worry, we'll only be using free credits, you won't be charged on your card. As long as you close your virtual machine when we email you in a few weeks, you will be fine and spend nothing. Please don't use PayPal, because that requires you making an initial deposit of $5 in your account. Next, you'll be taken to a page to create your first project. Skip this step by clicking your user icon in the top right of the screen and selecting 'Account' You should now see '$100.00 Credit Remaining' at the top-right of your window. If you do, you're good to go! On Tuesday (3/31), we will set up a server in DigitalOcean and introduce you to the tools that allow you to work remotely.","title":"Digital Ocean Signup"},{"location":"resources/dns-clients/","text":"Managing DNS clients \u00b6 View or clear your local DNS cache \u00b6 As applications make DNS queries to obtain the IP addresses of remote resources, your operating system will start to maintain a cache of previous responses. These cached responses are used on subsequent lookups in order to reduce network overhead and speed up the process of loading the applicable resources. Clearing your DNS cache is an operating system dependent operation: Windows 10 \u00b6 Open PowerShell as an administrator and run clear-dnsclientcache . macOS 10.11+: \u00b6 Run sudo killall -HUP mDNSResponder from Terminal 1 . Linux \u00b6 As an open source operating system with that comes in a variety of flavors, Linux users may find that some research is necessary to determine how DNS is managed in their distribution of choice and whether the system maintains a cache that can be cleared. Linux DNS caches may be incorporated into a resolver (systemd-resolved), provided by a standalone service (nscd), or built into a name server (bind9) running on localhost. A few of the most common options are listed below, along with the relevant command to restart the service and/or clear the cache directly. Service Description Command systemd-resolved DNS Resolver (distributed with systemd) sudo systemd-resolve --flush-caches nscd DNS Cache sudo systemctl restart nscd dnsmasq Name Server sudo systemctl restart dnsmasq bind9 Name Server sudo systemctl restart bind9 dns-clean DNS Resolver (previously used by Ubuntu) /etc/init.d/dns-clean restart Perform DNS lookups manually \u00b6 At times it can be helpful to perform DNS queries manually. Tools like dig allow us to query a nameserver and ask it to provide records about a particular host or domain. These tools provide us with an enormous amount of flexibility in interacting with DNS. Installing Dig \u00b6 The dig command balances flexibility with ease of use, making it a popular tool for troubleshooting issues with DNS or performing security-related research on a domain. The utility is installed by default on macOS and some Linux distributions. Instructions are provided below if dig isn't available on your system. Linux For Debian/Ubuntu based Linux including Arch, Mint, and Raspbian, dig is part of the dnsutils package and is installed with sudo apt install dnsutils . For Fedora/RedHat based Linux including CentOS, dig is part of the bind-utils package and can be installed with sudo dnf install bind-utils -- use sudo yum install bind-utils if dnf is not available. Windows Windows users may install dig by downloading ISC BIND 9 and installing with the Tools Only option 2 . Similar functionality is also provided by the PowerShell Resolve-DnsName command. Common Usage \u00b6 dig <domain name> : Request records for the given domain name. By default dig will send a query for A records (contain IPv4 addresses) to the default name server for the system. dig <type> <domain name> : Override the type in order to obtain cname (DNS aliases for the given name), mx (mail servers), or ns name servers for the given host or domain rather than the default A record. dig @<name server IP> <domain name> : Override the system's name server (often helpful to determine if other resolvers are returning different records). Example pi@titan.local:~ $ dig @1.1.1.1 cname uw.edu ; <<>> DiG 9.10.6 <<>> @1.1.1.1 cname uw.edu ; (1 server found) ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 50713 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1452 ;; QUESTION SECTION: ;uw.edu. IN CNAME ;; AUTHORITY SECTION: uw.edu. 600 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu. 2020012403 10800 1800 3600000 600 ;; Query time: 40 msec ;; SERVER: 1.1.1.1#53(1.1.1.1) ;; WHEN: Sun Jan 26 23:32:59 PST 2020 ;; MSG SIZE rcvd: 105 Resolving DNS with PowerShell \u00b6 PowerShell for Windows provides a powerful, scriptable DNS client that can be called via Resolve-DnsName . This tool replicates many of the features provided by dig, such as overriding the query type with the -type <type> option or the target server with -server <name server IP> . Run man Resolve-DnsName from PowerShell or view the online documentation to learn more about this command. Note that we are using sudo in order to perform this operation with root privileges. \u21a9 Detailed instructions provided at https://help.dyn.com/how-to-use-binds-dig-tool/ . \u21a9","title":"Managing DNS Clients"},{"location":"resources/dns-clients/#managing-dns-clients","text":"","title":"Managing DNS clients"},{"location":"resources/dns-clients/#view-or-clear-your-local-dns-cache","text":"As applications make DNS queries to obtain the IP addresses of remote resources, your operating system will start to maintain a cache of previous responses. These cached responses are used on subsequent lookups in order to reduce network overhead and speed up the process of loading the applicable resources. Clearing your DNS cache is an operating system dependent operation:","title":"View or clear your local DNS cache"},{"location":"resources/dns-clients/#windows-10","text":"Open PowerShell as an administrator and run clear-dnsclientcache .","title":"Windows 10"},{"location":"resources/dns-clients/#macos-1011","text":"Run sudo killall -HUP mDNSResponder from Terminal 1 .","title":"macOS 10.11+:"},{"location":"resources/dns-clients/#linux","text":"As an open source operating system with that comes in a variety of flavors, Linux users may find that some research is necessary to determine how DNS is managed in their distribution of choice and whether the system maintains a cache that can be cleared. Linux DNS caches may be incorporated into a resolver (systemd-resolved), provided by a standalone service (nscd), or built into a name server (bind9) running on localhost. A few of the most common options are listed below, along with the relevant command to restart the service and/or clear the cache directly. Service Description Command systemd-resolved DNS Resolver (distributed with systemd) sudo systemd-resolve --flush-caches nscd DNS Cache sudo systemctl restart nscd dnsmasq Name Server sudo systemctl restart dnsmasq bind9 Name Server sudo systemctl restart bind9 dns-clean DNS Resolver (previously used by Ubuntu) /etc/init.d/dns-clean restart","title":"Linux"},{"location":"resources/dns-clients/#perform-dns-lookups-manually","text":"At times it can be helpful to perform DNS queries manually. Tools like dig allow us to query a nameserver and ask it to provide records about a particular host or domain. These tools provide us with an enormous amount of flexibility in interacting with DNS.","title":"Perform DNS lookups manually"},{"location":"resources/dns-clients/#installing-dig","text":"The dig command balances flexibility with ease of use, making it a popular tool for troubleshooting issues with DNS or performing security-related research on a domain. The utility is installed by default on macOS and some Linux distributions. Instructions are provided below if dig isn't available on your system. Linux For Debian/Ubuntu based Linux including Arch, Mint, and Raspbian, dig is part of the dnsutils package and is installed with sudo apt install dnsutils . For Fedora/RedHat based Linux including CentOS, dig is part of the bind-utils package and can be installed with sudo dnf install bind-utils -- use sudo yum install bind-utils if dnf is not available. Windows Windows users may install dig by downloading ISC BIND 9 and installing with the Tools Only option 2 . Similar functionality is also provided by the PowerShell Resolve-DnsName command.","title":"Installing Dig"},{"location":"resources/dns-clients/#common-usage","text":"dig <domain name> : Request records for the given domain name. By default dig will send a query for A records (contain IPv4 addresses) to the default name server for the system. dig <type> <domain name> : Override the type in order to obtain cname (DNS aliases for the given name), mx (mail servers), or ns name servers for the given host or domain rather than the default A record. dig @<name server IP> <domain name> : Override the system's name server (often helpful to determine if other resolvers are returning different records). Example pi@titan.local:~ $ dig @1.1.1.1 cname uw.edu ; <<>> DiG 9.10.6 <<>> @1.1.1.1 cname uw.edu ; (1 server found) ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 50713 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1452 ;; QUESTION SECTION: ;uw.edu. IN CNAME ;; AUTHORITY SECTION: uw.edu. 600 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu. 2020012403 10800 1800 3600000 600 ;; Query time: 40 msec ;; SERVER: 1.1.1.1#53(1.1.1.1) ;; WHEN: Sun Jan 26 23:32:59 PST 2020 ;; MSG SIZE rcvd: 105","title":"Common Usage"},{"location":"resources/dns-clients/#resolving-dns-with-powershell","text":"PowerShell for Windows provides a powerful, scriptable DNS client that can be called via Resolve-DnsName . This tool replicates many of the features provided by dig, such as overriding the query type with the -type <type> option or the target server with -server <name server IP> . Run man Resolve-DnsName from PowerShell or view the online documentation to learn more about this command. Note that we are using sudo in order to perform this operation with root privileges. \u21a9 Detailed instructions provided at https://help.dyn.com/how-to-use-binds-dig-tool/ . \u21a9","title":"Resolving DNS with PowerShell"},{"location":"resources/host-config/","text":"Mac/Windows/Linux Networking \u00b6 Renewing DHCP Leases \u00b6 dhcp renewal is when a dhcp client (your laptop, phone, tablet...) renews or updates its IP address configuration with the dhcp server. Often times in our homes the dhcp server is already packaged in our router source . macOS \u00b6 Important The Renew DHCP Lease button for macOS will not result in a complete DHCP Exchange. Be sure to follow the instructions below. Go to Network Preferences >> Select interface >> Advanced -> TCP/IP, Turn off IPv4 Addressing (hit OK + Apply) Return to advanced settings and enable DHCP (hit OK + Apply). Windows \u00b6 Open a command prompt Run ipconfig /release Wi-Fi to release your IP address Wait for the release command to complete and run ipconfig /renew to request a new one Linux \u00b6 Important Linux instructions will vary depending on your target distribution. You may need to search online for alternative instructions. sudo dhclient -r eth0 sudo dhclient eth0 Managing ARP Cache \u00b6 Every computer maintains a cache of associations of ARP responses that have recently appeared on the network. In order to examine ARP functionality or troubleshoot the behavior of a particular network device, you may need to flush the existing contents. Windows \u00b6 Open an Administrator Command Prompt or PowerShell Session and run arp -d Unix (MacOS) \u00b6 sudo arp -ad Linux \u00b6 For the following command, substitute the name of your own network interface for : sudo ip neigh flush dev <wlan0>","title":"Mac/Win/Linux Networking"},{"location":"resources/host-config/#macwindowslinux-networking","text":"","title":"Mac/Windows/Linux Networking"},{"location":"resources/host-config/#renewing-dhcp-leases","text":"dhcp renewal is when a dhcp client (your laptop, phone, tablet...) renews or updates its IP address configuration with the dhcp server. Often times in our homes the dhcp server is already packaged in our router source .","title":"Renewing DHCP Leases"},{"location":"resources/host-config/#macos","text":"Important The Renew DHCP Lease button for macOS will not result in a complete DHCP Exchange. Be sure to follow the instructions below. Go to Network Preferences >> Select interface >> Advanced -> TCP/IP, Turn off IPv4 Addressing (hit OK + Apply) Return to advanced settings and enable DHCP (hit OK + Apply).","title":"macOS"},{"location":"resources/host-config/#windows","text":"Open a command prompt Run ipconfig /release Wi-Fi to release your IP address Wait for the release command to complete and run ipconfig /renew to request a new one","title":"Windows"},{"location":"resources/host-config/#linux","text":"Important Linux instructions will vary depending on your target distribution. You may need to search online for alternative instructions. sudo dhclient -r eth0 sudo dhclient eth0","title":"Linux"},{"location":"resources/host-config/#managing-arp-cache","text":"Every computer maintains a cache of associations of ARP responses that have recently appeared on the network. In order to examine ARP functionality or troubleshoot the behavior of a particular network device, you may need to flush the existing contents.","title":"Managing ARP Cache"},{"location":"resources/host-config/#windows_1","text":"Open an Administrator Command Prompt or PowerShell Session and run arp -d","title":"Windows"},{"location":"resources/host-config/#unix-macos","text":"sudo arp -ad","title":"Unix (MacOS)"},{"location":"resources/host-config/#linux_1","text":"For the following command, substitute the name of your own network interface for : sudo ip neigh flush dev <wlan0>","title":"Linux"},{"location":"resources/iptables/","text":"Introduction to Iptables \u00b6 This guide serves the dual purpose of providing an introductino to iptables and using it to build a basic ruleset that routes packets between an internal and external network while also applying NAT to private, internal addresses. You should read the entire guide carefully before attempting to install the template or any of the other tools referenced here. Tables, Chains, and Rule Syntax \u00b6 Iptables is a tool that has been used for more than 20 years to allow administrators to manage packet filter rules that shape the behavior of the Linux kernel's network stack. Tables \u00b6 Iptables uses a basic structure called a table to group rules according to their main function. Common tables include nat , filter , mangle , and raw . For this exercise, we'll focus on the nat table to implement address translation between private and public addresses along with the filter table to protect our network from outside traffic. Chains \u00b6 Within each table, rules are assigned to a structure called a chain. A chain is nothing more than an ordered list of rules. Rule conditions are tested in order from the beginning of the chain. Each rule ends with an action. If the conditions of a rule match, iptables will apply the specified action or jump to another chain without processing the other rules. If conditions do not match, the next rule in the chain will be evaluated. The default chains correspond to different points in the packet lifecycle. Within the filter table, we will often work with the INPUT , OUTPUT , and FORWARD chains. These chains correspond to packets sent to the host ( INPUT ), packets being sent by the host ( OUTPUT ), and packets being routed through the host ( FORWARD ). Within the nat table, our focus will be on the POSTROUTING chain. This chain represents the last set of rules that will be evaluated before forwarding a filtered packet. This is where we want to apply address mappings related to SNAT and masquerading. In contrast, the PREROUTING chain is applied before any other process and is used to specify DNAT rules. For a more detailed exploration of the chains we have discussed, see Understanding Netfilter/Iptables Hooks . Managing Rules from the Command Line \u00b6 We can load a set of iptables rules from a file or manage them directly from the command line with the iptables command ( sudo is required). As we explain the structure of rules, we will provide examples using the command line variant of iptables rule syntax. The first component of a rule specified from the command line is the table name. Specify the table using the -t option to the iptables command . If you don't specify a table explicitly, the filter table will be used by default. When working with rules via the command line, we have to work with rules one at a time and specify the order of operations as we go. Recall from the last section that the order of rules in a chain is significant. We can append new rules to the end of a chain using the -A option or insert rules at the beginning of a chain using -I . Likewise, we can delete a rule from a chain by specifying -D and providing a numeric index to the rule. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Appending Rules Append a rule to the end of the POSTROUTING chain of the nat table ... iptables -t nat -A POSTROUTING <conditions> <actions> Example: Deleting Rules Delete the first rule from the FORWARD chain of filter iptables -D FORWARD 1 Customize Rules with Filter Conditions \u00b6 In addition to specifying table and chain, our rules need to describe the criteria associated with packets we want to filter or manipulate. In this exercise, our primary consideration is the direction of traffic for a given packet, which we describe by specifying the ingress and/or egress interface for a given packet. Attention Throughout the instructions, we'll refer to the internal interface as our <LAN> (because it serves our local network) and the external interface as the <WAN> (because it connects us to the Internet). Your configuration files will reflect the Raspbian-assigned interface names, such as: eth0 and wlan0 . It's up to you to determine, based on your learning so far, which interface corresponds to which placeholder. For example, we want to apply address translation to outbound packets, i.e., packets being forwarded in the <LAN> interface and out the <WAN> interface. We can specify this restriction in our nat rule by providing the -o option with the name of the outbound interface. Likewise, we can instruct iptables to look at packets coming from the <LAN> and to the <WAN> by combining the -i option with -o in our filter rules. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Adding filter conditions to rules This NAT rule will be applied on outbound traffic that's being routed to the WAN network. iptables -t NAT -A POSTROUTING -o <WAN> <actions> Example: Combining multiple filters The following filter rule will be applied to outbound traffic that's being forwarded from the LAN to the WAN. iptables -A FORWARD -i <LAN> -o <WAN> <actions> Using Connection State in Rules \u00b6 Iptables is stateful , meaning that it is even possible to specify rules based on the relationship of a packet to other packets that were processed by iptables. This feature shapes our rules in two ways. First, you'll notice that we only have to specify the masquerade rule in the outward direction. The same rule also handles the de-masquerading process for incoming packets. Second, you'll see that we can base filtering decisions on connection state itself. While it's appropriate for NAT routers to allow outgoing traffic, we typically want to place greater restrictions on incoming traffic. When configuring a gateway connection for a home or office, we often block incoming traffic unless it relates to existing connections from the LAN. Unsolicited traffic does not make sense in this context and poses a security risk. To accomplish this feat, we will make use of netfilter's connection tracking extensions which are specified with the -m conntrack and --ctstate RELATED,ESTABLISHED options. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Using the connection tracking extension Check the connection state of ingress traffic. iptables -A FORWARD -i <WAN> -m conntrack --ctstate RELATED,ESTABLISHED <action> Specify an Action \u00b6 The last component of an iptables rule is specified using the -j option. In a simple configuration, this option provides the action to be carried out against the packet after the match. While we will encounter the MASQUERADE option in our NAT rules, we will more frequently with basic ACCEPT and DROP rules within the filter context. In more complex configurations, -j can point to user-defined chains containing additional rules that relate to the pattern you just matched. As you gain experience, you'll see that this provides a greater degree of organization and control flow. Bringing this option together with the earlier examples, we can express complete rules using the following syntax: iptables -t nat -A POSTROUTING -o <WAN> -j MASQUERADE iptables -A FORWARD -i <WAN> -o <LAN> -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT Default Actions \u00b6 We haven't yet said what will happen if your iptables chains complete without any matching rules. Each iptables chain defines a policy that specifies the default actions that will be taken if no other rule matches in a chain. Default policies are commonly used with the filter chains to implement a posture of failing securely, blocking traffic that wasn't explicitly allowed. # Don't forward packets unless there was an explicit rule match iptables -P FORWARD DROP Be careful, however, that you don't lock yourself out by a bad combination of rules and policies. For example, setting -P INPUT DROP and -P OUTPUT DROP will block all inbound and outbound traffic to your Pi unless you previously added rules to explicitly allow SSH or other tools that are needed for management purposes. Even when you correctly add these rules, it's relatively easy to lock yourself out of a device by flushing your current ruleset -- deleting the rules from all chains while leaving your policies intact. Final NAT Template \u00b6 The following template draws together all of the components we have discussed so far to define a basic NAT configuration for a Linux router. The syntax for this template differs somewhat from the commands we explored above. Rather than invoking each rule or policy in this file through the iptables command, this template would be applied via iptables-restore or iptables-apply . To prepare to use this template, save a copy of this template to the home directory (file name does not matter) of your Linux router. Pay close attention to the comments within the file, since they explain some of the differences in syntax. # Fill in the parameters in <> in order to complete the ruleset # Rules are given on a table-by-table basis, beginning with the *<table> and # ending with COMMIT. # Rules are appended to a chain using the -A <chain> syntax. Parameters vary # somewhat by chain and type of effect desired. # The -j switch instructs the rules engine to jump to another chain or perform # the action on the matched packet. The engine will not evaluate any more rules # in the given chain. # The default policy for a chain is given by the lines beginning with # :<chain>. The [0:0] resets the packet/byte counters that tell us how many # times the default policy has been applied. Note that default policy is # evaluated after all rules, so it only applies if there were not any matches. *nat -A POSTROUTING -o <interface> -j MASQUERADE COMMIT *filter :FORWARD <action> [0:0] -A FORWARD -i <interface> -o <interface> -j ACCEPT -A FORWARD -i <interface> -o <interface> -m conntrack --ctstate RELATED,ESTABLISHED -j <action> COMMIT Loading rules from the file system with iptables-persistent \u00b6 For simplicity, we\u2019ll rely on on a collection of tools called iptables-persistent to test our rules and then load them automatically at boot. Here be Dragons Do not write rules directly to /etc/iptables/rules.v4 . If you do this, you risk creating a rule that locks you out of your device from the network. Without an external monitor and keyboard, you will not be able to bypass these changes since they are loaded at boot. We are presenting iptables-persistent to provide you with a tool that allows us you to apply new rules safely by testing changes before making them fully persistent. Like many other tools, iptables-persistent is available as a package in Debian's package repository. This package contains tools to help you test new rules and install them into the /etc/iptables/rules.v4 path so that they can be loaded automatically in the future. Use apt to install the iptables-persistent package before attempting the instructions below. Make a copy of your rules within your home directory (file name does not matter) and use the iptables-apply command as shown below to test that they work before writing them to /etc/iptables/rules.v4 . While it is possible to edit /etc/iptables/rules.v4 directly, we recomend against it. The following command will flush iptables and load the rules given in ~/untested_rules . After loading the rules, iptables-apply waits for 60 seconds while you confirm that you can still SSH into the device from a second terminal tab or window. If your rules work as intended, you need respond affirmatively at this final prompt within the time limit so that iptables-apply can write them to a permanent location. If you skip this step, iptables-apply will assume that your test failed and restore the old version of the rules. sudo iptables-apply -t 60 -w /etc/iptables/rules.v4 ~/untested_rules After running the command, you\u2019ll have one minute to check that everything is working and confirm that you\u2019re ready to apply the rules. If everything checks out, the rules will be written to /etc/iptables/rules.v4 (where iptables-persistent can load them at boot). If your connection is interrupted or you decide not to keep the rules, the rules will be reset when the timer expires so that you con continue to access your Pi. As a final test that your rules are loaded, reboot the Pi, connect with SSH, and list the rules with sudo iptables-save . If you don\u2019t see your rules, something went wrong. Resources \u00b6 Understanding Netfilter/Iptables Hooks Digital Ocean Tutorial - Iptables and Netfilter Deep Dive Linux Network Administrators Guide - Masquerading DigitalOcean Tutorial - Manipulate Iptables Rules","title":"Introduction to Iptables"},{"location":"resources/iptables/#introduction-to-iptables","text":"This guide serves the dual purpose of providing an introductino to iptables and using it to build a basic ruleset that routes packets between an internal and external network while also applying NAT to private, internal addresses. You should read the entire guide carefully before attempting to install the template or any of the other tools referenced here.","title":"Introduction to Iptables"},{"location":"resources/iptables/#tables-chains-and-rule-syntax","text":"Iptables is a tool that has been used for more than 20 years to allow administrators to manage packet filter rules that shape the behavior of the Linux kernel's network stack.","title":"Tables, Chains, and Rule Syntax"},{"location":"resources/iptables/#tables","text":"Iptables uses a basic structure called a table to group rules according to their main function. Common tables include nat , filter , mangle , and raw . For this exercise, we'll focus on the nat table to implement address translation between private and public addresses along with the filter table to protect our network from outside traffic.","title":"Tables"},{"location":"resources/iptables/#chains","text":"Within each table, rules are assigned to a structure called a chain. A chain is nothing more than an ordered list of rules. Rule conditions are tested in order from the beginning of the chain. Each rule ends with an action. If the conditions of a rule match, iptables will apply the specified action or jump to another chain without processing the other rules. If conditions do not match, the next rule in the chain will be evaluated. The default chains correspond to different points in the packet lifecycle. Within the filter table, we will often work with the INPUT , OUTPUT , and FORWARD chains. These chains correspond to packets sent to the host ( INPUT ), packets being sent by the host ( OUTPUT ), and packets being routed through the host ( FORWARD ). Within the nat table, our focus will be on the POSTROUTING chain. This chain represents the last set of rules that will be evaluated before forwarding a filtered packet. This is where we want to apply address mappings related to SNAT and masquerading. In contrast, the PREROUTING chain is applied before any other process and is used to specify DNAT rules. For a more detailed exploration of the chains we have discussed, see Understanding Netfilter/Iptables Hooks .","title":"Chains"},{"location":"resources/iptables/#managing-rules-from-the-command-line","text":"We can load a set of iptables rules from a file or manage them directly from the command line with the iptables command ( sudo is required). As we explain the structure of rules, we will provide examples using the command line variant of iptables rule syntax. The first component of a rule specified from the command line is the table name. Specify the table using the -t option to the iptables command . If you don't specify a table explicitly, the filter table will be used by default. When working with rules via the command line, we have to work with rules one at a time and specify the order of operations as we go. Recall from the last section that the order of rules in a chain is significant. We can append new rules to the end of a chain using the -A option or insert rules at the beginning of a chain using -I . Likewise, we can delete a rule from a chain by specifying -D and providing a numeric index to the rule. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Appending Rules Append a rule to the end of the POSTROUTING chain of the nat table ... iptables -t nat -A POSTROUTING <conditions> <actions> Example: Deleting Rules Delete the first rule from the FORWARD chain of filter iptables -D FORWARD 1","title":"Managing Rules from the Command Line"},{"location":"resources/iptables/#customize-rules-with-filter-conditions","text":"In addition to specifying table and chain, our rules need to describe the criteria associated with packets we want to filter or manipulate. In this exercise, our primary consideration is the direction of traffic for a given packet, which we describe by specifying the ingress and/or egress interface for a given packet. Attention Throughout the instructions, we'll refer to the internal interface as our <LAN> (because it serves our local network) and the external interface as the <WAN> (because it connects us to the Internet). Your configuration files will reflect the Raspbian-assigned interface names, such as: eth0 and wlan0 . It's up to you to determine, based on your learning so far, which interface corresponds to which placeholder. For example, we want to apply address translation to outbound packets, i.e., packets being forwarded in the <LAN> interface and out the <WAN> interface. We can specify this restriction in our nat rule by providing the -o option with the name of the outbound interface. Likewise, we can instruct iptables to look at packets coming from the <LAN> and to the <WAN> by combining the -i option with -o in our filter rules. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Adding filter conditions to rules This NAT rule will be applied on outbound traffic that's being routed to the WAN network. iptables -t NAT -A POSTROUTING -o <WAN> <actions> Example: Combining multiple filters The following filter rule will be applied to outbound traffic that's being forwarded from the LAN to the WAN. iptables -A FORWARD -i <LAN> -o <WAN> <actions>","title":"Customize Rules with Filter Conditions"},{"location":"resources/iptables/#using-connection-state-in-rules","text":"Iptables is stateful , meaning that it is even possible to specify rules based on the relationship of a packet to other packets that were processed by iptables. This feature shapes our rules in two ways. First, you'll notice that we only have to specify the masquerade rule in the outward direction. The same rule also handles the de-masquerading process for incoming packets. Second, you'll see that we can base filtering decisions on connection state itself. While it's appropriate for NAT routers to allow outgoing traffic, we typically want to place greater restrictions on incoming traffic. When configuring a gateway connection for a home or office, we often block incoming traffic unless it relates to existing connections from the LAN. Unsolicited traffic does not make sense in this context and poses a security risk. To accomplish this feat, we will make use of netfilter's connection tracking extensions which are specified with the -m conntrack and --ctstate RELATED,ESTABLISHED options. Copy/Paste Warning These are examples only. Keep reading to learn how to build complete rules. Example: Using the connection tracking extension Check the connection state of ingress traffic. iptables -A FORWARD -i <WAN> -m conntrack --ctstate RELATED,ESTABLISHED <action>","title":"Using Connection State in Rules"},{"location":"resources/iptables/#specify-an-action","text":"The last component of an iptables rule is specified using the -j option. In a simple configuration, this option provides the action to be carried out against the packet after the match. While we will encounter the MASQUERADE option in our NAT rules, we will more frequently with basic ACCEPT and DROP rules within the filter context. In more complex configurations, -j can point to user-defined chains containing additional rules that relate to the pattern you just matched. As you gain experience, you'll see that this provides a greater degree of organization and control flow. Bringing this option together with the earlier examples, we can express complete rules using the following syntax: iptables -t nat -A POSTROUTING -o <WAN> -j MASQUERADE iptables -A FORWARD -i <WAN> -o <LAN> -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT","title":"Specify an Action"},{"location":"resources/iptables/#default-actions","text":"We haven't yet said what will happen if your iptables chains complete without any matching rules. Each iptables chain defines a policy that specifies the default actions that will be taken if no other rule matches in a chain. Default policies are commonly used with the filter chains to implement a posture of failing securely, blocking traffic that wasn't explicitly allowed. # Don't forward packets unless there was an explicit rule match iptables -P FORWARD DROP Be careful, however, that you don't lock yourself out by a bad combination of rules and policies. For example, setting -P INPUT DROP and -P OUTPUT DROP will block all inbound and outbound traffic to your Pi unless you previously added rules to explicitly allow SSH or other tools that are needed for management purposes. Even when you correctly add these rules, it's relatively easy to lock yourself out of a device by flushing your current ruleset -- deleting the rules from all chains while leaving your policies intact.","title":"Default Actions"},{"location":"resources/iptables/#final-nat-template","text":"The following template draws together all of the components we have discussed so far to define a basic NAT configuration for a Linux router. The syntax for this template differs somewhat from the commands we explored above. Rather than invoking each rule or policy in this file through the iptables command, this template would be applied via iptables-restore or iptables-apply . To prepare to use this template, save a copy of this template to the home directory (file name does not matter) of your Linux router. Pay close attention to the comments within the file, since they explain some of the differences in syntax. # Fill in the parameters in <> in order to complete the ruleset # Rules are given on a table-by-table basis, beginning with the *<table> and # ending with COMMIT. # Rules are appended to a chain using the -A <chain> syntax. Parameters vary # somewhat by chain and type of effect desired. # The -j switch instructs the rules engine to jump to another chain or perform # the action on the matched packet. The engine will not evaluate any more rules # in the given chain. # The default policy for a chain is given by the lines beginning with # :<chain>. The [0:0] resets the packet/byte counters that tell us how many # times the default policy has been applied. Note that default policy is # evaluated after all rules, so it only applies if there were not any matches. *nat -A POSTROUTING -o <interface> -j MASQUERADE COMMIT *filter :FORWARD <action> [0:0] -A FORWARD -i <interface> -o <interface> -j ACCEPT -A FORWARD -i <interface> -o <interface> -m conntrack --ctstate RELATED,ESTABLISHED -j <action> COMMIT","title":"Final NAT Template"},{"location":"resources/iptables/#loading-rules-from-the-file-system-with-iptables-persistent","text":"For simplicity, we\u2019ll rely on on a collection of tools called iptables-persistent to test our rules and then load them automatically at boot. Here be Dragons Do not write rules directly to /etc/iptables/rules.v4 . If you do this, you risk creating a rule that locks you out of your device from the network. Without an external monitor and keyboard, you will not be able to bypass these changes since they are loaded at boot. We are presenting iptables-persistent to provide you with a tool that allows us you to apply new rules safely by testing changes before making them fully persistent. Like many other tools, iptables-persistent is available as a package in Debian's package repository. This package contains tools to help you test new rules and install them into the /etc/iptables/rules.v4 path so that they can be loaded automatically in the future. Use apt to install the iptables-persistent package before attempting the instructions below. Make a copy of your rules within your home directory (file name does not matter) and use the iptables-apply command as shown below to test that they work before writing them to /etc/iptables/rules.v4 . While it is possible to edit /etc/iptables/rules.v4 directly, we recomend against it. The following command will flush iptables and load the rules given in ~/untested_rules . After loading the rules, iptables-apply waits for 60 seconds while you confirm that you can still SSH into the device from a second terminal tab or window. If your rules work as intended, you need respond affirmatively at this final prompt within the time limit so that iptables-apply can write them to a permanent location. If you skip this step, iptables-apply will assume that your test failed and restore the old version of the rules. sudo iptables-apply -t 60 -w /etc/iptables/rules.v4 ~/untested_rules After running the command, you\u2019ll have one minute to check that everything is working and confirm that you\u2019re ready to apply the rules. If everything checks out, the rules will be written to /etc/iptables/rules.v4 (where iptables-persistent can load them at boot). If your connection is interrupted or you decide not to keep the rules, the rules will be reset when the timer expires so that you con continue to access your Pi. As a final test that your rules are loaded, reboot the Pi, connect with SSH, and list the rules with sudo iptables-save . If you don\u2019t see your rules, something went wrong.","title":"Loading rules from the file system with iptables-persistent"},{"location":"resources/iptables/#resources","text":"Understanding Netfilter/Iptables Hooks Digital Ocean Tutorial - Iptables and Netfilter Deep Dive Linux Network Administrators Guide - Masquerading DigitalOcean Tutorial - Manipulate Iptables Rules","title":"Resources"},{"location":"resources/manage-dhcp/","text":"DHCP \u00b6 DHCP advice will be updated and rolled out to this page. Reminder that the service dhcpd will handle dhcp for us. Renew dhcp lease \u00b6 Quote dhcp renewal is when a dhcp client (your laptop, phone, tablet...) renews or updates its IP address cofniguration with the dhcp server. Often times in our homes the dhcp server is already packaged in our router source . Unix (Mac OS) : This steps below are necessary since the renew button for mac os only does a shortened DHCP exchange. Go to Network Preferences >> Select interface >> Advanced -> TCP/IP, Turn off IPv4 Addressing (hit OK + Apply) Return to advanced settings and enable DHCP. Windows : Open a command prompt run ipconfig /release Wi-Fi to release your IP address then run ipconfig /renew to request a new one Linux : sudo dhclient -r eth0 sudo dhclient eth0 General Troubleshoot \u00b6 Follow the checklist below if you had dhcp previously working and it recently failed. Check DHCP errors journalctl -u isc-dhcp-server check subnet range in dhcpd.conf Check what wifi your pi is using the appropriate wifi wpa_cli -i wlan0 status Make sure both dhcpd and systemd are declaring the same statis IP for the Pi. Check your leases in at /var/lib/dhcp/dhcpd.leases Troubleshooting ISC DHCP Server \u00b6 Follow steps below if you are having trouble getting your ISC DHCP server setup for the first time. Raspbian provides us with several commands to troubleshoot and find errors related to services. Check status and recent log output using systemctl status isc-dhcp-server.service or journalctl -xe . Search the system logs for relevant errors journalctl -u isc-dhcp-server As you debug, keep the following points in mind: A misplaced space or bracket may cause DHCP to fail, so pay close attention to syntax. Your Pi will keep it's static address, so be sure that you excluded the address from the DHCP pool. Double check that you\u2019ve configured the server defaults with the correct interface names and commented out IPv6 related settings.","title":"Troubleshooting DHCP"},{"location":"resources/manage-dhcp/#dhcp","text":"DHCP advice will be updated and rolled out to this page. Reminder that the service dhcpd will handle dhcp for us.","title":"DHCP"},{"location":"resources/manage-dhcp/#renew-dhcp-lease","text":"Quote dhcp renewal is when a dhcp client (your laptop, phone, tablet...) renews or updates its IP address cofniguration with the dhcp server. Often times in our homes the dhcp server is already packaged in our router source . Unix (Mac OS) : This steps below are necessary since the renew button for mac os only does a shortened DHCP exchange. Go to Network Preferences >> Select interface >> Advanced -> TCP/IP, Turn off IPv4 Addressing (hit OK + Apply) Return to advanced settings and enable DHCP. Windows : Open a command prompt run ipconfig /release Wi-Fi to release your IP address then run ipconfig /renew to request a new one Linux : sudo dhclient -r eth0 sudo dhclient eth0","title":"Renew dhcp lease"},{"location":"resources/manage-dhcp/#general-troubleshoot","text":"Follow the checklist below if you had dhcp previously working and it recently failed. Check DHCP errors journalctl -u isc-dhcp-server check subnet range in dhcpd.conf Check what wifi your pi is using the appropriate wifi wpa_cli -i wlan0 status Make sure both dhcpd and systemd are declaring the same statis IP for the Pi. Check your leases in at /var/lib/dhcp/dhcpd.leases","title":"General Troubleshoot"},{"location":"resources/manage-dhcp/#troubleshooting-isc-dhcp-server","text":"Follow steps below if you are having trouble getting your ISC DHCP server setup for the first time. Raspbian provides us with several commands to troubleshoot and find errors related to services. Check status and recent log output using systemctl status isc-dhcp-server.service or journalctl -xe . Search the system logs for relevant errors journalctl -u isc-dhcp-server As you debug, keep the following points in mind: A misplaced space or bracket may cause DHCP to fail, so pay close attention to syntax. Your Pi will keep it's static address, so be sure that you excluded the address from the DHCP pool. Double check that you\u2019ve configured the server defaults with the correct interface names and commented out IPv6 related settings.","title":"Troubleshooting ISC DHCP Server"},{"location":"resources/markdown/","text":"Intro to Markdown \u00b6 What is Markdown? \u00b6 \"Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML)\" source . You will be expected to use this syntax for most of your reports. Every lab you do in this course will require a lab report, and a markdown template will be provided to make your life easier. You will also find a file called README.md in the root of all of your GitHub repo folders that you will need to edit to describe your projects. How do I get started? \u00b6 Don't worry if you are unfamiliar with Markdown, it's really easy to pick up. First, let's learn the syntax required to write a document in Markdown. Github has great documentation on all of the things you can do with it here: mastering-markdown guide. Once you've taken a look at it, you can follow this interactive tutorial: markdowntutorial.com . Editors \u00b6 Now that you've got the syntax down, it's time to download and set up an editor. Most text-editing applications will work with markdown files ( .md ), but they won't allow you to preview what your document will look like with all the formatting, it will just look like plain ##text## #with# -markdown formatting . Instead, you should use an editor developed with markdown in mind. There are two options presented in this course. Option One - Standalone Editor Typora \u00b6 A simple option for an editor is Typora. Typora is a simple Markdown viewer for Windows, Mac OS X, and Linux that allows you to preview and edit your Markdown document in both a source code and presentation format. You can switch between these formats with Ctrl + / on Windows or Cmd + / on Mac. You can download Typora here (download links are at the bottom of the page). Markdown -> PDF when using Typora \u00b6 Often you will need to attach images to a lab report. Unless you want to upload multiple files (the markdown document, plus the images with exact names for markdown to find them) it is recommended that you compile your lab report into a PDF after completion and submit that. In Typora, you can do this by clicking File > Export > PDF . Option Two - Using VS Code \u00b6 A slightly more complex option is to use Visual Studio Code. This might be the best option for you if you already use VS Code to program in other languages. To use VS Code to edit markdown documents, I recommend installing a couple extensions on VS code in order to make your life easier: Markdown Preview Github and Markdown All in One . Each has instructions at the time of installation on how to use them. Markdown -> PDF when using VS Code \u00b6 Often you will need to attach images to a lab report. Unless you want to upload multiple files (the markdown document, plus the images with exact names for markdown to find them) it is recommended that you compile your lab report into a PDF after completion and submit that. If you use VS Code as a Markdown editor, you should use a command line tool such as grip to export Markdown documents to pdf. grip is a command line tool that will easily convert your markdown file to a pdf or html file. Installation instruction github.com/joeyespo/grip Usage: grip <file name>.md --export","title":"Intro to Markdown"},{"location":"resources/markdown/#intro-to-markdown","text":"","title":"Intro to Markdown"},{"location":"resources/markdown/#what-is-markdown","text":"\"Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML)\" source . You will be expected to use this syntax for most of your reports. Every lab you do in this course will require a lab report, and a markdown template will be provided to make your life easier. You will also find a file called README.md in the root of all of your GitHub repo folders that you will need to edit to describe your projects.","title":"What is Markdown?"},{"location":"resources/markdown/#how-do-i-get-started","text":"Don't worry if you are unfamiliar with Markdown, it's really easy to pick up. First, let's learn the syntax required to write a document in Markdown. Github has great documentation on all of the things you can do with it here: mastering-markdown guide. Once you've taken a look at it, you can follow this interactive tutorial: markdowntutorial.com .","title":"How do I get started?"},{"location":"resources/markdown/#editors","text":"Now that you've got the syntax down, it's time to download and set up an editor. Most text-editing applications will work with markdown files ( .md ), but they won't allow you to preview what your document will look like with all the formatting, it will just look like plain ##text## #with# -markdown formatting . Instead, you should use an editor developed with markdown in mind. There are two options presented in this course.","title":"Editors"},{"location":"resources/markdown/#option-one-standalone-editor-typora","text":"A simple option for an editor is Typora. Typora is a simple Markdown viewer for Windows, Mac OS X, and Linux that allows you to preview and edit your Markdown document in both a source code and presentation format. You can switch between these formats with Ctrl + / on Windows or Cmd + / on Mac. You can download Typora here (download links are at the bottom of the page).","title":"Option One - Standalone Editor Typora"},{"location":"resources/markdown/#markdown-pdf-when-using-typora","text":"Often you will need to attach images to a lab report. Unless you want to upload multiple files (the markdown document, plus the images with exact names for markdown to find them) it is recommended that you compile your lab report into a PDF after completion and submit that. In Typora, you can do this by clicking File > Export > PDF .","title":"Markdown -&gt; PDF when using Typora"},{"location":"resources/markdown/#option-two-using-vs-code","text":"A slightly more complex option is to use Visual Studio Code. This might be the best option for you if you already use VS Code to program in other languages. To use VS Code to edit markdown documents, I recommend installing a couple extensions on VS code in order to make your life easier: Markdown Preview Github and Markdown All in One . Each has instructions at the time of installation on how to use them.","title":"Option Two - Using VS Code"},{"location":"resources/markdown/#markdown-pdf-when-using-vs-code","text":"Often you will need to attach images to a lab report. Unless you want to upload multiple files (the markdown document, plus the images with exact names for markdown to find them) it is recommended that you compile your lab report into a PDF after completion and submit that. If you use VS Code as a Markdown editor, you should use a command line tool such as grip to export Markdown documents to pdf. grip is a command line tool that will easily convert your markdown file to a pdf or html file. Installation instruction github.com/joeyespo/grip Usage: grip <file name>.md --export","title":"Markdown -&gt; PDF when using VS Code"},{"location":"resources/netfilter-hooks/","text":"Understanding Netfilter/Iptables Hooks \u00b6 The netfilter component of Linux defines a set of hooks within the TCP/IP stack that are used to run code based on different packet events at different moments in the packet lifecycle. Utilities like iptables (and more recently nftables) provide a frontend and language for managing rules and actions that we want to perform based on the characteristics of network traffic. These tools are commonly used to implement services like NAT or to provide host or network-based packet filtering firewalls. Working with Local Traffic \u00b6 To better understand how all of this works, let\u2019s start with a simplified example on a standard Linux host. For now, ignore the possibility of routing and focus on the host\u2019s ability to send or receive packets. In this scenario, we can use netfilter for tasks like dropping unwanted traffic or rewriting addresses and layer-3 ports on the fly. Since this is a simplified scenario, we can limit our examination to two hooks, INPUT and OUTPUT, that are triggered for packets flowing to and from the local device in a non-routing scenario. By non-routing, we mean that the INPUT hook is only invoked when the host is the intended recipient of the message based on the packet\u2019s destination IP address. Likewise, the OUTPUT hook won\u2019t fire unless the message originated from the local host. Given the INPUT/OUTPUT hooks, we can use a frontend like iptables to register specific rules and actions that are evaluated for each packet passing through the network stack. Host-based Packet Filters \u00b6 One of the most common applications of the INPUT/OUTPUT hooks is to perform packet filtering in order to provide a host-based firewall for the Linux device. For example, from a security perspective, we typically want to limit how much of an \u201cattack surface\u201d we expose over the network. We can leverage the INPUT hook to drop packets that aren\u2019t part of a TCP connection that we had previously initiated. In other words, we allow client-based software to open outbound connections but we block any attempts to connect to us as a server. If we need more flexibility, we can create rules to allow connections in to specific services, such as an HTTP or SSH daemon. Working with Routed Traffic \u00b6 Netfilter operations become slightly more complex when routing is introduced. Like an ordinary host, routers still process packets coming to/from the local device, but they also need to forward packets received on one network interface through other interfaces. In fact, this latter operation is their main responsibility. In order to support these communication paths, netfilter defines three additional hooks: FORWARD, PREROUTING, and POSTROUTING that we can use to perform network-based packet filtering, network address translation (NAT), and other packet-level operations. Network-based Packet Filters \u00b6 For packet-filtering purposes, the FORWARD hook is a direct analogue for the INPUT/OUTPUT hooks. As we\u2019ve mentioned, INPUT/OUTPUT are not applied to routed packets. Instead, code registered on the FORWARD hook will be evaluated after the initial routing decision is made. The FORWARD hook provides the basis for network-based firewall functionality. Network-based firewalls enable us to drop or reject unwanted traffic before it has the opportunity to reach our hosts (or even enter into the network). Likewise, we can also leverage packet filtering to prevent certain types of local traffic from inadvertently leaking outside our own network perimeters. Network Address Translation \u00b6 Sometimes it makes more sense to perform an action for an incoming packet before any routing decision has been made or just before actually sending an outgoing packet. This is the case for port and network address translation and is facilitated by attaching rules to the PREROUTING and POSTROUTING hooks. Specifically, we set up rules on the PREROUTING hook when we want to modify incoming packets based on their destination IP address. This configuration is called destination NAT (DNAT) and is useful for delivering traffic to a server on a private subnet. Likewise, we use the POSTROUTING hook when our goal is to change outgoing packets based on the original source address. This configuration is called source NAT (SNAT) and is useful when we need map a public IP on to packets coming from private addresses. Additional Caveats for Local Traffic \u00b6 Unlike the FORWARD hook, PREROUTING and POSTROUTING may be used for local traffic as well as routed traffic. In particular, an incoming packet will be processed by the PREROUTING hook before the network stack makes a routing decision and reaches the INPUT hook. For outgoing packets, the OUTPUT hook is invoked prior to the outbound routing/forwarding decision or the POSTROUTING hook. For local traffic, we often have a choice about which hook provides the best entry point for our rules. Summary \u00b6 When you're first learning about Linux networking internals, it can be difficult to remember the relationship between netfilter hooks and related events in the packet lifecycle. The following list summarizes what we've learned so far in terms of specific traffic flows. Incoming local traffic: (receive packet via network interface) -> PREROUTING -> (local routing decision) -> INPUT -> (continue processing packet and deliver via sockets) Outgoing local traffic: (receive packet via sockets) -> OUTPUT -> (outbound routing) -> POSTROUTING -> (continue processing and send via network interface) Routed traffic: (receive packet via network interface) -> PREROUTING -> (inbound routing) -> FORWARD -> (outbound routing) -> POSTROUTING -> (continue processing and send via network interface) As you work to digest each of these traffic flows, you can refer to the following list for a reminder of which operations can be performed by using a particular hook. Once again, we are distinguishing routed traffic from incoming and outgoing routed traffic. Filtering incoming traffic to local: INPUT Filtering outgoing traffic from local: OUTPUT Filtering routed traffic (in any direction): FORWARD SNAT for routed traffic: POSTROUTING SNAT for outgoing local traffic: POSTROUTING or OUTPUT DNAT for routed traffic: PREROUTING DNAT for incoming local traffic: PREROUTING or INPUT","title":"Understanding Netfilter/Iptables Hooks"},{"location":"resources/netfilter-hooks/#understanding-netfilteriptables-hooks","text":"The netfilter component of Linux defines a set of hooks within the TCP/IP stack that are used to run code based on different packet events at different moments in the packet lifecycle. Utilities like iptables (and more recently nftables) provide a frontend and language for managing rules and actions that we want to perform based on the characteristics of network traffic. These tools are commonly used to implement services like NAT or to provide host or network-based packet filtering firewalls.","title":"Understanding Netfilter/Iptables Hooks"},{"location":"resources/netfilter-hooks/#working-with-local-traffic","text":"To better understand how all of this works, let\u2019s start with a simplified example on a standard Linux host. For now, ignore the possibility of routing and focus on the host\u2019s ability to send or receive packets. In this scenario, we can use netfilter for tasks like dropping unwanted traffic or rewriting addresses and layer-3 ports on the fly. Since this is a simplified scenario, we can limit our examination to two hooks, INPUT and OUTPUT, that are triggered for packets flowing to and from the local device in a non-routing scenario. By non-routing, we mean that the INPUT hook is only invoked when the host is the intended recipient of the message based on the packet\u2019s destination IP address. Likewise, the OUTPUT hook won\u2019t fire unless the message originated from the local host. Given the INPUT/OUTPUT hooks, we can use a frontend like iptables to register specific rules and actions that are evaluated for each packet passing through the network stack.","title":"Working with Local Traffic"},{"location":"resources/netfilter-hooks/#host-based-packet-filters","text":"One of the most common applications of the INPUT/OUTPUT hooks is to perform packet filtering in order to provide a host-based firewall for the Linux device. For example, from a security perspective, we typically want to limit how much of an \u201cattack surface\u201d we expose over the network. We can leverage the INPUT hook to drop packets that aren\u2019t part of a TCP connection that we had previously initiated. In other words, we allow client-based software to open outbound connections but we block any attempts to connect to us as a server. If we need more flexibility, we can create rules to allow connections in to specific services, such as an HTTP or SSH daemon.","title":"Host-based Packet Filters"},{"location":"resources/netfilter-hooks/#working-with-routed-traffic","text":"Netfilter operations become slightly more complex when routing is introduced. Like an ordinary host, routers still process packets coming to/from the local device, but they also need to forward packets received on one network interface through other interfaces. In fact, this latter operation is their main responsibility. In order to support these communication paths, netfilter defines three additional hooks: FORWARD, PREROUTING, and POSTROUTING that we can use to perform network-based packet filtering, network address translation (NAT), and other packet-level operations.","title":"Working with Routed Traffic"},{"location":"resources/netfilter-hooks/#network-based-packet-filters","text":"For packet-filtering purposes, the FORWARD hook is a direct analogue for the INPUT/OUTPUT hooks. As we\u2019ve mentioned, INPUT/OUTPUT are not applied to routed packets. Instead, code registered on the FORWARD hook will be evaluated after the initial routing decision is made. The FORWARD hook provides the basis for network-based firewall functionality. Network-based firewalls enable us to drop or reject unwanted traffic before it has the opportunity to reach our hosts (or even enter into the network). Likewise, we can also leverage packet filtering to prevent certain types of local traffic from inadvertently leaking outside our own network perimeters.","title":"Network-based Packet Filters"},{"location":"resources/netfilter-hooks/#network-address-translation","text":"Sometimes it makes more sense to perform an action for an incoming packet before any routing decision has been made or just before actually sending an outgoing packet. This is the case for port and network address translation and is facilitated by attaching rules to the PREROUTING and POSTROUTING hooks. Specifically, we set up rules on the PREROUTING hook when we want to modify incoming packets based on their destination IP address. This configuration is called destination NAT (DNAT) and is useful for delivering traffic to a server on a private subnet. Likewise, we use the POSTROUTING hook when our goal is to change outgoing packets based on the original source address. This configuration is called source NAT (SNAT) and is useful when we need map a public IP on to packets coming from private addresses.","title":"Network Address Translation"},{"location":"resources/netfilter-hooks/#additional-caveats-for-local-traffic","text":"Unlike the FORWARD hook, PREROUTING and POSTROUTING may be used for local traffic as well as routed traffic. In particular, an incoming packet will be processed by the PREROUTING hook before the network stack makes a routing decision and reaches the INPUT hook. For outgoing packets, the OUTPUT hook is invoked prior to the outbound routing/forwarding decision or the POSTROUTING hook. For local traffic, we often have a choice about which hook provides the best entry point for our rules.","title":"Additional Caveats for Local Traffic"},{"location":"resources/netfilter-hooks/#summary","text":"When you're first learning about Linux networking internals, it can be difficult to remember the relationship between netfilter hooks and related events in the packet lifecycle. The following list summarizes what we've learned so far in terms of specific traffic flows. Incoming local traffic: (receive packet via network interface) -> PREROUTING -> (local routing decision) -> INPUT -> (continue processing packet and deliver via sockets) Outgoing local traffic: (receive packet via sockets) -> OUTPUT -> (outbound routing) -> POSTROUTING -> (continue processing and send via network interface) Routed traffic: (receive packet via network interface) -> PREROUTING -> (inbound routing) -> FORWARD -> (outbound routing) -> POSTROUTING -> (continue processing and send via network interface) As you work to digest each of these traffic flows, you can refer to the following list for a reminder of which operations can be performed by using a particular hook. Once again, we are distinguishing routed traffic from incoming and outgoing routed traffic. Filtering incoming traffic to local: INPUT Filtering outgoing traffic from local: OUTPUT Filtering routed traffic (in any direction): FORWARD SNAT for routed traffic: POSTROUTING SNAT for outgoing local traffic: POSTROUTING or OUTPUT DNAT for routed traffic: PREROUTING DNAT for incoming local traffic: PREROUTING or INPUT","title":"Summary"},{"location":"resources/pi-materials/","text":"Required Class Materials \u00b6 In this course, you will need to purchase a Raspberry Pi 4 B. Many of the labs and exercises in this course are built around the Raspberry Pi's hardware. The Pi is a compact, single-board computer that can be used to create a Linux-based router and other common network components. Warning Please let us know ASAP if a lockdown is preventing packages or if sellers are indicating major delays. Also please keep a close eye on fulfillment times. All of the links provided here have reasonable times when we looked at them, but things can change quickly. Feel free to email with any questions. Please pay close attention to delivery time frames when ordering . We are hoping for students to be mostly equipped by approximately 4/8 For this reason, I don't recommend Amazon for the Raspberry Pi. Instead, check the following sources: PiShop.US US Shipping in 2 - 4 business days BestBuy Curbside Pickup in Seattle US shipping in about 8 days Canakit US shipping in 5 to 8 business days TL;DR \u00b6 Within the US: Order the Raspberry Pi hardware. At minimum, you will need: Board : Raspberry Pi 4 Model B (2GB version, Board Only, for $35 USD) Recommended US Seller: PiShop US Please keep the cardboard box the Pi came in as a safe place to store it when not in use. Power : Raspberry Pi 4 Power Supply (USB-C) Recommended US Seller: PiShop US Storage : A fast, microSD card, at least 8GB Recommended US Seller Ethernet Adapter : If your computer does not have an ethernet port , then you need a USB based Ethernet adapter. If your computer only has USB-A ports, you need a USB-A to Ethernet adapter Recommended US Seller If your computer only has USB-C ports, then you need a USB-C to Ethernet adapter Recommended US Seller Ethernet Cable : An ethernet cable long enough to connect your computer's ethernet port to your Raspberry Pi. Many people can find one of these at home, but you may need to purchase if you don't have one available Recommended US Seller A way to write to a microSD card. If you don't have access to a computer with a built-in SD reader/writer , a USB microSD card reader/writer will be essential. If your computer only has USB-A ports, you need a USB-A microSD card reader/writer Recommended US Seller If your computer only has USB-C ports, then you need a USB-CmicroSD card reader/writer Recommended US Seller In addition, we recommend getting these optional supplies . An inexpensive case for your Pi , though it should be pretty safe while using at home without a case. Recommended US Seller We typically recommend a USB-C battery pack rather than relying on AC (wall outlet) power, but this won't be a major issue with us meeting remotely. The battery bank must have 5 volt output at 3 amps, no less. Recommended US Seller Outside the US : Order the Raspberry Pi hardware. To do this: Please research your purchasing options and order right away if possible. To research, we recommend starting here: https://www.raspberrypi.org/products/raspberry-pi-4-model-b/ . Select 'Buy Now', then select '2GB RAM' and your country. Then select one of the options on the right. After doing some research, refer to the US guide above. You need to order the same 6 minimum parts as in the US guide above, and the optional ones are recommended too. You likely will need to use other websites for ordering parts 3 through 6. If you need help finding parts on the US list, please reach out to us. Materials: A Closer Look \u00b6 Compute \u00b6 The main hardware you need for this course is a Raspberry Pi 4 Model B. The Pi is a compact, single-board computer that can be used to create a Linux-based router and other common network components. We recommend the 2GB version of the Raspberry Pi 4 Model B, but if you ever plan to do other projects with the device after this course, feel free to upgrade to the 4GB model. We don't recommend the kits because they don't align well with our needs, and you can often save a lot of money by only buying the parts you need. That being said, feel free to buy a kit if you want it for the convenience. Make sure that you get all of the 6 required minimal parts in the list above, though. If you are shipping within the US, you may be able to get reasonable delivery times from these suppliers (Amazon is quoting one month for Seattle, so don't order it there unless you the shipping time is faster where you live): PiShop.US (Recomended) Canakit Chicago Electronics Distributors Power \u00b6 You will need something to power the Raspberry Pi. Typically in this course, we use external USB battery banks, but since this course is now remote, you can rely on AC (wall outlet) power instead. If going the AC power route, you need a USB-C power supply. We recommend the official power supply found here , but it may be easier to order it with your Pi as an add-on item. You can use another power supply if you have one, provided it meets the required specifications. The power supply needs to provide 3 amps of current at 5 volts, and needs to have a USB-C at the charging end. You can see if your power supply provides 3 amps of current by looking on the back of the power supply, where it will say something like 5V3A; 5V, 3A; 3A; or 3000mA. Note: we are talking about amps (A) and milliamps (mA), NOT milliamp-hours (mAh). If it says something smaller, like 2.4A or 1A, that won't cut it , and you need something else, like the recommended model. Also, you will need to power your Pi while your computer is on, so please don't assume you can use your only laptop charger to power your Pi! If going the battery bank power route, you will need a strong USB battery bank. We recommended this power bank that we have tested to work great with the Pi. If you want to use your own, the battery bank must have 5 volt output at 3 amps, no less, and needs to have a USB-C at the charging end. You can check if your battery bank provides 3 amps of current by looking on the back of the battery bank, where it will say something like 5V3A; 5V, 3A; 3A; or 3000mA. Note: we are talking about amps (A) and milliamps (mA), NOT milliamp-hours (mAh). If it says something smaller, like 2.4A or 1A, that won't cut it , and you need something else, like the recommended model. Storage \u00b6 In addition to the Raspberry Pi (and power), you will need a fast microSD card (> 8GB) on which to install the Linux operating system. I typically order these from Amazon to save money, but it may be easier to order with your Pi as an add-on item. Sandisk 16GB on Amazon Prime PNY 32GB on Amazon Prime Ethernet Adapter \u00b6 In addition to the Pi, please check on whether your computer has a built-in ethernet port available (most modern laptops do not). Since you will need to connect to ethernet in order to manage your Pi, you may need to purchase a USB-based Ethernet adapter . Determine whether your computer is USB-A or USB-C and then pick accordingly. If your computer only has USB-A ports, you need a USB-A to Ethernet adapter Recommended US Seller If your computer only has USB-C ports, then you need a USB-C to Ethernet adapter Recommended US Seller Ethernet Cable \u00b6 You will need an ethernet cable long enough to connect your computer's ethernet port to your Raspberry Pi. Many people can find one of these at home, but you may need to purchase if you don't have one available Recommended US Seller MicroSD Card Reader \u00b6 Finally, you will need a way to write to a microSD card. This is essential for setting up your Pi, but you shouldn't need it after the initial set-up. If you don't have access to a computer with a built-in SD reader/writer , a USB microSD card reader/writer will be essential. If your computer only has USB-A ports, you need a USB-A microSD card reader/writer Recommended US Seller If your computer only has USB-C ports, then you need a USB-CmicroSD card reader/writer Recommended US Seller Case \u00b6 An inexpensive case for your Pi is very nice to have, but is optional . The Pi by itself is a bare PCB, like a motherboard, so it is prone to damage if mishandled or placed in a bag without any other protection. Because we are remote, the Pi should be safe without a case at your house, but please keep the cardboard box the Pi came in as a safe place to store it when not in use. Most cases protect the Pi within a plastic shell. Some cases come with extra supplies, like heatsinks (metal fins that stick on the chips on the Pi to provide passive cooling), or even fans to cool the Pi. These aren't necessary for this class, but do help your Pi push itself to its limits in terms of CPU power, so they are nice especially if you are planning to use your Pi for other projects after this course. Right now on Amazon, I only found one case that does not have one-month shipping times. Recommended Case . This case comes with a nice heatsink for passive cooling. This case does not, however, come with a fan, so you may want to get a different case by doing your own research, or waiting a month for something with a fan like this case . Just make sure that the case supports a Raspberry Pi 4 Model B. \u200b","title":"Getting Pi Materials"},{"location":"resources/pi-materials/#required-class-materials","text":"In this course, you will need to purchase a Raspberry Pi 4 B. Many of the labs and exercises in this course are built around the Raspberry Pi's hardware. The Pi is a compact, single-board computer that can be used to create a Linux-based router and other common network components. Warning Please let us know ASAP if a lockdown is preventing packages or if sellers are indicating major delays. Also please keep a close eye on fulfillment times. All of the links provided here have reasonable times when we looked at them, but things can change quickly. Feel free to email with any questions. Please pay close attention to delivery time frames when ordering . We are hoping for students to be mostly equipped by approximately 4/8 For this reason, I don't recommend Amazon for the Raspberry Pi. Instead, check the following sources: PiShop.US US Shipping in 2 - 4 business days BestBuy Curbside Pickup in Seattle US shipping in about 8 days Canakit US shipping in 5 to 8 business days","title":"Required Class Materials"},{"location":"resources/pi-materials/#tldr","text":"Within the US: Order the Raspberry Pi hardware. At minimum, you will need: Board : Raspberry Pi 4 Model B (2GB version, Board Only, for $35 USD) Recommended US Seller: PiShop US Please keep the cardboard box the Pi came in as a safe place to store it when not in use. Power : Raspberry Pi 4 Power Supply (USB-C) Recommended US Seller: PiShop US Storage : A fast, microSD card, at least 8GB Recommended US Seller Ethernet Adapter : If your computer does not have an ethernet port , then you need a USB based Ethernet adapter. If your computer only has USB-A ports, you need a USB-A to Ethernet adapter Recommended US Seller If your computer only has USB-C ports, then you need a USB-C to Ethernet adapter Recommended US Seller Ethernet Cable : An ethernet cable long enough to connect your computer's ethernet port to your Raspberry Pi. Many people can find one of these at home, but you may need to purchase if you don't have one available Recommended US Seller A way to write to a microSD card. If you don't have access to a computer with a built-in SD reader/writer , a USB microSD card reader/writer will be essential. If your computer only has USB-A ports, you need a USB-A microSD card reader/writer Recommended US Seller If your computer only has USB-C ports, then you need a USB-CmicroSD card reader/writer Recommended US Seller In addition, we recommend getting these optional supplies . An inexpensive case for your Pi , though it should be pretty safe while using at home without a case. Recommended US Seller We typically recommend a USB-C battery pack rather than relying on AC (wall outlet) power, but this won't be a major issue with us meeting remotely. The battery bank must have 5 volt output at 3 amps, no less. Recommended US Seller Outside the US : Order the Raspberry Pi hardware. To do this: Please research your purchasing options and order right away if possible. To research, we recommend starting here: https://www.raspberrypi.org/products/raspberry-pi-4-model-b/ . Select 'Buy Now', then select '2GB RAM' and your country. Then select one of the options on the right. After doing some research, refer to the US guide above. You need to order the same 6 minimum parts as in the US guide above, and the optional ones are recommended too. You likely will need to use other websites for ordering parts 3 through 6. If you need help finding parts on the US list, please reach out to us.","title":"TL;DR"},{"location":"resources/pi-materials/#materials-a-closer-look","text":"","title":"Materials: A Closer Look"},{"location":"resources/pi-materials/#compute","text":"The main hardware you need for this course is a Raspberry Pi 4 Model B. The Pi is a compact, single-board computer that can be used to create a Linux-based router and other common network components. We recommend the 2GB version of the Raspberry Pi 4 Model B, but if you ever plan to do other projects with the device after this course, feel free to upgrade to the 4GB model. We don't recommend the kits because they don't align well with our needs, and you can often save a lot of money by only buying the parts you need. That being said, feel free to buy a kit if you want it for the convenience. Make sure that you get all of the 6 required minimal parts in the list above, though. If you are shipping within the US, you may be able to get reasonable delivery times from these suppliers (Amazon is quoting one month for Seattle, so don't order it there unless you the shipping time is faster where you live): PiShop.US (Recomended) Canakit Chicago Electronics Distributors","title":"Compute"},{"location":"resources/pi-materials/#power","text":"You will need something to power the Raspberry Pi. Typically in this course, we use external USB battery banks, but since this course is now remote, you can rely on AC (wall outlet) power instead. If going the AC power route, you need a USB-C power supply. We recommend the official power supply found here , but it may be easier to order it with your Pi as an add-on item. You can use another power supply if you have one, provided it meets the required specifications. The power supply needs to provide 3 amps of current at 5 volts, and needs to have a USB-C at the charging end. You can see if your power supply provides 3 amps of current by looking on the back of the power supply, where it will say something like 5V3A; 5V, 3A; 3A; or 3000mA. Note: we are talking about amps (A) and milliamps (mA), NOT milliamp-hours (mAh). If it says something smaller, like 2.4A or 1A, that won't cut it , and you need something else, like the recommended model. Also, you will need to power your Pi while your computer is on, so please don't assume you can use your only laptop charger to power your Pi! If going the battery bank power route, you will need a strong USB battery bank. We recommended this power bank that we have tested to work great with the Pi. If you want to use your own, the battery bank must have 5 volt output at 3 amps, no less, and needs to have a USB-C at the charging end. You can check if your battery bank provides 3 amps of current by looking on the back of the battery bank, where it will say something like 5V3A; 5V, 3A; 3A; or 3000mA. Note: we are talking about amps (A) and milliamps (mA), NOT milliamp-hours (mAh). If it says something smaller, like 2.4A or 1A, that won't cut it , and you need something else, like the recommended model.","title":"Power"},{"location":"resources/pi-materials/#storage","text":"In addition to the Raspberry Pi (and power), you will need a fast microSD card (> 8GB) on which to install the Linux operating system. I typically order these from Amazon to save money, but it may be easier to order with your Pi as an add-on item. Sandisk 16GB on Amazon Prime PNY 32GB on Amazon Prime","title":"Storage"},{"location":"resources/pi-materials/#ethernet-adapter","text":"In addition to the Pi, please check on whether your computer has a built-in ethernet port available (most modern laptops do not). Since you will need to connect to ethernet in order to manage your Pi, you may need to purchase a USB-based Ethernet adapter . Determine whether your computer is USB-A or USB-C and then pick accordingly. If your computer only has USB-A ports, you need a USB-A to Ethernet adapter Recommended US Seller If your computer only has USB-C ports, then you need a USB-C to Ethernet adapter Recommended US Seller","title":"Ethernet Adapter"},{"location":"resources/pi-materials/#ethernet-cable","text":"You will need an ethernet cable long enough to connect your computer's ethernet port to your Raspberry Pi. Many people can find one of these at home, but you may need to purchase if you don't have one available Recommended US Seller","title":"Ethernet Cable"},{"location":"resources/pi-materials/#microsd-card-reader","text":"Finally, you will need a way to write to a microSD card. This is essential for setting up your Pi, but you shouldn't need it after the initial set-up. If you don't have access to a computer with a built-in SD reader/writer , a USB microSD card reader/writer will be essential. If your computer only has USB-A ports, you need a USB-A microSD card reader/writer Recommended US Seller If your computer only has USB-C ports, then you need a USB-CmicroSD card reader/writer Recommended US Seller","title":"MicroSD Card Reader"},{"location":"resources/pi-materials/#case","text":"An inexpensive case for your Pi is very nice to have, but is optional . The Pi by itself is a bare PCB, like a motherboard, so it is prone to damage if mishandled or placed in a bag without any other protection. Because we are remote, the Pi should be safe without a case at your house, but please keep the cardboard box the Pi came in as a safe place to store it when not in use. Most cases protect the Pi within a plastic shell. Some cases come with extra supplies, like heatsinks (metal fins that stick on the chips on the Pi to provide passive cooling), or even fans to cool the Pi. These aren't necessary for this class, but do help your Pi push itself to its limits in terms of CPU power, so they are nice especially if you are planning to use your Pi for other projects after this course. Right now on Amazon, I only found one case that does not have one-month shipping times. Recommended Case . This case comes with a nice heatsink for passive cooling. This case does not, however, come with a fan, so you may want to get a different case by doing your own research, or waiting a month for something with a fan like this case . Just make sure that the case supports a Raspberry Pi 4 Model B. \u200b","title":"Case"},{"location":"resources/setup-frr/","text":"Getting Started with Free Range Routing (FRR) on Raspbian \u00b6 Initial Setup \u00b6 Review the project homepage at https://frrouting.org Configure the FRR Debain Repository a. Download the public key used to verify application packages: curl -s https://deb.frrouting.org/frr/keys.asc | sudo apt-key add - b. Add the repository into the list of available resources for apt: echo deb https://deb.frrouting.org/frr $(lsb_release -s -c) frr-stable | sudo tee -a /etc/apt/sources.list.d/frr.list Use apt to install FRR: sudo apt update && sudo apt install frr Give the Pi user permission to run the FRR managment client a. Run sudo usermod -aG frrvty pi to add the pi user to the frrvty management group b. Logout (exit SSH) and return in order for Linux to recognize your new privileges Enable the BGP routing daemon a. Edit /etc/frr/daemons and set bgpd=yes . b. Repeat this process for other routing daemons (if applicable). Restart FRRouting: sudo systemctl restart frr Learn the basics of navigating VTY Shell Basics \u00b6 Launch VTY shell \u00b6 To manage FRR, we will use a dedicated UI called the VTY shell. Launch the shell with the vtysh command. VTYSH modes \u00b6 While using the VTY shell, you'll need to switch between modes . While most of our work will be conducted in Configuration Mode , the shell will launch initially in Enable mode . To enter Configuration Mode, type configure terminal at the VTY shell prompt. To exit Configuration Mode and return to Enable Mode, type exit . Save Configuration (from enable mode) \u00b6 Configuration changes you make from VTY shell will take effect right away, but they do not persist between reboots due to a distinction FRR makes between the Running Config and the Startup Config . To save your changes to disk, return to Enable Mode and type write memory or copy running-config startup-config . Show the Running Config (from enable mode) \u00b6 To view the active Running Config, return to Enable Mode and enter show running-config or write terminal at the prompt. Shortcuts \u00b6 Command abbreviations are accepted in VTY shell as long as the abbreviation is unambiguous. The shell will do its best to determine your intent and complete the command. configure terminal can be abbreviated conf t quit can be abbreviated q write memory can be abbreviated w m","title":"Install Free Range Routing (FRR)"},{"location":"resources/setup-frr/#getting-started-with-free-range-routing-frr-on-raspbian","text":"","title":"Getting Started with Free Range Routing (FRR) on Raspbian"},{"location":"resources/setup-frr/#initial-setup","text":"Review the project homepage at https://frrouting.org Configure the FRR Debain Repository a. Download the public key used to verify application packages: curl -s https://deb.frrouting.org/frr/keys.asc | sudo apt-key add - b. Add the repository into the list of available resources for apt: echo deb https://deb.frrouting.org/frr $(lsb_release -s -c) frr-stable | sudo tee -a /etc/apt/sources.list.d/frr.list Use apt to install FRR: sudo apt update && sudo apt install frr Give the Pi user permission to run the FRR managment client a. Run sudo usermod -aG frrvty pi to add the pi user to the frrvty management group b. Logout (exit SSH) and return in order for Linux to recognize your new privileges Enable the BGP routing daemon a. Edit /etc/frr/daemons and set bgpd=yes . b. Repeat this process for other routing daemons (if applicable). Restart FRRouting: sudo systemctl restart frr","title":"Initial Setup"},{"location":"resources/setup-frr/#learn-the-basics-of-navigating-vty-shell-basics","text":"","title":"Learn the basics of navigating VTY Shell Basics"},{"location":"resources/setup-frr/#launch-vty-shell","text":"To manage FRR, we will use a dedicated UI called the VTY shell. Launch the shell with the vtysh command.","title":"Launch VTY shell"},{"location":"resources/setup-frr/#vtysh-modes","text":"While using the VTY shell, you'll need to switch between modes . While most of our work will be conducted in Configuration Mode , the shell will launch initially in Enable mode . To enter Configuration Mode, type configure terminal at the VTY shell prompt. To exit Configuration Mode and return to Enable Mode, type exit .","title":"VTYSH modes"},{"location":"resources/setup-frr/#save-configuration-from-enable-mode","text":"Configuration changes you make from VTY shell will take effect right away, but they do not persist between reboots due to a distinction FRR makes between the Running Config and the Startup Config . To save your changes to disk, return to Enable Mode and type write memory or copy running-config startup-config .","title":"Save Configuration (from enable mode)"},{"location":"resources/setup-frr/#show-the-running-config-from-enable-mode","text":"To view the active Running Config, return to Enable Mode and enter show running-config or write terminal at the prompt.","title":"Show the Running Config (from enable mode)"},{"location":"resources/setup-frr/#shortcuts","text":"Command abbreviations are accepted in VTY shell as long as the abbreviation is unambiguous. The shell will do its best to determine your intent and complete the command. configure terminal can be abbreviated conf t quit can be abbreviated q write memory can be abbreviated w m","title":"Shortcuts"},{"location":"resources/ssh-agent/","text":"Using the SSH Agent to Manage Login Keys \u00b6 SSH keys can provide a notable improvement over password-based security (with respect to certain threats), but they are not without inconvenience or risk. Most notably, if we don't use encryption with strong passphrases to keys on disk, an intruder or piece of malware can more easily retrieve our keys and use them to access any resources we are permitted to access. Moreover, when we encrypt our private keys, we face the potential inconvenience of supplying the passphrase each time we run ssh . To ease the burden of using keys in the proper manner, OpenSSH provides a helper service, i.e., ssh-agent , to help you manage your private keys. Once an identity has been added to the ssh-agent , the agent can use the private key to log into servers without requiring you to enter a password for the the server or supply the key's passphrase. The ssh-agent helper is available for both macOS and Windows 10 (as well as Linux), but the configuration process varies for each system. By following the instructions provided in this guide when you first set up your private keys, you'll be able to take advantage of the security improvements offered by key-based SSH authentication with OpenSSH on your macOS or Windows 10 device. Configuring ssh-agent for macOS \u00b6 Configure OpenSSH to work with ssh-agent and macOS KeyChain Launch the ssh-agent as a background service. Use ssh-add to load your keys into the agent. Step 1 \u00b6 Edit or create ~/.ssh/config so that ssh-agent and macOS KeyChain are used automatically to manage private keys and passphrases. This configuration is required by the version of ssh distributed by Apple since macOS Sierra 10.12.2. Host * AddKeysToAgent yes UseKeyChain yes Step 2 \u00b6 Launch the ssh-agent as a background service. # The eval $() syntax is used to update the current environment based on the output of the ssh-agent command $ eval \" $( ssh-agent -s ) \" Add your key to the ssh-agent using the ssh-add utility. Step 3 \u00b6 # The -K option is required for some versions of macOS. Omit if it returns an error. ssh-add -K ~/.ssh/id_ed25519 # Check that your key is loaded by listing current keys in the agent ssh-add -l Configuring ssh-agent for Windows 10 \u00b6 Enable the ssh-agent Windows Service (disabled by default). Configure Powershell to launch ssh-agent when you open a console. Use ssh-add to load your keys into the agent. Step 1 \u00b6 Launch Powershell with administrator privileges and set the startup mode for the ssh-agent service to Manual since it is configured by default as Disabled . Set-Service -Name ssh-agent -StartupType Manual Step 2 \u00b6 Open a normal (non-administrator) Powershell console and edit/create a profile script to automatically launch the ssh-agent service. In order to do this, we need to enable the ability to run basic scripts on the system and then find the location of the script (automatically assigned by Windows to the $PROFILE variable). # Modify Powershell policy to allow basic powershell scripts to run Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # Test whether the profile script exists Test-Path $PROFILE # If the previous command returns False, create the file New-Item -path $PROFILE -type file -force # Launch Notepad.exe to create a script notepad . exe $PROFILE Use Notepad to add the following code to your profile script. This will be run each time you launch a new console. # Launch the service if it's not already running $agentService = Get-Service -Name ssh-agent if ( $agentService . Status -ne \"Running\" ) { Start-Service -Name ssh-agent } Step 3 \u00b6 Open a fresh Powershell console and add your keys to the agent. # Add the private key to the ssh-agent ssh-add $HOME \\. ssh \\ id_ed25519 # Check that your key is loaded by listing current keys in the agent ssh-add -l","title":"Using ssh-agent"},{"location":"resources/ssh-agent/#using-the-ssh-agent-to-manage-login-keys","text":"SSH keys can provide a notable improvement over password-based security (with respect to certain threats), but they are not without inconvenience or risk. Most notably, if we don't use encryption with strong passphrases to keys on disk, an intruder or piece of malware can more easily retrieve our keys and use them to access any resources we are permitted to access. Moreover, when we encrypt our private keys, we face the potential inconvenience of supplying the passphrase each time we run ssh . To ease the burden of using keys in the proper manner, OpenSSH provides a helper service, i.e., ssh-agent , to help you manage your private keys. Once an identity has been added to the ssh-agent , the agent can use the private key to log into servers without requiring you to enter a password for the the server or supply the key's passphrase. The ssh-agent helper is available for both macOS and Windows 10 (as well as Linux), but the configuration process varies for each system. By following the instructions provided in this guide when you first set up your private keys, you'll be able to take advantage of the security improvements offered by key-based SSH authentication with OpenSSH on your macOS or Windows 10 device.","title":"Using the SSH Agent to Manage Login Keys"},{"location":"resources/ssh-agent/#configuring-ssh-agent-for-macos","text":"Configure OpenSSH to work with ssh-agent and macOS KeyChain Launch the ssh-agent as a background service. Use ssh-add to load your keys into the agent.","title":"Configuring ssh-agent for macOS"},{"location":"resources/ssh-agent/#step-1","text":"Edit or create ~/.ssh/config so that ssh-agent and macOS KeyChain are used automatically to manage private keys and passphrases. This configuration is required by the version of ssh distributed by Apple since macOS Sierra 10.12.2. Host * AddKeysToAgent yes UseKeyChain yes","title":"Step 1"},{"location":"resources/ssh-agent/#step-2","text":"Launch the ssh-agent as a background service. # The eval $() syntax is used to update the current environment based on the output of the ssh-agent command $ eval \" $( ssh-agent -s ) \" Add your key to the ssh-agent using the ssh-add utility.","title":"Step 2"},{"location":"resources/ssh-agent/#step-3","text":"# The -K option is required for some versions of macOS. Omit if it returns an error. ssh-add -K ~/.ssh/id_ed25519 # Check that your key is loaded by listing current keys in the agent ssh-add -l","title":"Step 3"},{"location":"resources/ssh-agent/#configuring-ssh-agent-for-windows-10","text":"Enable the ssh-agent Windows Service (disabled by default). Configure Powershell to launch ssh-agent when you open a console. Use ssh-add to load your keys into the agent.","title":"Configuring ssh-agent for Windows 10"},{"location":"resources/ssh-agent/#step-1_1","text":"Launch Powershell with administrator privileges and set the startup mode for the ssh-agent service to Manual since it is configured by default as Disabled . Set-Service -Name ssh-agent -StartupType Manual","title":"Step 1"},{"location":"resources/ssh-agent/#step-2_1","text":"Open a normal (non-administrator) Powershell console and edit/create a profile script to automatically launch the ssh-agent service. In order to do this, we need to enable the ability to run basic scripts on the system and then find the location of the script (automatically assigned by Windows to the $PROFILE variable). # Modify Powershell policy to allow basic powershell scripts to run Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # Test whether the profile script exists Test-Path $PROFILE # If the previous command returns False, create the file New-Item -path $PROFILE -type file -force # Launch Notepad.exe to create a script notepad . exe $PROFILE Use Notepad to add the following code to your profile script. This will be run each time you launch a new console. # Launch the service if it's not already running $agentService = Get-Service -Name ssh-agent if ( $agentService . Status -ne \"Running\" ) { Start-Service -Name ssh-agent }","title":"Step 2"},{"location":"resources/ssh-agent/#step-3_1","text":"Open a fresh Powershell console and add your keys to the agent. # Add the private key to the ssh-agent ssh-add $HOME \\. ssh \\ id_ed25519 # Check that your key is loaded by listing current keys in the agent ssh-add -l","title":"Step 3"},{"location":"resources/tshark-install/","text":"Install TShark \u00b6 To perform captures from your pi you will need to install tshark (command line version of wireshark) using the apt command. When prompted to allow non-root users to run packet captures, say yes . After install, run sudo usermod -aG wireshark pi and reboot . This command is adding the pi user to the wireshark group. This group was created when you installed tshark and it is used to allow non-root users to run packet captures. After rebooting, test tshark by running tshark -i wlan0 and confirming that packets are captured. Type Ctrl + C to quit capturing. Info Use the command man tshark from the pi for more info about tshark and how to use it. Performing a Capture \u00b6 Tshark is a terminal based tool, but that doesn't mean you are limited to conducting all of your analysis on the commandline. Follow along below to explore two different approaches to get your tshark captures into wireshark for analysis. Capturing to a file \u00b6 The first approach we present is the easiest, but requires some manual effort to complete the capture and copy back to your computer with ssh/scp. Once the file is saved to your computer, you can open it in Wireshark and perform analysis just as you would with a native Wireshark capture. tshark allows you to specify the interface on which to capture using the -i argument as well as a filename to record the capture using -w . You may also pass a capture filter as the final argument of the command. # Capture DNS traffic from wlan0 and write the output into a file named cap.pcapng tshark -i wlan0 -w cap.pcapng 'port 53' Live Capture to Wireshark \u00b6 With a little more effort, Wireshark can leverage tshark for a remote capture. In this case, we are launching a capture with tshark and piping the results back through the SSH session into Wireshark (instead of saving to a file on the Pi). There is an ulterior motive for sharing this method. For some students, the live capture does provide a more natural workflow. However, this is a good opportunity to give you a small taste of what SSH can accomplish 1 . Windows users Add the wireshark program directory ( c:\\program files\\wireshark\\ ) to the system path and then use the standard command prompt rather than Powershell to launch the remote capture. The following command will launch a remote capture on your Pi (see additional notes for Windows below): ssh pi@titan.local tshark -s0 -F libpcap -i wlan0 -w - 'port 53' | wireshark -k -i - Live Wireshark captures are cool, but we've hardly scratched the surface of secure shell's super powers. \u21a9","title":"Install TShark"},{"location":"resources/tshark-install/#install-tshark","text":"To perform captures from your pi you will need to install tshark (command line version of wireshark) using the apt command. When prompted to allow non-root users to run packet captures, say yes . After install, run sudo usermod -aG wireshark pi and reboot . This command is adding the pi user to the wireshark group. This group was created when you installed tshark and it is used to allow non-root users to run packet captures. After rebooting, test tshark by running tshark -i wlan0 and confirming that packets are captured. Type Ctrl + C to quit capturing. Info Use the command man tshark from the pi for more info about tshark and how to use it.","title":"Install TShark"},{"location":"resources/tshark-install/#performing-a-capture","text":"Tshark is a terminal based tool, but that doesn't mean you are limited to conducting all of your analysis on the commandline. Follow along below to explore two different approaches to get your tshark captures into wireshark for analysis.","title":"Performing a Capture"},{"location":"resources/tshark-install/#capturing-to-a-file","text":"The first approach we present is the easiest, but requires some manual effort to complete the capture and copy back to your computer with ssh/scp. Once the file is saved to your computer, you can open it in Wireshark and perform analysis just as you would with a native Wireshark capture. tshark allows you to specify the interface on which to capture using the -i argument as well as a filename to record the capture using -w . You may also pass a capture filter as the final argument of the command. # Capture DNS traffic from wlan0 and write the output into a file named cap.pcapng tshark -i wlan0 -w cap.pcapng 'port 53'","title":"Capturing to a file"},{"location":"resources/tshark-install/#live-capture-to-wireshark","text":"With a little more effort, Wireshark can leverage tshark for a remote capture. In this case, we are launching a capture with tshark and piping the results back through the SSH session into Wireshark (instead of saving to a file on the Pi). There is an ulterior motive for sharing this method. For some students, the live capture does provide a more natural workflow. However, this is a good opportunity to give you a small taste of what SSH can accomplish 1 . Windows users Add the wireshark program directory ( c:\\program files\\wireshark\\ ) to the system path and then use the standard command prompt rather than Powershell to launch the remote capture. The following command will launch a remote capture on your Pi (see additional notes for Windows below): ssh pi@titan.local tshark -s0 -F libpcap -i wlan0 -w - 'port 53' | wireshark -k -i - Live Wireshark captures are cool, but we've hardly scratched the surface of secure shell's super powers. \u21a9","title":"Live Capture to Wireshark"},{"location":"resources/vlans-and-dummies/","text":"Configuring VLANs and Dummy Interfaces in Networkd \u00b6 VLANs \u00b6 VLAN functionality in networkd enables Linux hosts to participate in VLANs based on explicit tagging of ethernet frames. VLANs provide a valuable layer of logical configurability on top of physical network infrastructure. VLAN connections are presented in Linux as software-defined network interfaces that can be configured and utilized just like other types of network interfaces. Creating VLAN Interfaces \u00b6 Networkd supports various software-defined interface types that are created based on .netdev files in the networkd configuration directories. A .netdev for a VLAN sets Kind=vlan and defines the numeric ID used to tag VLAN traffic on the wire in order to keep it separate from other traffic. Creating a VLAN interface /etc/systemd/network/15-vlan25.netdev [NetDev] Name=vlan25 Kind=vlan [VLAN] # Specify the tag Id=25 Add VLANs to a Physical Interface \u00b6 In order to send and receive tagged traffic over a network link, we need to associate the newly created VLAN interfaces with the physical LAN interface. In networkd, this can be done by adding one or more VLAN properties to the physical interface's .network configuration. After doing this, tagged frames will be presented to the operating system as originating from the associated VLAN interface. Likewise, traffic that is sent through a VLAN interface will be tagged with the specified ID before being sent on the network. Linking a VLAN interface to a physical interface /etc/systemd/network/20-eth0.network [Match] Name=eth0 [Network] # Existing Configuration Address=192.168.0.1/24 # Tagged VLANs Referenced by Interface Name VLAN=vlan25 VLAN=vlan50 Network Configuration for VLAN Interfaces \u00b6 Attaching the VLANs to a physical interface enables traffic to be sent and received from the virtual interface via tagged frames on the physical link. At the moment, however, our VLAN interfaces do not have any network-level settings attached to them. Depending on the task at hand and the configuration of the Linux host, you may configure the new interfaces by any method(s) available, including networkd: Sample VLAN interface configuration /etc/systemd/network/25-vlan25.network DHCP [Match] Name=vlan25 [Network] DHCP=ipv4 Static IP [Match] Name=vlan25 [Network] Address=172.16.0.1/24 DNS=1.1.1.1 Dummy Interfaces \u00b6 When we set up labs with multiple services hosted on a single physical node, it can be useful to virtualize additional network connections and interfaces to allow us to extend the logical topology of the system. Dummy interfaces are treated much like standard network interfaces, although they do not require a physical connection and do not go up and down based on link status. Like a standard ethernet interface, a dummy interface can be configured with an IP address and other layer-3 settings. Likewise, we can bind daemons to sockets on our dummy interfaces and respond to network requests received at these addresses. Creating the Interface \u00b6 Adding a .netdev definition with Kind=dummy will trigger networkd to add a dummy interface and make it visible to other standard networking tools. Creating a Dummy Interface /etc/systemd/network/10-dmz0.netdev [NetDev] Name=dmz0 Kind=dummy Resources \u00b6 https://wiki.archlinux.org/index.php/VLAN https://manpages.debian.org/stretch/systemd/systemd.netdev.5.en.html https://wiki.archlinux.org/index.php/systemd-networkd","title":"Special Network Interfaces (VLANs and Dummies)"},{"location":"resources/vlans-and-dummies/#configuring-vlans-and-dummy-interfaces-in-networkd","text":"","title":"Configuring VLANs and Dummy Interfaces in Networkd"},{"location":"resources/vlans-and-dummies/#vlans","text":"VLAN functionality in networkd enables Linux hosts to participate in VLANs based on explicit tagging of ethernet frames. VLANs provide a valuable layer of logical configurability on top of physical network infrastructure. VLAN connections are presented in Linux as software-defined network interfaces that can be configured and utilized just like other types of network interfaces.","title":"VLANs"},{"location":"resources/vlans-and-dummies/#creating-vlan-interfaces","text":"Networkd supports various software-defined interface types that are created based on .netdev files in the networkd configuration directories. A .netdev for a VLAN sets Kind=vlan and defines the numeric ID used to tag VLAN traffic on the wire in order to keep it separate from other traffic. Creating a VLAN interface /etc/systemd/network/15-vlan25.netdev [NetDev] Name=vlan25 Kind=vlan [VLAN] # Specify the tag Id=25","title":"Creating VLAN Interfaces"},{"location":"resources/vlans-and-dummies/#add-vlans-to-a-physical-interface","text":"In order to send and receive tagged traffic over a network link, we need to associate the newly created VLAN interfaces with the physical LAN interface. In networkd, this can be done by adding one or more VLAN properties to the physical interface's .network configuration. After doing this, tagged frames will be presented to the operating system as originating from the associated VLAN interface. Likewise, traffic that is sent through a VLAN interface will be tagged with the specified ID before being sent on the network. Linking a VLAN interface to a physical interface /etc/systemd/network/20-eth0.network [Match] Name=eth0 [Network] # Existing Configuration Address=192.168.0.1/24 # Tagged VLANs Referenced by Interface Name VLAN=vlan25 VLAN=vlan50","title":"Add VLANs to a Physical Interface"},{"location":"resources/vlans-and-dummies/#network-configuration-for-vlan-interfaces","text":"Attaching the VLANs to a physical interface enables traffic to be sent and received from the virtual interface via tagged frames on the physical link. At the moment, however, our VLAN interfaces do not have any network-level settings attached to them. Depending on the task at hand and the configuration of the Linux host, you may configure the new interfaces by any method(s) available, including networkd: Sample VLAN interface configuration /etc/systemd/network/25-vlan25.network DHCP [Match] Name=vlan25 [Network] DHCP=ipv4 Static IP [Match] Name=vlan25 [Network] Address=172.16.0.1/24 DNS=1.1.1.1","title":"Network Configuration for VLAN Interfaces"},{"location":"resources/vlans-and-dummies/#dummy-interfaces","text":"When we set up labs with multiple services hosted on a single physical node, it can be useful to virtualize additional network connections and interfaces to allow us to extend the logical topology of the system. Dummy interfaces are treated much like standard network interfaces, although they do not require a physical connection and do not go up and down based on link status. Like a standard ethernet interface, a dummy interface can be configured with an IP address and other layer-3 settings. Likewise, we can bind daemons to sockets on our dummy interfaces and respond to network requests received at these addresses.","title":"Dummy Interfaces"},{"location":"resources/vlans-and-dummies/#creating-the-interface","text":"Adding a .netdev definition with Kind=dummy will trigger networkd to add a dummy interface and make it visible to other standard networking tools. Creating a Dummy Interface /etc/systemd/network/10-dmz0.netdev [NetDev] Name=dmz0 Kind=dummy","title":"Creating the Interface"},{"location":"resources/vlans-and-dummies/#resources","text":"https://wiki.archlinux.org/index.php/VLAN https://manpages.debian.org/stretch/systemd/systemd.netdev.5.en.html https://wiki.archlinux.org/index.php/systemd-networkd","title":"Resources"},{"location":"resources/wifi-reference/","text":"WPA Supplicant Configuration Reference (2020-01-18) \u00b6 Basic Configuration \u00b6 Wireless settings for the Pi are controlled by a service called wpa_supplicant , which stores information about known wireless networks in a text-based configuration file in /etc/wpa_supplicant/ . By default, in Raspbian, the name of this file is wpa_supplicant.conf . You may also encounter an interface-specific configuration where the interface name is appended to the file, e.g., wpa_supplicant-wlan0.conf . In both cases, the file is owned by root and requires root privileges to read or edit. Security Risk wpa_supplicant.conf is protected from casual reading due to the fact that it is a sensitive file that will likely contain your home network keys and a hash of your UW NetID password. While hashes typically provide some extra protection of a stored password, MD4 is nearly useless in this regard except with really strong passwords. Practice caution with this file: Never share the contents of this file directly online. Scrub passwords, keys, and hashes before committing a copy into a repository . Reset your password if you lose your Pi or suspect that you may have disclosed it inadvertently. You can edit wpa_supplicant configs directly on the Pi using any terminal-based text editor. Alternatively, you can create the file on your local system and copy it into place on the Pi (as described later in this guide). Warning: Windows line-endings and rich text format As students get started with Linux networking, we frequently encounter problems related to the overall file format. As a rule, the configuration files you create in this class must be plain text with standard line endings. You'll want to stick to using a code-oriented text editor, as opposed to options like macOS TextEdit and Windows Notepad that often save files as rich text rather than plain text. For Windows users, a code-oriented editor will also help you avoid issues related to line endings. While most operating systems use a simple New Line (aka Line Feed) control character to signify the end of a line, most Windows tools also include a Carriage Return . This alternate line ending causes parsing errors in many Linux tools. The general structure of the configuration file is show below. The file begins with a standard set of parameters specifying the country (needed to initialize appropriate radio settings), a control interface used by network management tools, and a boolean that instructs wpa_supplicant to accept configuration updates from other network management tools. We won't delve any deeper into the meaning of these initial parameters within this course. Rather, our concern will be how to configure Linux to join nearby wireless networks. Example wpa_supplicant.conf country=US ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"Some public network\" key_mgmt=NONE } network={ ssid=\"My home network\" psk=\"Don't tell anyone the password\" } The contents of the network block will depend largely on the security settings of the network, e.g., whether or not the network is encrypted with a passphrase. This document provides instructions for configuring three common types of networks: Unencrypted Networks WPA2 Personal Networks (simple passphrase) WPA2 Enterprise Networks Let's start by examining the configuration for an unencrypted network. Unencrypted Networks \u00b6 All networks are defined by parameter=value pairs enclosed within network={} . Regardless of security configuration, each network block is required to contain an ssid parameter identifying the network. The service set identifier (SSID) is the network name that you see on your device when you connect to a wireless network. Since this name may include whitespace, we encapsulate it in double quotes. In addition to the ssid , wpa_supplicant expects us to provide encryption a passphrase and other encryption settings for the wireless network. Omitting these settings, even for an unencrypted network, will result in errors. Instead, for unencrypted networks, we explicitly disable encryption with key_mgmt=NONE . Configuration for an unencrypted network network={ ssid=\"Coffee Shop\" key_mgmt=NONE } WPA2 Personal Networks \u00b6 For a basic (non-enterprise) encrypted network, the configuration of the network block changes only slightly. Rather than specify the key_mgmt setting, we assign the network passphrase to the psk parameter. There are two ways to accomplish this task. First, we can assign the passphrase directly to the parameter in plaintext as shown here: Danger: Don't do this!!! network={ ssid=\"Home Wifi\" psk=\"super secret squirrels\" } Security professionals generally frown on plaintext passwords and passphrases being written to configuration files or code. As such, we prefer to write the configuration based on the raw network key (computed using a function called PBKDF in conjunction with SHA1 ). Using wpa_passphrase to generate a raw PSK You can generate the raw psk directly on your Pi by running the wpa_passphrase utility. This utility takes your SSID as an argument and then prompts you to enter your passphrase. # Pass your SSID as the first argument wpa_passphrase \"Home Wifi\" You will not see any characters or placeholders echoed as you type the passphrase, but wpa_passphrase will continue to accept input until you hit Enter/Return . The output will be a valid wpa_supplicant configuration that you can paste into your configuration. network={ ssid=\"Home Wifi\" psk=2508539ff867a3578f6ba7d9ee1d4a62aea82c25d30ffb1eb3a05cd08a373c02 } WPA2 Enterprise Networks \u00b6 Unlike home and coffee shop networks, enterprise networks like Eduroam , require a bit more setup since they authenticate individual users to the network as part of the process of establishing an encrypted connection. As such, these networks are substantially more secure than networks that are protected by WPA2 Personal . Eduroam at UW uses the NetID system to authenticate users and grant secure access to the network. Before you can join the network, you will first need to compute a hash from your NetID password. For security and privacy purposes, you will use this hash as a substitute for your password within the final configuration. Computing an MD4 hash in Linux Follow these commands in order to compute the MD4 hash in Linux. 1 The history commands are not needed to compute a hash but are added for security. Without them, your password will be stored in the Bash history file and easily readable to anyone with access to your memory card. set +o history echo -n 'This is your password' | iconv -t utf16le | openssl md4 # You should see output like 6f9bad2c90b80bd549e595fc91e27806 set -o history The following template supplies all of the parameters needed to attach to Eduroam at UW. Add it to your wpa_supplicant.conf , substituting your own NetID and password hash for the supplied values. Eduroam configuration template network={ ssid=\"eduroam\" scan_ssid=1 key_mgmt=WPA-EAP eap=PEAP identity=\"YOUR_NETID@uw.edu\" password=hash:6f9bad2c90b80bd549e595fc91e27806 phase1=\"peaplabel=0\" phase2=\"auth=MSCHAPV2\" } Using \"University of Washington\" instead of \"eduroam\" \u00b6 As of 1/27/20, there is an issue we are facing with the \"eduroam\" network. Temporarily, we recommend using the \"University of Washington\" WiFi instead. Please setup your Pi for connecting to eduroam, but follow this guide if that does not work. To set \"University of Washington\" up, do as follows: Find the MAC address of wlan0 on your pi using the ip link command. Make sure to select the MAC of wlan0 and not eth0 ! Register your wlan0 MAC address manually for UW WiFi at: https://itconnect.uw.edu/connect/uw-networks/campus-wi-fi/manual-wifi-reg/ Next, edit wpa_supplicant.conf again using: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf or sudo nano /etc/wpa_supplicant/wpa_supplicant-wlan0.conf depending on where you are in the setup of your Pi. Add the \u201cUniversity of Washington\u201d network. Put this definition above eduroam in your wpa_supplicant.conf file so that it will take priority. Also, add disabled=1 on a line in the eduroam section. Applying Configuration Changes \u00b6 Like other services, wpa_supplicant will not load our changes automatically. Rather than reset the daemon completely using systemctl , we can use wpa_cli to update the configuration and perform other basic maintenance. When running wpa_cli we need to specify the interface we are configuring and a command to send to the wpa_supplicant service. Load configuration from wpa_supplicant.conf # Update configuration from disk wpa_cli -i wlan0 reconfigure # Check the status of current connection wpa_cli -i wlan0 status See man wpa_cli for further instructions and examples. The project repository includes a shell script called calc-md4-hash.sh that will compute this value for you. It can be run from macOS, Linux, and Git Bash (Windows users). To run the script, navigate to the resources path in your git repository and type ./calc-md4-hash.sh . You may also copy this file to your Pi and run it there. \u21a9","title":"Linux Wireless Configuration"},{"location":"resources/wifi-reference/#wpa-supplicant-configuration-reference-2020-01-18","text":"","title":"WPA Supplicant Configuration Reference (2020-01-18)"},{"location":"resources/wifi-reference/#basic-configuration","text":"Wireless settings for the Pi are controlled by a service called wpa_supplicant , which stores information about known wireless networks in a text-based configuration file in /etc/wpa_supplicant/ . By default, in Raspbian, the name of this file is wpa_supplicant.conf . You may also encounter an interface-specific configuration where the interface name is appended to the file, e.g., wpa_supplicant-wlan0.conf . In both cases, the file is owned by root and requires root privileges to read or edit. Security Risk wpa_supplicant.conf is protected from casual reading due to the fact that it is a sensitive file that will likely contain your home network keys and a hash of your UW NetID password. While hashes typically provide some extra protection of a stored password, MD4 is nearly useless in this regard except with really strong passwords. Practice caution with this file: Never share the contents of this file directly online. Scrub passwords, keys, and hashes before committing a copy into a repository . Reset your password if you lose your Pi or suspect that you may have disclosed it inadvertently. You can edit wpa_supplicant configs directly on the Pi using any terminal-based text editor. Alternatively, you can create the file on your local system and copy it into place on the Pi (as described later in this guide). Warning: Windows line-endings and rich text format As students get started with Linux networking, we frequently encounter problems related to the overall file format. As a rule, the configuration files you create in this class must be plain text with standard line endings. You'll want to stick to using a code-oriented text editor, as opposed to options like macOS TextEdit and Windows Notepad that often save files as rich text rather than plain text. For Windows users, a code-oriented editor will also help you avoid issues related to line endings. While most operating systems use a simple New Line (aka Line Feed) control character to signify the end of a line, most Windows tools also include a Carriage Return . This alternate line ending causes parsing errors in many Linux tools. The general structure of the configuration file is show below. The file begins with a standard set of parameters specifying the country (needed to initialize appropriate radio settings), a control interface used by network management tools, and a boolean that instructs wpa_supplicant to accept configuration updates from other network management tools. We won't delve any deeper into the meaning of these initial parameters within this course. Rather, our concern will be how to configure Linux to join nearby wireless networks. Example wpa_supplicant.conf country=US ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"Some public network\" key_mgmt=NONE } network={ ssid=\"My home network\" psk=\"Don't tell anyone the password\" } The contents of the network block will depend largely on the security settings of the network, e.g., whether or not the network is encrypted with a passphrase. This document provides instructions for configuring three common types of networks: Unencrypted Networks WPA2 Personal Networks (simple passphrase) WPA2 Enterprise Networks Let's start by examining the configuration for an unencrypted network.","title":"Basic Configuration"},{"location":"resources/wifi-reference/#unencrypted-networks","text":"All networks are defined by parameter=value pairs enclosed within network={} . Regardless of security configuration, each network block is required to contain an ssid parameter identifying the network. The service set identifier (SSID) is the network name that you see on your device when you connect to a wireless network. Since this name may include whitespace, we encapsulate it in double quotes. In addition to the ssid , wpa_supplicant expects us to provide encryption a passphrase and other encryption settings for the wireless network. Omitting these settings, even for an unencrypted network, will result in errors. Instead, for unencrypted networks, we explicitly disable encryption with key_mgmt=NONE . Configuration for an unencrypted network network={ ssid=\"Coffee Shop\" key_mgmt=NONE }","title":"Unencrypted Networks"},{"location":"resources/wifi-reference/#wpa2-personal-networks","text":"For a basic (non-enterprise) encrypted network, the configuration of the network block changes only slightly. Rather than specify the key_mgmt setting, we assign the network passphrase to the psk parameter. There are two ways to accomplish this task. First, we can assign the passphrase directly to the parameter in plaintext as shown here: Danger: Don't do this!!! network={ ssid=\"Home Wifi\" psk=\"super secret squirrels\" } Security professionals generally frown on plaintext passwords and passphrases being written to configuration files or code. As such, we prefer to write the configuration based on the raw network key (computed using a function called PBKDF in conjunction with SHA1 ). Using wpa_passphrase to generate a raw PSK You can generate the raw psk directly on your Pi by running the wpa_passphrase utility. This utility takes your SSID as an argument and then prompts you to enter your passphrase. # Pass your SSID as the first argument wpa_passphrase \"Home Wifi\" You will not see any characters or placeholders echoed as you type the passphrase, but wpa_passphrase will continue to accept input until you hit Enter/Return . The output will be a valid wpa_supplicant configuration that you can paste into your configuration. network={ ssid=\"Home Wifi\" psk=2508539ff867a3578f6ba7d9ee1d4a62aea82c25d30ffb1eb3a05cd08a373c02 }","title":"WPA2 Personal Networks"},{"location":"resources/wifi-reference/#wpa2-enterprise-networks","text":"Unlike home and coffee shop networks, enterprise networks like Eduroam , require a bit more setup since they authenticate individual users to the network as part of the process of establishing an encrypted connection. As such, these networks are substantially more secure than networks that are protected by WPA2 Personal . Eduroam at UW uses the NetID system to authenticate users and grant secure access to the network. Before you can join the network, you will first need to compute a hash from your NetID password. For security and privacy purposes, you will use this hash as a substitute for your password within the final configuration. Computing an MD4 hash in Linux Follow these commands in order to compute the MD4 hash in Linux. 1 The history commands are not needed to compute a hash but are added for security. Without them, your password will be stored in the Bash history file and easily readable to anyone with access to your memory card. set +o history echo -n 'This is your password' | iconv -t utf16le | openssl md4 # You should see output like 6f9bad2c90b80bd549e595fc91e27806 set -o history The following template supplies all of the parameters needed to attach to Eduroam at UW. Add it to your wpa_supplicant.conf , substituting your own NetID and password hash for the supplied values. Eduroam configuration template network={ ssid=\"eduroam\" scan_ssid=1 key_mgmt=WPA-EAP eap=PEAP identity=\"YOUR_NETID@uw.edu\" password=hash:6f9bad2c90b80bd549e595fc91e27806 phase1=\"peaplabel=0\" phase2=\"auth=MSCHAPV2\" }","title":"WPA2 Enterprise Networks"},{"location":"resources/wifi-reference/#using-university-of-washington-instead-of-eduroam","text":"As of 1/27/20, there is an issue we are facing with the \"eduroam\" network. Temporarily, we recommend using the \"University of Washington\" WiFi instead. Please setup your Pi for connecting to eduroam, but follow this guide if that does not work. To set \"University of Washington\" up, do as follows: Find the MAC address of wlan0 on your pi using the ip link command. Make sure to select the MAC of wlan0 and not eth0 ! Register your wlan0 MAC address manually for UW WiFi at: https://itconnect.uw.edu/connect/uw-networks/campus-wi-fi/manual-wifi-reg/ Next, edit wpa_supplicant.conf again using: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf or sudo nano /etc/wpa_supplicant/wpa_supplicant-wlan0.conf depending on where you are in the setup of your Pi. Add the \u201cUniversity of Washington\u201d network. Put this definition above eduroam in your wpa_supplicant.conf file so that it will take priority. Also, add disabled=1 on a line in the eduroam section.","title":"Using \"University of Washington\" instead of \"eduroam\""},{"location":"resources/wifi-reference/#applying-configuration-changes","text":"Like other services, wpa_supplicant will not load our changes automatically. Rather than reset the daemon completely using systemctl , we can use wpa_cli to update the configuration and perform other basic maintenance. When running wpa_cli we need to specify the interface we are configuring and a command to send to the wpa_supplicant service. Load configuration from wpa_supplicant.conf # Update configuration from disk wpa_cli -i wlan0 reconfigure # Check the status of current connection wpa_cli -i wlan0 status See man wpa_cli for further instructions and examples. The project repository includes a shell script called calc-md4-hash.sh that will compute this value for you. It can be run from macOS, Linux, and Git Bash (Windows users). To run the script, navigate to the resources path in your git repository and type ./calc-md4-hash.sh . You may also copy this file to your Pi and run it there. \u21a9","title":"Applying Configuration Changes"},{"location":"resources/wireshark-install/","text":"Installing WireShark \u00b6 Install WiresShark using the instructions linked below and test that you are able to run a packet capture over your current wireless connection. Instructions (macOS) \u00b6 Download the macOS installer from the WireShark download page and proceed with the instructions at: https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallOSXInstall.html Important The latest release of WireShark shipped with a macOS specific bug that appears with a permission denied error every time the user opens a new terminal window. This is a known bug 1 in the latest installer and can be resolved by running sudo chmod 644 /etc/manpaths.d/Wireshark /etc/paths.d/Wireshark from the terminal. Instructions (Windows) \u00b6 Download the Windows installer (64-bit) from the Wireshark download page and proceed with the instructions at: https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallWinInstall.html Instructions (Linux) \u00b6 https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallUnixInstallBins.html https://github.com/Homebrew/homebrew-cask/issues/74548 \u21a9","title":"Install Wireshark"},{"location":"resources/wireshark-install/#installing-wireshark","text":"Install WiresShark using the instructions linked below and test that you are able to run a packet capture over your current wireless connection.","title":"Installing WireShark"},{"location":"resources/wireshark-install/#instructions-macos","text":"Download the macOS installer from the WireShark download page and proceed with the instructions at: https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallOSXInstall.html Important The latest release of WireShark shipped with a macOS specific bug that appears with a permission denied error every time the user opens a new terminal window. This is a known bug 1 in the latest installer and can be resolved by running sudo chmod 644 /etc/manpaths.d/Wireshark /etc/paths.d/Wireshark from the terminal.","title":"Instructions (macOS)"},{"location":"resources/wireshark-install/#instructions-windows","text":"Download the Windows installer (64-bit) from the Wireshark download page and proceed with the instructions at: https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallWinInstall.html","title":"Instructions (Windows)"},{"location":"resources/wireshark-install/#instructions-linux","text":"https://www.wireshark.org/docs/wsug_html_chunked/ChBuildInstallUnixInstallBins.html https://github.com/Homebrew/homebrew-cask/issues/74548 \u21a9","title":"Instructions (Linux)"},{"location":"resources/zone-file-format/","text":"BIND Zone Files \u00b6 A DNS zone file is a text file that describes a DNS zone and provides the list of all resource records that are defined in the zone. The zone file for an authoritative DNS server follows is composed of the following elements: Zone File Structure \u00b6 Comments beginning with a semicolon and continuing to the end of the current line. Directives such as $ORIGIN and $TTL keywords that provide default values used when interpreting DNS records. A SOA record positioned at the top of the file that defines global parameters for the zone. Additional Resource Records used to identify service-specific resources such as name servers and email servers or to map hostnames to network addresses. The following simple zone file distributed with BIND9 defines a zone description for the reserved localhost namespace: ; ; BIND data file for local loopback interface ; $TTL 604800 @ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL ; @ IN NS localhost. @ IN A 127.0.0.1 @ IN AAAA ::1 Record Format \u00b6 Standard Fields \u00b6 Each record in a zone defines a set of parameters associated with a single DNS resource. NAME is the DNS record's alphanumeric identifier (e.g., such as www or mail ). TTL informs DNS clients, such as your your OS or browser, how long they can keep the record in their local cache. The TTL field is optional for individual resource records. BIND9 will default to the value of the global $TTL directive when omitted. CLASS is a namespace identifier defined by the DNS protocol. For our purposes, the value will always be IN . TYPE describes the type of resource, e.g., NS (name server), A (address), or MX (mail server). RDATA specifies the value of the record. The format of this data is based on the record type. A few common types are given later in this document. Names \u00b6 DNS names can be given in absolute or relative form. Absolute names are commonly called fully qualified domain name (FQDN) and include all parts of the name from the the host to the root of the DNS hierarchy. When configuring DNS servers, FQDNs are always terminated with a trailing dot, e.g., www.washington.edu. . Relative names omit the domain portion of the address and the trailing dot, e.g., www . When BIND encounters a hostname without the trailing dot in a zone file, it implicitly inserts the domain portion of the address. Forgetting to terminate an absolute hostname such as www.washington.edu with the trailing period will result in errors since BIND will see the resource as www.washington.edu.washington.edu. . Shorthand \u00b6 The standard zone file format employs a number of shortcuts that allow certain fields to be omitted or shortened. BIND will use the global $TTL value as a default for records that do not specify their own. A hostname of @ is shorthand for the default domain name for the zone. This value will be explicitly defined by the $ORIGIN directive at the start of a zone file or learned implicitly by the server based on the server's configuration. When specifying multiple records in a row with the same name, you can omit the name after the first record. Common Record Types \u00b6 SOA Record Data \u00b6 A valid zone file begins with the Start of Authority record. This record provides information about the primary servers for the domain and defines parameters to control the behavior of secondary servers. RDATA for SOA includes the following fields: MNAME specifies the name server that is the primary source of data about this domain. RNAME is the email address of the administrator for the zone. RFC 2142 recommends that every domain provides a hostmaster mailbox to receive support queries related to the domain. **Special formatting applies for the RNAME (see below). SERIAL is an unsigned 32-bit version number of the zone-file used to detect updates. This number must be incremented every time the zone file is updated. RFC 1912 recommends using the numerically formatted date followed by a 2 digit revision number, i.e., YYYYMMDDnn . REFRESH defines the number of seconds after which secondary name servers should query the master for the SOA record to determine whether there are any updates to the zone. RIPE's recommendation for small and stable zones is 86400 seconds (24 hours). RETRY defines the number of seconds a secondary name server should wait to retry its refresh query if the master does not respond. RIPE's recommendation for small and stable zones is 7200 seconds (2 hours). EXPIRE defines the number of seconds before expiring the current set of records if the master does not respond. RIPE's recommendation for small and stable zones is 3600000 seconds (1000 hours). TTL defines a time to live value that is used by recent servers to determine how long to cache a negative DNS result and by older servers to determine the default TTL for resources that don't specify it explicitly. RIPE's recommendation for small and stable zones is 172800 seconds (2 days). When formatting an email address for the RNAME field, You must escape any period in the username portion of the address with a \\ and replace the @ symbol with an unescaped period. Do not escape periods in the domain portion of the address. An example can be seen in the following SOA record. ; ; Example SOA record for washington.edu ; Primary NS - hanna.cac.washington.edu ; Administrative Email - domainmaster@cac.washington.edu ; washington.edu. 462 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu. 2019021600 3600 1800 3600000 600 ; ; Use parenthesis to split the record across lines for readability ; washington.edu. 462 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu ( 2019021600 ; SERIAL 3600 ; REFRESH (1 hour) 1800 ; RETRY (30 minutes) 3600000 ; EXPIRE (1000 hours) 600 ; TTL (10 minutes) ) NS Record Data \u00b6 Name Server records are used to indicate the servers that host the zone file for a domain. A zone file will normally include its own name servers and the name servers of any subdomains. In a real world scenario, your domains should be hosted by at least two name servers. NS records refer to the hostname of a server. Assigning an IP address to a NS record is a misconfiguration. Rather a zone file can define glue records, A and AAAA address records that tie the name servers' hostnames to IP addresses. Glue records are required when a zone hosts its own authoritative name servers. ; Name Server washington.edu. 86400 IN NS hanna.cac.washington.edu. ; Glue Records hanna.cac.washington.edu. 86400 IN A 140.142.5.5 hanna.cac.washington.edu. 86400 IN AAAA 2607:4000:200:42::5 A and AAAA Record Data \u00b6 Address records map hostnames to IP addresses. The value of an A record in a BIND zone file is simply the IPv4 address in dotted decimal notation. For AAAA records, BIND supports the standard shorthand rules for IPv6. It is legal (and common) for multiple address records to be provided for a given hostname. This feature allows us to support dual stack hosts that can be reached using either IPv4 or IPv6 addresses, but it also enables us to distribute traffic between multiple servers for redundancy and load balancing. This configuration is referred to as round-robin DNS and can be seen in the following example: ; ; Subsequent DNS responses will list records in a random order ; www.washington.edu. IN A 128.95.155.134 www.washington.edu. IN A 128.95.155.197 www.washington.edu. IN A 128.95.155.198 CNAME Record Data \u00b6 Canonical Name records define aliases for hostnames. CNAME records have many uses, including mapping alternate domain registrations to a primary domain (as seen below) or to improve the stability of DNS records when we do not have direct control over the underlying infrastructure. ; ; www.uw.edu can be used as an alias for www.washington.edu ; www.uw.edu. IN CNAME www.washington.edu. While CNAME records can be quite useful, there are several important restrictions to keep in mind: Do not define a CNAME record for the apex domain name , i.e., the name of the domain without any host prefix. Do not define a CNAME as the target of an MX or NS record. The target of an MX or NS must always resolve to an A or AAAA record. Do not define any other records for a hostname that is given a CNAME record. For example, since www.uw.edu has a CNAME, it cannot also be given an A record or a TXT record. MX Record Data \u00b6 Mail Exchanger records are used to specify the servers that will receive mail for a given domain. An individual MX record include an integer priority and a hostname. It is common and recommended to define multiple MX records for a domain. The priority field is used by mail agents to determine the preferred mail server (lower values are given higher priority). ; ; Since the three servers listed here have equal priority, a mail ; agent will choose one at random. ; washington.edu. 10800 IN MX 100 mxe30.s.uw.edu. washington.edu. 10800 IN MX 100 mxe31.s.uw.edu. washington.edu. 10800 IN MX 100 mxe32.s.uw.edu. ; ; The hostnames referred to by MX records must resolve to address ; records are hosted in the zone for uw.edu, e.g., ; mxe30.s.uw.edu. 86400 IN A 173.250.227.19 TXT Record Data \u00b6 Text records hold freeform text that is generally intended for use by external services. TXT records are frequently used to: * Verify ownership of a domain, e.g., required to set up 3 rd party email hosting or obtain a certificate for TLS. * Support SPAM reduction technologies such as the Sender Policy Framework (SPF) and DomainKeys Identfied Mail (DKIM). ; ; SPF uses TXT to indicate which networks or hosts may be used to send ; email on behalf of a domain. Recipients may flag or drop email that ; originated from an alternate server. ; uw.edu. 3600 IN TXT \"v=spf1 ip4:128.95.242.222/32 ip4:128.208.0.5/32 ip4:128.208.181.0/26 ip4:140.142.32.0/24 ip4:140.142.234.128/25 ip4:173.250.227.0/24 ?all\" References \u00b6 RFC 1912: Common DNS Operational and Configuration Errors RFC 2142: Mailbox Names for Common Services, Roles, and Functions RIPE 203: Recommendations for DNS SOA Values","title":"Zone File Reference"},{"location":"resources/zone-file-format/#bind-zone-files","text":"A DNS zone file is a text file that describes a DNS zone and provides the list of all resource records that are defined in the zone. The zone file for an authoritative DNS server follows is composed of the following elements:","title":"BIND Zone Files"},{"location":"resources/zone-file-format/#zone-file-structure","text":"Comments beginning with a semicolon and continuing to the end of the current line. Directives such as $ORIGIN and $TTL keywords that provide default values used when interpreting DNS records. A SOA record positioned at the top of the file that defines global parameters for the zone. Additional Resource Records used to identify service-specific resources such as name servers and email servers or to map hostnames to network addresses. The following simple zone file distributed with BIND9 defines a zone description for the reserved localhost namespace: ; ; BIND data file for local loopback interface ; $TTL 604800 @ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL ; @ IN NS localhost. @ IN A 127.0.0.1 @ IN AAAA ::1","title":"Zone File Structure"},{"location":"resources/zone-file-format/#record-format","text":"","title":"Record Format"},{"location":"resources/zone-file-format/#standard-fields","text":"Each record in a zone defines a set of parameters associated with a single DNS resource. NAME is the DNS record's alphanumeric identifier (e.g., such as www or mail ). TTL informs DNS clients, such as your your OS or browser, how long they can keep the record in their local cache. The TTL field is optional for individual resource records. BIND9 will default to the value of the global $TTL directive when omitted. CLASS is a namespace identifier defined by the DNS protocol. For our purposes, the value will always be IN . TYPE describes the type of resource, e.g., NS (name server), A (address), or MX (mail server). RDATA specifies the value of the record. The format of this data is based on the record type. A few common types are given later in this document.","title":"Standard Fields"},{"location":"resources/zone-file-format/#names","text":"DNS names can be given in absolute or relative form. Absolute names are commonly called fully qualified domain name (FQDN) and include all parts of the name from the the host to the root of the DNS hierarchy. When configuring DNS servers, FQDNs are always terminated with a trailing dot, e.g., www.washington.edu. . Relative names omit the domain portion of the address and the trailing dot, e.g., www . When BIND encounters a hostname without the trailing dot in a zone file, it implicitly inserts the domain portion of the address. Forgetting to terminate an absolute hostname such as www.washington.edu with the trailing period will result in errors since BIND will see the resource as www.washington.edu.washington.edu. .","title":"Names"},{"location":"resources/zone-file-format/#shorthand","text":"The standard zone file format employs a number of shortcuts that allow certain fields to be omitted or shortened. BIND will use the global $TTL value as a default for records that do not specify their own. A hostname of @ is shorthand for the default domain name for the zone. This value will be explicitly defined by the $ORIGIN directive at the start of a zone file or learned implicitly by the server based on the server's configuration. When specifying multiple records in a row with the same name, you can omit the name after the first record.","title":"Shorthand"},{"location":"resources/zone-file-format/#common-record-types","text":"","title":"Common Record Types"},{"location":"resources/zone-file-format/#soa-record-data","text":"A valid zone file begins with the Start of Authority record. This record provides information about the primary servers for the domain and defines parameters to control the behavior of secondary servers. RDATA for SOA includes the following fields: MNAME specifies the name server that is the primary source of data about this domain. RNAME is the email address of the administrator for the zone. RFC 2142 recommends that every domain provides a hostmaster mailbox to receive support queries related to the domain. **Special formatting applies for the RNAME (see below). SERIAL is an unsigned 32-bit version number of the zone-file used to detect updates. This number must be incremented every time the zone file is updated. RFC 1912 recommends using the numerically formatted date followed by a 2 digit revision number, i.e., YYYYMMDDnn . REFRESH defines the number of seconds after which secondary name servers should query the master for the SOA record to determine whether there are any updates to the zone. RIPE's recommendation for small and stable zones is 86400 seconds (24 hours). RETRY defines the number of seconds a secondary name server should wait to retry its refresh query if the master does not respond. RIPE's recommendation for small and stable zones is 7200 seconds (2 hours). EXPIRE defines the number of seconds before expiring the current set of records if the master does not respond. RIPE's recommendation for small and stable zones is 3600000 seconds (1000 hours). TTL defines a time to live value that is used by recent servers to determine how long to cache a negative DNS result and by older servers to determine the default TTL for resources that don't specify it explicitly. RIPE's recommendation for small and stable zones is 172800 seconds (2 days). When formatting an email address for the RNAME field, You must escape any period in the username portion of the address with a \\ and replace the @ symbol with an unescaped period. Do not escape periods in the domain portion of the address. An example can be seen in the following SOA record. ; ; Example SOA record for washington.edu ; Primary NS - hanna.cac.washington.edu ; Administrative Email - domainmaster@cac.washington.edu ; washington.edu. 462 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu. 2019021600 3600 1800 3600000 600 ; ; Use parenthesis to split the record across lines for readability ; washington.edu. 462 IN SOA hanna.cac.washington.edu. domainmaster.cac.washington.edu ( 2019021600 ; SERIAL 3600 ; REFRESH (1 hour) 1800 ; RETRY (30 minutes) 3600000 ; EXPIRE (1000 hours) 600 ; TTL (10 minutes) )","title":"SOA Record Data"},{"location":"resources/zone-file-format/#ns-record-data","text":"Name Server records are used to indicate the servers that host the zone file for a domain. A zone file will normally include its own name servers and the name servers of any subdomains. In a real world scenario, your domains should be hosted by at least two name servers. NS records refer to the hostname of a server. Assigning an IP address to a NS record is a misconfiguration. Rather a zone file can define glue records, A and AAAA address records that tie the name servers' hostnames to IP addresses. Glue records are required when a zone hosts its own authoritative name servers. ; Name Server washington.edu. 86400 IN NS hanna.cac.washington.edu. ; Glue Records hanna.cac.washington.edu. 86400 IN A 140.142.5.5 hanna.cac.washington.edu. 86400 IN AAAA 2607:4000:200:42::5","title":"NS Record Data"},{"location":"resources/zone-file-format/#a-and-aaaa-record-data","text":"Address records map hostnames to IP addresses. The value of an A record in a BIND zone file is simply the IPv4 address in dotted decimal notation. For AAAA records, BIND supports the standard shorthand rules for IPv6. It is legal (and common) for multiple address records to be provided for a given hostname. This feature allows us to support dual stack hosts that can be reached using either IPv4 or IPv6 addresses, but it also enables us to distribute traffic between multiple servers for redundancy and load balancing. This configuration is referred to as round-robin DNS and can be seen in the following example: ; ; Subsequent DNS responses will list records in a random order ; www.washington.edu. IN A 128.95.155.134 www.washington.edu. IN A 128.95.155.197 www.washington.edu. IN A 128.95.155.198","title":"A and AAAA Record Data"},{"location":"resources/zone-file-format/#cname-record-data","text":"Canonical Name records define aliases for hostnames. CNAME records have many uses, including mapping alternate domain registrations to a primary domain (as seen below) or to improve the stability of DNS records when we do not have direct control over the underlying infrastructure. ; ; www.uw.edu can be used as an alias for www.washington.edu ; www.uw.edu. IN CNAME www.washington.edu. While CNAME records can be quite useful, there are several important restrictions to keep in mind: Do not define a CNAME record for the apex domain name , i.e., the name of the domain without any host prefix. Do not define a CNAME as the target of an MX or NS record. The target of an MX or NS must always resolve to an A or AAAA record. Do not define any other records for a hostname that is given a CNAME record. For example, since www.uw.edu has a CNAME, it cannot also be given an A record or a TXT record.","title":"CNAME Record Data"},{"location":"resources/zone-file-format/#mx-record-data","text":"Mail Exchanger records are used to specify the servers that will receive mail for a given domain. An individual MX record include an integer priority and a hostname. It is common and recommended to define multiple MX records for a domain. The priority field is used by mail agents to determine the preferred mail server (lower values are given higher priority). ; ; Since the three servers listed here have equal priority, a mail ; agent will choose one at random. ; washington.edu. 10800 IN MX 100 mxe30.s.uw.edu. washington.edu. 10800 IN MX 100 mxe31.s.uw.edu. washington.edu. 10800 IN MX 100 mxe32.s.uw.edu. ; ; The hostnames referred to by MX records must resolve to address ; records are hosted in the zone for uw.edu, e.g., ; mxe30.s.uw.edu. 86400 IN A 173.250.227.19","title":"MX Record Data"},{"location":"resources/zone-file-format/#txt-record-data","text":"Text records hold freeform text that is generally intended for use by external services. TXT records are frequently used to: * Verify ownership of a domain, e.g., required to set up 3 rd party email hosting or obtain a certificate for TLS. * Support SPAM reduction technologies such as the Sender Policy Framework (SPF) and DomainKeys Identfied Mail (DKIM). ; ; SPF uses TXT to indicate which networks or hosts may be used to send ; email on behalf of a domain. Recipients may flag or drop email that ; originated from an alternate server. ; uw.edu. 3600 IN TXT \"v=spf1 ip4:128.95.242.222/32 ip4:128.208.0.5/32 ip4:128.208.181.0/26 ip4:140.142.32.0/24 ip4:140.142.234.128/25 ip4:173.250.227.0/24 ?all\"","title":"TXT Record Data"},{"location":"resources/zone-file-format/#references","text":"RFC 1912: Common DNS Operational and Configuration Errors RFC 2142: Mailbox Names for Common Services, Roles, and Functions RIPE 203: Recommendations for DNS SOA Values","title":"References"}]}