# Lab 7 - proxy part II

## Python concepts

* slicing lists / strings
* Converting strings <> numbers
* enumeration type
* format strings, e.g., "{}: {}".format(header_name, header_value)

## Instructions

### Getting Started 

As always, create a new branch dedicated to this lab within your http-proxy repository, and at the root of your repository, open up the `http-proxy.py` script you created in Lab 6 and continue working from the same file. 

In the previous lab, we started to build the server component of your proxy. This component is designed to receive incoming requests from web clients and then eventually forward responses that were received from an upstream web server. The core of the server is established on a request parser, which we also started to develop in the last assignment.

In this lab, we'll extend the parser to handle additional HTTP request types and also HTTP responses. Likewise, we'll start to build out the client component of the proxy by writing a new function that rebuilds an HTTP request from a previously parsed message. 

### Parsing Requests (cont.)

Extend your parsing function to handle more complex HTTP requests, such as the POST or PUT type. While GET requests are terminated by an empty CRLF line after the headers, other request types append an additional message body.

From a parsing perspective, a POST or PUT request proceeds exactly like the GET request up until reading the final CRLF that follows the header section. In order to read the remainder of the message, we need to first find out the length of the body component. In HTTP 1.0, the body length is defined by an HTTP header called Content-Length.

To determine whether a message includes a body section, look for a message header called `Content-Length`.[^oversimplification] The value of `Content-Length` will be a numeric string that defines the length of the body payload. If the header exists and its integer value is non-zero, you should attempt to read _Content-Length_ bytes from the buffer and save as an additional field in your parsed message. 

If you succeed in parsing a complete message, you should remove the data from the buffer and return a dictionary containing the parts of your message back to the main event loop.

If you don't succeed, you should leave the data in the buffer and return to your connection handling loop to read more data.

[^oversimplification]: This is an oversimplification of the RFC for HTTP/1.0, but it will be sufficient
for our purposes.

### Parsing Responses
Structurally, there is almost no difference between an HTTP request with a message body and an HTTP response. In fact, the only difference from your parsers perspective is the order of fields in the first line of the message. 

Extend your parser to handle both types of messages based on an additional `message_type` argument to your parser function. Modify the behavior of the function to read the first line properly based on this argument. Include the `message_type` in the parsed message.

A standard way to represent a value representing a message type is using an enumeration, e.g.:

```python
# Required imports
from enum import Enum, auto

# Enumeration to represent message types 
class MessageType(Enum):
    REQUEST = auto()
    RESPONSE = auto()

# Use the is operator rather than == to test an enumeration …
# if message[‘type’] is MessageType.REQUEST:
```

### Build Message

Before you wrap up this lab, let's create one more component of the parser, a new function that takes a dictionary like the one generated by your parser and builds a new message (returning the message as a byte string).

The message you build should be modified in the following manner:

-   Replace the HTTP version you received with HTTP/1.0
-   Add or update a `Via` header (per RFC 7230) for the proxied connection, e.g.,
    -   `Via: 1.0 127.0.0.1:9999`
    -   If a `Via` already exists, append your entry as a comma separated value to the end of the existing header

#### Tips

-   Use python format strings to recreate the line-delimited parts of the message, ensuring you terminate each line in `\r\n` and encode as `iso-8859-1`

### Output

Once all parts of your code are working, print the following summary and close the connection. This will return to the start of your loop to listen for new connections).

**Request summary**  

* Connection Source: < IP address returned from the call to Socket.accept() >  
* HTTP Method: < Name of method, e.g., GET, OPTION, or POST  >  
* Destination: < URI extracted from the request >  
* Headers: < Comma delimited list of header names >

**Ready to forward Request**

* Target: < URI of server obtained from request >
* Message: < Raw bytes of the rebuilt request >

??? note " What are these diamonds "<   >" ?"
    These are placeholders. When you see these it means you should fill in information that is between them and then delete the symbols. It's a quick way of saying "hey something needs to be filled in" for the developer world.

### Testing your code with test.py

The resources directory of the project repository contains a simple
python script called test.py that you can use to send HTTP requests from
a file into your proxy code.

```python
# Send the request from sample-request.txt on port 9999 one line at a time with a short delay between
python3 test.py 9999 sample-request.txt

# Send the request from sample-request.txt on port 9999 250 bytes at a time with a short delay between
python3 test.py 9999 sample-request.txt 250
```


### Capturing proxied requests for testing

Use the following method to capture valid requests that you can use for
testing:

-   Open ncat to listen for incoming connections, e.g., `ncat -o <FILENAME> -l <PORT>`
-   Configure Firefox with an HTTP proxy on `127.0.0.1 <PORT>`
-   Enter the URL of an HTTP-only site into the FF address bar (the request will hang)
-   Manually stop the request from the browser
-   Verify that the request was captured in ncat (ncat will close automatically)
